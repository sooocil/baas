{"version":3,"sources":["../src/contexts/medusa.tsx","../src/contexts/session-cart.tsx","../src/utils/index.ts","../src/helpers/index.ts","../src/hooks/utils/queryKeysFactory.ts","../src/hooks/utils/useLocalStorage.ts","../src/contexts/cart.tsx","../src/hooks/store/carts/queries.ts","../src/hooks/store/carts/mutations.ts","../src/hooks/store/collections/queries.ts","../src/hooks/store/customers/queries.ts","../src/hooks/store/customers/mutations.ts","../src/hooks/store/gift-cards/queries.ts","../src/hooks/store/line-items/mutations.ts","../src/hooks/store/order-edits/queries.ts","../src/hooks/store/order-edits/mutations.ts","../src/hooks/utils/buildOptions.ts","../src/hooks/store/orders/queries.ts","../src/hooks/store/orders/mutations.ts","../src/hooks/store/payment-collections/queries.ts","../src/hooks/store/payment-collections/mutations.ts","../src/hooks/store/product-categories/queries.ts","../src/hooks/store/product-tags/queries.ts","../src/hooks/store/product-types/queries.ts","../src/hooks/store/products/queries.ts","../src/hooks/store/regions/queries.ts","../src/hooks/store/return-reasons/queries.ts","../src/hooks/store/returns/mutations.ts","../src/hooks/store/shipping-options/queries.ts","../src/hooks/store/swaps/queries.ts","../src/hooks/store/swaps/mutations.ts","../src/hooks/admin/auth/queries.ts","../src/hooks/admin/auth/mutations.ts","../src/hooks/admin/batch-jobs/queries.ts","../src/hooks/admin/batch-jobs/mutations.ts","../src/hooks/admin/claims/mutations.ts","../src/hooks/admin/products/queries.ts","../src/hooks/admin/products/mutations.ts","../src/hooks/admin/variants/queries.ts","../src/hooks/admin/orders/queries.ts","../src/hooks/admin/collections/queries.ts","../src/hooks/admin/collections/mutations.ts","../src/hooks/admin/currencies/mutations.ts","../src/hooks/admin/currencies/queries.ts","../src/hooks/admin/custom/mutations.ts","../src/hooks/admin/customer-groups/queries.ts","../src/hooks/admin/customer-groups/mutations.ts","../src/hooks/admin/customers/queries.ts","../src/hooks/admin/customers/mutations.ts","../src/hooks/admin/discounts/queries.ts","../src/hooks/admin/discounts/mutations.ts","../src/hooks/admin/gift-cards/queries.ts","../src/hooks/admin/gift-cards/mutations.ts","../src/hooks/admin/orders/mutations.ts","../src/hooks/admin/price-lists/queries.ts","../src/hooks/admin/price-lists/mutations.ts","../src/hooks/admin/custom/queries.ts","../src/hooks/admin/draft-orders/queries.ts","../src/hooks/admin/draft-orders/mutations.ts","../src/hooks/admin/inventory-item/queries.ts","../src/hooks/admin/inventory-item/mutations.ts","../src/hooks/admin/invites/queries.ts","../src/hooks/admin/invites/mutations.ts","../src/hooks/admin/notes/queries.ts","../src/hooks/admin/notes/mutations.ts","../src/hooks/admin/notifications/queries.ts","../src/hooks/admin/notifications/mutations.ts","../src/hooks/admin/order-edits/queries.ts","../src/hooks/admin/order-edits/mutations.ts","../src/hooks/admin/payment-collections/queries.ts","../src/hooks/admin/payment-collections/mutations.ts","../src/hooks/admin/payments/queries.ts","../src/hooks/admin/payments/mutations.ts","../src/hooks/admin/product-categories/queries.ts","../src/hooks/admin/product-categories/mutations.ts","../src/hooks/admin/product-tags/queries.ts","../src/hooks/admin/product-types/queries.ts","../src/hooks/admin/publishable-api-keys/queries.ts","../src/hooks/admin/publishable-api-keys/mutations.ts","../src/hooks/admin/regions/queries.ts","../src/hooks/admin/regions/mutations.ts","../src/hooks/admin/reservations/mutations.ts","../src/hooks/admin/reservations/queries.ts","../src/hooks/admin/return-reasons/queries.ts","../src/hooks/admin/return-reasons/mutations.ts","../src/hooks/admin/returns/queries.ts","../src/hooks/admin/returns/mutations.ts","../src/hooks/admin/sales-channels/queries.ts","../src/hooks/admin/sales-channels/mutations.ts","../src/hooks/admin/stock-locations/queries.ts","../src/hooks/admin/stock-locations/mutations.ts","../src/hooks/admin/shipping-options/queries.ts","../src/hooks/admin/shipping-options/mutations.ts","../src/hooks/admin/shipping-profiles/queries.ts","../src/hooks/admin/shipping-profiles/mutations.ts","../src/hooks/admin/store/queries.ts","../src/hooks/admin/store/mutations.ts","../src/hooks/admin/swaps/queries.ts","../src/hooks/admin/swaps/mutations.ts","../src/hooks/admin/tax-rates/queries.ts","../src/hooks/admin/tax-rates/mutations.ts","../src/hooks/admin/uploads/mutations.ts","../src/hooks/admin/users/queries.ts","../src/hooks/admin/users/mutations.ts"],"sourcesContent":["/**\n * @packageDocumentation\n * \n * @customNamespace Providers.Medusa\n */\n\nimport Medusa from \"@medusajs/medusa-js\"\nimport {\n  QueryClientProvider,\n  QueryClientProviderProps,\n} from \"@tanstack/react-query\"\nimport React from \"react\"\n\nexport interface MedusaContextState {\n  /**\n   * The Medusa JS Client instance.\n   */\n  client: Medusa\n}\n\nconst MedusaContext = React.createContext<MedusaContextState | null>(null)\n\n/**\n * This hook gives you access to context of {@link MedusaProvider}. It's useful if you want access to the \n * [Medusa JS Client](https://docs.medusajs.com/js-client/overview).\n * \n * @example\n * import React from \"react\"\n * import { useMeCustomer, useMedusa } from \"medusa-react\"\n * \n * const CustomerLogin = () => {\n *   const { client } = useMedusa()\n *   const { refetch: refetchCustomer } = useMeCustomer()\n *   // ...\n * \n *   const handleLogin = (\n *     email: string,\n *     password: string\n *   ) => {\n *     client.auth.authenticate({\n *       email,\n *       password\n *     })\n *     .then(() => {\n *       // customer is logged-in successfully\n *       refetchCustomer()\n *     })\n *     .catch(() => {\n *       // an error occurred.\n *     })\n *   }\n * \n *   // ...\n * }\n * \n * @customNamespace Providers.Medusa\n */\nexport const useMedusa = () => {\n  const context = React.useContext(MedusaContext)\n  if (!context) {\n    throw new Error(\"useMedusa must be used within a MedusaProvider\")\n  }\n  return context\n}\n\nexport interface MedusaProviderProps {\n  /**\n   * The URL to your Medusa backend.\n   */\n  baseUrl: string\n  /**\n   * An object used to set the Tanstack Query client. The object requires a `client` property, \n   * which should be an instance of [QueryClient](https://tanstack.com/query/v4/docs/react/reference/QueryClient).\n   */\n  queryClientProviderProps: QueryClientProviderProps\n  /**\n   * @ignore\n   */\n  children: React.ReactNode\n  /**\n   * API key used for authenticating admin requests. Follow [this guide](https://docs.medusajs.com/api/admin#authentication) to learn how to create an API key for an admin user.\n   */\n  apiKey?: string\n  /**\n   * Publishable API key used for storefront requests. You can create a publishable API key either using the \n   * [admin APIs](https://docs.medusajs.com/development/publishable-api-keys/admin/manage-publishable-api-keys) or the \n   * [Medusa admin](https://docs.medusajs.com/user-guide/settings/publishable-api-keys#create-publishable-api-key).\n   */\n  publishableApiKey?: string\n  /**\n   * Number of times to retry a request if it fails.\n   * \n   * @defaultValue 3\n   */\n  maxRetries?: number\n  /**\n   * An object of custom headers to pass with every request. Each key of the object is the name of the header, and its value is the header's value.\n   * \n   * @defaultValue `{}`\n   */\n  customHeaders?: Record<string, any>\n  /**\n   * An instance of the Medusa JS Client. If you don't provide an instance, one will be created using the `baseUrl`, `apiKey`, \n   * `publishableApiKey`, `maxRetries`, and `customHeaders` props.\n   */\n  medusaClient?: Medusa\n}\n\n/**\n * The `MedusaProvider` must be used at the highest possible point in the React component tree. Using any of `medusa-react`'s hooks or providers requires having `MedusaProvider`\n * higher in the component tree.\n * \n * @param {MedusaProviderProps} param0 - Props of the provider.\n * \n * @example\n * ```tsx title=\"src/App.ts\"\n * import { MedusaProvider } from \"medusa-react\"\n * import Storefront from \"./Storefront\"\n * import { QueryClient } from \"@tanstack/react-query\"\n * import React from \"react\"\n * \n * const queryClient = new QueryClient()\n * \n * const App = () => {\n *   return (\n *     <MedusaProvider\n *       queryClientProviderProps={{ client: queryClient }}\n *       baseUrl=\"http://localhost:9000\"\n *     >\n *       <Storefront />\n *     </MedusaProvider>\n *   )\n * }\n * \n * export default App\n * ```\n * \n * In the example above, you wrap the `Storefront` component with the `MedusaProvider`. `Storefront` is assumed to be the top-level component of your storefront, but you can place `MedusaProvider` at any point in your tree. Only children of `MedusaProvider` can benefit from its hooks.\n * \n * The `Storefront` component and its child components can now use hooks exposed by Medusa React.\n * \n * @customNamespace Providers.Medusa\n */\nexport const MedusaProvider = ({\n  queryClientProviderProps,\n  baseUrl,\n  apiKey,\n  publishableApiKey,\n  customHeaders,\n  maxRetries = 3,\n  children,\n  medusaClient = new Medusa({\n    baseUrl,\n    maxRetries,\n    apiKey,\n    publishableApiKey,\n    customHeaders,\n  }),\n}: MedusaProviderProps) => {\n  return (\n    <QueryClientProvider {...queryClientProviderProps}>\n      <MedusaContext.Provider\n        value={{\n          client: medusaClient,\n        }}\n      >\n        {children}\n      </MedusaContext.Provider>\n    </QueryClientProvider>\n  )\n}\n","/**\n * @packageDocumentation\n * \n * @customNamespace Providers.Session Cart\n */\n\nimport React, { useContext, useEffect } from \"react\"\nimport { getVariantPrice } from \"../helpers\"\nimport { useLocalStorage } from \"../hooks/utils\"\nimport { ProductVariant, RegionInfo } from \"../types\"\nimport { isArray, isEmpty, isObject } from \"../utils\"\n\n/**\n * A session cart's item.\n */\nexport interface Item {\n  /**\n   * The product variant represented by this item in the cart.\n   */\n  variant: ProductVariant\n  /**\n   * The quantity added in the cart.\n   */\n  quantity: number\n  /**\n   * The total amount of the item in the cart.\n   */\n  readonly total?: number\n}\n\nexport interface SessionCartState {\n  /**\n   * The region of the cart.\n   */\n  region: RegionInfo\n  /**\n   * The items in the cart.\n   */\n  items: Item[]\n  /**\n   * The total items in the cart.\n   */\n  totalItems: number\n  /**\n   * The total amount of the cart.\n   */\n  total: number\n}\n\nexport interface SessionCartContextState extends SessionCartState {\n  /**\n   * A state function used to set the region.\n   * \n   * @param region - The new value of the region.\n   */\n  setRegion: (region: RegionInfo) => void\n  /**\n   * This function adds an item to the session cart.\n   * \n   * @param {Item} item - The item to add.\n   */\n  addItem: (item: Item) => void\n  /**\n   * This function removes an item from the session cart.\n   * \n   * @param {string} id - The ID of the item.\n   */\n  removeItem: (id: string) => void\n  /**\n   * This function updates an item in the session cart.\n   * \n   * @param {string} id - The ID of the item.\n   * @param {Partial<Item>} item - The item's data to update.\n   */\n  updateItem: (id: string, item: Partial<Item>) => void\n  /**\n   * A state function used to set the items in the cart.\n   * \n   * @param {Item[]} items - The items to set in the cart.\n   */\n  setItems: (items: Item[]) => void\n  /**\n   * This function updates an item's quantity in the cart.\n   * \n   * @param {string} id - The ID of the item.\n   * @param {number} quantity - The new quantity of the item.\n   */\n  updateItemQuantity: (id: string, quantity: number) => void\n  /**\n   * This function increments the item's quantity in the cart.\n   * \n   * @param {string} id - The ID of the item.\n   */\n  incrementItemQuantity: (id: string) => void\n  /**\n   * This function decrements the item's quantity in the cart.\n   * \n   * @param {string} id - The ID of the item.\n   */\n  decrementItemQuantity: (id: string) => void\n  /**\n   * This function retrieves an item's details by its ID.\n   * \n   * @param {string} id - The ID of the item.\n   * @returns {Item | undefined} The item in the cart, if found.\n   */\n  getItem: (id: string) => Item | undefined\n  /**\n   * Removes all items in the cart.\n   */\n  clearItems: () => void\n}\n\nconst SessionCartContext = React.createContext<SessionCartContextState | null>(\n  null\n)\n\nenum ACTION_TYPES {\n  INIT,\n  ADD_ITEM,\n  SET_ITEMS,\n  REMOVE_ITEM,\n  UPDATE_ITEM,\n  CLEAR_ITEMS,\n  SET_REGION,\n}\n\ntype Action =\n  | { type: ACTION_TYPES.SET_REGION; payload: RegionInfo }\n  | { type: ACTION_TYPES.INIT; payload: object }\n  | { type: ACTION_TYPES.ADD_ITEM; payload: Item }\n  | {\n      type: ACTION_TYPES.UPDATE_ITEM\n      payload: { id: string; item: Partial<Item> }\n    }\n  | { type: ACTION_TYPES.REMOVE_ITEM; payload: { id: string } }\n  | { type: ACTION_TYPES.SET_ITEMS; payload: Item[] }\n  | { type: ACTION_TYPES.CLEAR_ITEMS }\n\nconst reducer = (state: SessionCartState, action: Action) => {\n  switch (action.type) {\n    case ACTION_TYPES.INIT: {\n      return state\n    }\n    case ACTION_TYPES.SET_REGION: {\n      return generateCartState(\n        {\n          ...state,\n          region: action.payload,\n        },\n        state.items\n      )\n    }\n    case ACTION_TYPES.ADD_ITEM: {\n      const duplicateVariantIndex = state.items.findIndex(\n        (item) => item.variant.id === action.payload?.variant?.id\n      )\n      if (duplicateVariantIndex !== -1) {\n        state.items.splice(duplicateVariantIndex, 1)\n      }\n      const items = [...state.items, action.payload]\n      return generateCartState(state, items)\n    }\n    case ACTION_TYPES.UPDATE_ITEM: {\n      const items = state.items.map((item) =>\n        item.variant.id === action.payload.id\n          ? { ...item, ...action.payload.item }\n          : item\n      )\n\n      return generateCartState(state, items)\n    }\n    case ACTION_TYPES.REMOVE_ITEM: {\n      const items = state.items.filter(\n        (item) => item.variant.id !== action.payload.id\n      )\n      return generateCartState(state, items)\n    }\n    case ACTION_TYPES.SET_ITEMS: {\n      return generateCartState(state, action.payload)\n    }\n    case ACTION_TYPES.CLEAR_ITEMS: {\n      return {\n        ...state,\n        items: [],\n        total: 0,\n        totalItems: 0,\n      }\n    }\n    default:\n      return state\n  }\n}\n\n/**\n * @ignore\n */\nexport const generateCartState = (state: SessionCartState, items: Item[]) => {\n  const newItems = generateItems(state.region, items)\n  return {\n    ...state,\n    items: newItems,\n    totalItems: items.reduce((sum, item) => sum + item.quantity, 0),\n    total: calculateSessionCartTotal(newItems),\n  }\n}\n\nconst generateItems = (region: RegionInfo, items: Item[]) => {\n  return items.map((item) => ({\n    ...item,\n    total: getVariantPrice(item.variant, region),\n  }))\n}\n\nconst calculateSessionCartTotal = (items: Item[]) => {\n  return items.reduce(\n    (total, item) => total + item.quantity * (item.total || 0),\n    0\n  )\n}\n\nexport interface SessionCartProviderProps {\n  /**\n   * @ignore\n   */\n  children: React.ReactNode\n  /**\n   * An optional initial value to be used for the session cart.\n   */\n  initialState?: SessionCartState\n}\n\nconst defaultInitialState: SessionCartState = {\n  region: {} as RegionInfo,\n  items: [],\n  total: 0,\n  totalItems: 0,\n}\n\n/**\n * Unlike the {@link Providers.Cart.CartProvider | CartProvider}, `SessionProvider` never interacts with the Medusa backend. It can be used to implement the user experience related to managing a cart’s items. \n * Its state variables are JavaScript objects living in the browser, but are in no way communicated with the backend.\n * \n * You can use the `SessionProvider` as a lightweight client-side cart functionality. It’s not stored in any database or on the Medusa backend.\n * \n * To use `SessionProvider`, you first have to insert it somewhere in your component tree below the {@link Providers.Medusa.MedusaProvider | MedusaProvider}. Then, in any of the child components, \n * you can use the {@link useSessionCart} hook to get access to client-side cart item functionalities.\n * \n * @param {SessionCartProviderProps} param0 - Props of the provider.\n * \n * @example\n * ```tsx title=\"src/App.ts\"\n * import { SessionProvider, MedusaProvider } from \"medusa-react\"\n * import Storefront from \"./Storefront\"\n * import { QueryClient } from \"@tanstack/react-query\"\n * import React from \"react\"\n * \n * const queryClient = new QueryClient()\n * \n * const App = () => {\n *   return (\n *     <MedusaProvider\n *       queryClientProviderProps={{ client: queryClient }}\n *       baseUrl=\"http://localhost:9000\"\n *     >\n *       <SessionProvider>\n *         <Storefront />\n *       </SessionProvider>\n *     </MedusaProvider>\n *   )\n * }\n * \n * export default App\n * ```\n * \n * @customNamespace Providers.Session Cart\n */\nexport const SessionCartProvider = ({\n  initialState = defaultInitialState,\n  children,\n}: SessionCartProviderProps) => {\n  const [saved, save] = useLocalStorage(\n    \"medusa-session-cart\",\n    JSON.stringify(initialState)\n  )\n\n  const [state, dispatch] = React.useReducer(reducer, JSON.parse(saved))\n\n  useEffect(() => {\n    save(JSON.stringify(state))\n  }, [state, save])\n\n  const setRegion = (region: RegionInfo) => {\n    if (!isObject(region) || isEmpty(region)) {\n      throw new Error(\"region must be a non-empty object\")\n    }\n\n    dispatch({ type: ACTION_TYPES.SET_REGION, payload: region })\n  }\n\n  const getItem = (id: string) => {\n    return state.items.find((item) => item.variant.id === id)\n  }\n\n  const setItems = (items: Item[]) => {\n    if (!isArray(items)) {\n      throw new Error(\"items must be an array of items\")\n    }\n\n    dispatch({ type: ACTION_TYPES.SET_ITEMS, payload: items })\n  }\n\n  const addItem = (item: Item) => {\n    if (!isObject(item) || isEmpty(item)) {\n      throw new Error(\"item must be a non-empty object\")\n    }\n\n    dispatch({ type: ACTION_TYPES.ADD_ITEM, payload: item })\n  }\n\n  const updateItem = (id: string, item: Partial<Item>) => {\n    dispatch({ type: ACTION_TYPES.UPDATE_ITEM, payload: { id, item } })\n  }\n\n  const updateItemQuantity = (id: string, quantity: number) => {\n    const item = getItem(id)\n    if (!item) return\n\n    quantity = quantity <= 0 ? 1 : quantity\n\n    dispatch({\n      type: ACTION_TYPES.UPDATE_ITEM,\n      payload: {\n        id,\n        item: {\n          ...item,\n          quantity: Math.min(item.variant.inventory_quantity, quantity),\n        },\n      },\n    })\n  }\n\n  const incrementItemQuantity = (id: string) => {\n    const item = getItem(id)\n    if (!item) return\n\n    dispatch({\n      type: ACTION_TYPES.UPDATE_ITEM,\n      payload: {\n        id,\n        item: {\n          ...item,\n          quantity: Math.min(\n            item.variant.inventory_quantity,\n            item.quantity + 1\n          ),\n        },\n      },\n    })\n  }\n\n  const decrementItemQuantity = (id: string) => {\n    const item = getItem(id)\n    if (!item) return\n\n    dispatch({\n      type: ACTION_TYPES.UPDATE_ITEM,\n      payload: {\n        id,\n        item: { ...item, quantity: Math.max(0, item.quantity - 1) },\n      },\n    })\n  }\n\n  const removeItem = (id: string) => {\n    dispatch({\n      type: ACTION_TYPES.REMOVE_ITEM,\n      payload: { id },\n    })\n  }\n\n  const clearItems = () => {\n    dispatch({\n      type: ACTION_TYPES.CLEAR_ITEMS,\n    })\n  }\n\n  return (\n    <SessionCartContext.Provider\n      value={{\n        ...state,\n        setRegion,\n        addItem,\n        updateItem,\n        updateItemQuantity,\n        incrementItemQuantity,\n        decrementItemQuantity,\n        removeItem,\n        getItem,\n        setItems,\n        clearItems,\n      }}\n    >\n      {children}\n    </SessionCartContext.Provider>\n  )\n}\n\n/**\n * This hook exposes the context of {@link SessionCartProvider}.\n * \n * @example\n * The following example assumes that you've added `SessionCartProvider` previously in the React components tree:\n * \n * ```tsx title=\"src/Products.ts\"\n * const Products = () => {\n *   const { addItem } = useSessionCart()\n *   // ...\n * \n *   function addToCart(variant: ProductVariant) {\n *     addItem({\n *       variant: variant,\n *       quantity: 1,\n *     })\n *   }\n * }\n * ```\n * \n * @customNamespace Providers.Session Cart\n */\nexport const useSessionCart = () => {\n  const context = useContext(SessionCartContext)\n  if (!context) {\n    throw new Error(\n      \"useSessionCart should be used as a child of SessionCartProvider\"\n    )\n  }\n  return context\n}\n","export const isObject = (input: any) => input instanceof Object\nexport const isArray = (input: any) => Array.isArray(input)\nexport const isEmpty = (input: any) => {\n  return (\n    input === null ||\n    input === undefined ||\n    (isObject(input) && Object.keys(input).length === 0) ||\n    (isArray(input) && (input as any[]).length === 0) ||\n    (typeof input === \"string\" && input.trim().length === 0)\n  )\n}\n","/**\n * @packageDocumentation\n * \n * `medusa-react` exposes a set of utility functions that are mainly used to retrieve or format the price of a product variant.\n * \n * @customNamespace Utilities\n */\n\nimport { ProductVariantInfo, RegionInfo } from \"../types\"\nimport { isEmpty } from \"../utils\"\n\n/**\n * @interface\n * \n * Options to format a variant's price.\n */\nexport type FormatVariantPriceParams = {\n  /**\n   * A variant's details.\n   */\n  variant: ProductVariantInfo\n  /**\n   * A region's details.\n   */\n  region: RegionInfo\n  /**\n   * Whether the computed price should include taxes or not.\n   * \n   * @defaultValue true\n   */\n  includeTaxes?: boolean\n  /**\n   * The minimum number of fraction digits to use when formatting the price. This is passed as an option to `Intl.NumberFormat` in the underlying layer. \n   * You can learn more about this method’s options in \n   * [MDN’s documentation](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/NumberFormat/NumberFormat#parameters).\n   */\n  minimumFractionDigits?: number\n  /**\n   * The maximum number of fraction digits to use when formatting the price. This is passed as an option to `Intl.NumberFormat` which is used within the utility method.\n   * You can learn more about this method’s options in \n   * [MDN’s documentation](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/NumberFormat/NumberFormat#parameters).\n   */\n  maximumFractionDigits?: number\n  /**\n   * A BCP 47 language tag. The default value is `en-US`. This is passed as a first parameter to `Intl.NumberFormat` which is used within the utility method. \n   * You can learn more about this method’s parameters in \n   * [MDN’s documentation](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/NumberFormat/NumberFormat#parameters).\n   */\n  locale?: string\n}\n\n/**\n * This utility function can be used to compute the price of a variant for a region and retrieve the formatted amount. For example, `$20.00`.\n * \n * @param {FormatVariantPriceParams} param0 - Options to format the variant's price.\n * @returns {string} The formatted price.\n * \n * @example\n * ```tsx title=\"src/Products.ts\"\n * import React from \"react\"\n * import { formatVariantPrice } from \"medusa-react\"\n * import { Product, ProductVariant } from \"@medusajs/medusa\"\n * \n * const Products = () => {\n *   // ...\n *   return (\n *     <ul>\n *       {products?.map((product: Product) => (\n *         <li key={product.id}>\n *           {product.title}\n *           <ul>\n *             {product.variants.map((variant: ProductVariant) => (\n *               <li key={variant.id}>\n *                 {formatVariantPrice({\n *                   variant,\n *                   region, // should be retrieved earlier\n *                 })}\n *               </li>\n *             ))}\n *           </ul>\n *         </li>\n *       ))}\n *     </ul>\n *   )\n * }\n * ```\n * \n * @customNamespace Utilities\n */\nexport const formatVariantPrice = ({\n  variant,\n  region,\n  includeTaxes = true,\n  ...rest\n}: FormatVariantPriceParams) => {\n  const amount = computeVariantPrice({ variant, region, includeTaxes })\n\n  return convertToLocale({\n    amount,\n    currency_code: region?.currency_code,\n    ...rest,\n  })\n}\n\n/**\n * @interface\n * \n * Options to format a variant's price.\n */\nexport type ComputeVariantPriceParams = {\n  /**\n   * A variant's details.\n   */\n  variant: ProductVariantInfo\n  /**\n   * A region's details.\n   */\n  region: RegionInfo\n  /**\n   * Whether the computed price should include taxes or not.\n   * \n   * @defaultValue true\n   */\n  includeTaxes?: boolean\n}\n\n/**\n * This utility function can be used to compute the price of a variant for a region and retrieve the amount without formatting. \n * For example, `20`. This method is used by {@link formatVariantPrice} before applying the price formatting.\n * \n * @param {ComputeVariantPriceParams} param0 - Options to compute the variant's price.\n * @returns The computed price of the variant.\n * \n * @example\n * ```tsx title=\"src/Products.ts\"\n * import React from \"react\"\n * import { computeVariantPrice } from \"medusa-react\"\n * import { Product, ProductVariant } from \"@medusajs/medusa\"\n * \n * const Products = () => {\n *   // ...\n *   return (\n *     <ul>\n *       {products?.map((product: Product) => (\n *         <li key={product.id}>\n *           {product.title}\n *           <ul>\n *             {product.variants.map((variant: ProductVariant) => (\n *               <li key={variant.id}>\n *                 {computeVariantPrice({\n *                   variant,\n *                   region, // should be retrieved earlier\n *                 })}\n *               </li>\n *             ))}\n *           </ul>\n *         </li>\n *       ))}\n *     </ul>\n *   )\n * }\n * ```\n * \n * @customNamespace Utilities\n */\nexport const computeVariantPrice = ({\n  variant,\n  region,\n  includeTaxes = true,\n}: ComputeVariantPriceParams) => {\n  const amount = getVariantPrice(variant, region)\n\n  return computeAmount({\n    amount,\n    region,\n    includeTaxes,\n  })\n}\n\n/**\n * This utility function is used to retrieve a variant's price in a region. It doesn't take into account taxes or any options, so you typically wouldn't need this function on its own.\n * It's used by the {@link computeVariantPrice} function to retrieve the variant's price in a region before computing the correct price for the options provided.\n * \n * @param {ProductVariantInfo} variant - The variant's details.\n * @param {RegionInfo} region - The region's details.\n * @returns {number} The variant's price in a region.\n * \n * @example\n * ```tsx title=\"src/Products.ts\"\n * import React from \"react\"\n * import { getVariantPrice } from \"medusa-react\"\n * import { Product, ProductVariant } from \"@medusajs/medusa\"\n * \n * const Products = () => {\n *   // ...\n *   return (\n *     <ul>\n *       {products?.map((product: Product) => (\n *         <li key={product.id}>\n *           {product.title}\n *           <ul>\n *             {product.variants.map((variant: ProductVariant) => (\n *               <li key={variant.id}>\n *                 {getVariantPrice(\n *                   variant,\n *                   region, // should be retrieved earlier\n *                 )}\n *               </li>\n *             ))}\n *           </ul>\n *         </li>\n *       ))}\n *     </ul>\n *   )\n * }\n * ```\n * \n * @customNamespace Utilities\n */\nexport const getVariantPrice = (\n  variant: ProductVariantInfo,\n  region: RegionInfo\n) => {\n  let price = variant?.prices?.find(\n    (p) =>\n      p.currency_code.toLowerCase() === region?.currency_code?.toLowerCase()\n  )\n\n  return price?.amount || 0\n}\n\n/**\n * Options to compute an amount.\n */\nexport type ComputeAmountParams = {\n  /**\n   * The original amount used for computation.\n   */\n  amount: number\n  /**\n   * The region's details.\n   */\n  region: RegionInfo\n  /**\n   * Whether the computed price should include taxes or not.\n   * \n   * @defaultValue true\n   */\n  includeTaxes?: boolean\n}\n\n/**\n * This utility function can be used to compute the price of an amount for a region and retrieve the amount without formatting. For example, `20`.\n * This function is used by {@link formatAmount} before applying the price formatting.\n * \n * The main difference between this utility function and {@link computeVariantPrice} is that you don’t need to pass a complete variant object. This can be used with any number.\n * \n * @param {ComputeAmountParams} params0 - The options to compute the amount.\n * @returns {number} The computed amount.\n * \n * @example\n * ```tsx title=\"src/MyComponent.ts\"\n * import React from \"react\"\n * import { computeAmount } from \"medusa-react\"\n * \n * const MyComponent = () => {\n *   // ...\n *   return (\n *     <div>\n *       {computeAmount({\n *         amount,\n *         region, // should be retrieved earlier\n *       })}\n *     </div>\n *   )\n * }\n * ```\n * \n * @customNamespace Utilities\n */\nexport const computeAmount = ({\n  amount,\n  region,\n  includeTaxes = true,\n}: ComputeAmountParams) => {\n  const toDecimal = convertToDecimal(amount, region)\n\n  const taxRate = includeTaxes ? getTaxRate(region) : 0\n\n  const amountWithTaxes = toDecimal * (1 + taxRate)\n\n  return amountWithTaxes\n}\n\n/**\n * Options to format an amount.\n */\nexport type FormatAmountParams = {\n  /**\n   * The original amount used for computation.\n   */\n  amount: number\n  /**\n   * The region's details.\n   */\n  region: RegionInfo\n  /**\n   * Whether the computed price should include taxes or not.\n   * \n   * @defaultValue true\n   */\n  includeTaxes?: boolean\n  /**\n   * The minimum number of fraction digits to use when formatting the price. This is passed as an option to `Intl.NumberFormat` in the underlying layer. \n   * You can learn more about this method’s options in \n   * [MDN’s documentation](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/NumberFormat/NumberFormat#parameters).\n   */\n  minimumFractionDigits?: number\n  /**\n   * The maximum number of fraction digits to use when formatting the price. This is passed as an option to `Intl.NumberFormat` which is used within the utility method. \n   * You can learn more about this method’s options in \n   * [MDN’s documentation](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/NumberFormat/NumberFormat#parameters).\n   */\n  maximumFractionDigits?: number\n  /**\n   * A BCP 47 language tag. The default value is `en-US`. This is passed as a first parameter to `Intl.NumberFormat` which is used within the utility method. \n   * You can learn more about this method’s parameters in \n   * [MDN’s documentation](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/NumberFormat/NumberFormat#parameters).\n   */\n  locale?: string\n}\n\n/**\n * This utility function can be used to compute the price of an amount for a region and retrieve the formatted amount. For example, `$20.00`.\n * \n * The main difference between this utility function and {@link formatVariantPrice} is that you don’t need to pass a complete variant object. This can be used with any number.\n * \n * @param {FormatAmountParams} param0 - Options to format the amount.\n * @returns {string} The formatted price.\n * \n * @example\n * import React from \"react\"\n * import { formatVariantPrice } from \"medusa-react\"\n * import { Product, ProductVariant } from \"@medusajs/medusa\"\n * \n * const Products = () => {\n *   // ...\n *   return (\n *     <ul>\n *       {products?.map((product: Product) => (\n *         <li key={product.id}>\n *           {product.title}\n *           <ul>\n *             {product.variants.map((variant: ProductVariant) => (\n *               <li key={variant.id}>\n *                 {formatVariantPrice({\n *                   variant,\n *                   region, // should be retrieved earlier\n *                 })}\n *               </li>\n *             ))}\n *           </ul>\n *         </li>\n *       ))}\n *     </ul>\n *   )\n * }\n * \n * @customNamespace Utilities\n */\nexport const formatAmount = ({\n  amount,\n  region,\n  includeTaxes = true,\n  ...rest\n}: FormatAmountParams) => {\n  const taxAwareAmount = computeAmount({\n    amount,\n    region,\n    includeTaxes,\n  })\n  return convertToLocale({\n    amount: taxAwareAmount,\n    currency_code: region.currency_code,\n    ...rest,\n  })\n}\n\n// we should probably add a more extensive list\nconst noDivisionCurrencies = [\"krw\", \"jpy\", \"vnd\"]\n\nconst convertToDecimal = (amount: number, region: RegionInfo) => {\n  const divisor = noDivisionCurrencies.includes(\n    region?.currency_code?.toLowerCase()\n  )\n    ? 1\n    : 100\n\n  return Math.floor(amount) / divisor\n}\n\nconst getTaxRate = (region?: RegionInfo) => {\n  return region && !isEmpty(region) ? region?.tax_rate / 100 : 0\n}\n\nconst convertToLocale = ({\n  amount,\n  currency_code,\n  minimumFractionDigits,\n  maximumFractionDigits,\n  locale = \"en-US\",\n}: ConvertToLocaleParams) => {\n  return currency_code && !isEmpty(currency_code)\n    ? new Intl.NumberFormat(locale, {\n        style: \"currency\",\n        currency: currency_code,\n        minimumFractionDigits,\n        maximumFractionDigits,\n      }).format(amount)\n    : amount.toString()\n}\n\ntype ConvertToLocaleParams = {\n  amount: number\n  currency_code: string\n  minimumFractionDigits?: number\n  maximumFractionDigits?: number\n  locale?: string\n}\n\n/**\n * @internal We need to export these types so that they're included in the generated reference documentation.\n */\nexport { ProductVariantInfo, RegionInfo }","import { TQueryKey } from \"../../types\"\n\nexport const queryKeysFactory = <\n  T,\n  TListQueryType = any,\n  TDetailQueryType = string\n>(\n  globalKey: T\n) => {\n  const queryKeyFactory: TQueryKey<T, TListQueryType, TDetailQueryType> = {\n    all: [globalKey],\n    lists: () => [...queryKeyFactory.all, \"list\"],\n    list: (query?: TListQueryType) => [...queryKeyFactory.lists(), { query }],\n    details: () => [...queryKeyFactory.all, \"detail\"],\n    detail: (id: TDetailQueryType) => [...queryKeyFactory.details(), id],\n  }\n  return queryKeyFactory\n}\n","import * as React from \"react\"\n\nexport const useLocalStorage = (key: string, initialState: string) => {\n  const [item, setItem] = React.useState(() => {\n    try {\n      const item =\n        typeof window !== \"undefined\" && window.localStorage.getItem(key)\n\n      return item || initialState\n    } catch (err) {\n      return initialState\n    }\n  })\n\n  const save = (data: string) => {\n    setItem(data)\n\n    if (typeof window !== \"undefined\") {\n      window.localStorage.setItem(key, data)\n    }\n  }\n\n  const remove = () => {\n    if (typeof window !== \"undefined\") {\n      window.localStorage.removeItem(key)\n    }\n  }\n\n  return [item, save, remove] as const\n}\n","/**\n * @packageDocumentation\n * \n * @customNamespace Providers.Cart\n */\n\nimport React, { useState } from \"react\"\nimport {\n  useAddShippingMethodToCart,\n  useCompleteCart,\n  useCreateCart,\n  useSetPaymentSession,\n  useUpdateCart,\n  useCreatePaymentSession,\n} from \"../hooks/store/\"\nimport { Cart } from \"../types\"\n\ninterface CartState {\n  /**\n   * The currently-used cart.\n   */\n  cart?: Cart\n}\n\n/**\n * The cart context available if the {@link CartProvider} is used previously in the React components tree.\n */\nexport interface CartContext extends CartState {\n  /**\n   * A state function used to set the cart object.\n   * \n   * @param {Cart} cart - The new value of the cart.\n   */\n  setCart: (cart: Cart) => void\n  /**\n   * A mutation used to select a payment processor during checkout.\n   * Using it is equivalent to using the {@link useSetPaymentSession} mutation.\n   */\n  pay: ReturnType<typeof useSetPaymentSession>\n  /**\n   * A mutation used to create a cart.\n   * Using it is equivalent to using the {@link useCreateCart} mutation.\n   */\n  createCart: ReturnType<typeof useCreateCart>\n  /**\n   * A mutation used to initialize payment sessions during checkout.\n   * Using it is equivalent to using the {@link useCreatePaymentSession} mutation.\n   */\n  startCheckout: ReturnType<typeof useCreatePaymentSession>\n  /**\n   * A mutation used to complete the cart and place the order.\n   * Using it is equivalent to using the {@link useCompleteCart} mutation.\n   */\n  completeCheckout: ReturnType<typeof useCompleteCart>\n  /**\n   * A mutation used to update a cart’s details such as region, customer email, shipping address, and more.\n   * Using it is equivalent to using the {@link useUpdateCart} mutation.\n   */\n  updateCart: ReturnType<typeof useUpdateCart>\n  /**\n   * A mutation used to add a shipping method to the cart during checkout.\n   * Using it is equivalent to using the {@link useAddShippingMethodToCart} mutation.\n   */\n  addShippingMethod: ReturnType<typeof useAddShippingMethodToCart>\n  /**\n   * The number of items in the cart.\n   */\n  totalItems: number\n}\n\nconst CartContext = React.createContext<CartContext | null>(null)\n\n/**\n * This hook exposes the context of {@link CartProvider}.\n * \n * The context provides helper functions and mutations for managing the cart and checkout. You can refer to the following guides for examples on how to use them:\n * \n * - [How to Add Cart Functionality](https://docs.medusajs.com/modules/carts-and-checkout/storefront/implement-cart)\n * - [How to Implement Checkout Flow](https://docs.medusajs.com/modules/carts-and-checkout/storefront/implement-checkout-flow)\n * \n * @example\n * ```tsx title=\"src/Cart.ts\"\n * import * as React from \"react\"\n * \n * import { useCart } from \"medusa-react\"\n * \n * const Cart = () => {\n *   const handleClick = () => {\n *     createCart.mutate({}) // create an empty cart\n *   }\n * \n *   const { cart, createCart } = useCart()\n * \n *   return (\n *     <div>\n *       {createCart.isLoading && <div>Loading...</div>}\n *       {!cart?.id && (\n *         <button onClick={handleClick}>\n *           Create cart\n *         </button>\n *       )}\n *       {cart?.id && (\n *         <div>Cart ID: {cart.id}</div>\n *       )}\n *     </div>\n *   )\n * }\n * \n * export default Cart\n * ```\n * \n * In the example above, you retrieve the `createCart` mutation and `cart` state object using the `useCart` hook. \n * If the `cart` is not set, a button is shown. When the button is clicked, the `createCart` mutation is executed, which interacts with the backend and creates a new cart.\n * \n * After the cart is created, the `cart` state variable is set and its ID is shown instead of the button.\n * \n * :::note\n * \n * The example above does not store in the browser the ID of the cart created, so the cart’s data will be gone on refresh. \n * You would have to do that using the browser’s [Local Storage](https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage).\n * \n * :::\n * \n * @customNamespace Providers.Cart\n */\nexport const useCart = () => {\n  const context = React.useContext(CartContext)\n  if (!context) {\n    throw new Error(\"useCart must be used within a CartProvider\")\n  }\n  return context\n}\n\nexport interface CartProps {\n  /**\n   * @ignore\n   */\n  children: React.ReactNode\n  /**\n   * An optional initial value to be used for the cart.\n   */\n  initialState?: Cart\n}\n\nconst defaultInitialState = {\n  id: \"\",\n  items: [] as any,\n} as Cart\n\n/**\n * `CartProvider` makes use of some of the hooks already exposed by `medusa-react` to perform cart operations on the Medusa backend. \n * You can use it to create a cart, start the checkout flow, authorize payment sessions, and so on.\n * \n * It also manages one single global piece of state which represents a cart, exactly like the one created on your Medusa backend.\n * \n * To use `CartProvider`, you first have to insert it somewhere in your component tree below the {@link Providers.Medusa.MedusaProvider | MedusaProvider}. Then, in any of the child components, \n * you can use the {@link useCart} hook exposed by `medusa-react` to get access to cart operations and data.\n * \n * @param {CartProps} param0 - Props of the provider.\n * \n * @example\n * ```tsx title=\"src/App.ts\"\n * import { CartProvider, MedusaProvider } from \"medusa-react\"\n * import Storefront from \"./Storefront\"\n * import { QueryClient } from \"@tanstack/react-query\"\n * import React from \"react\"\n * \n * const queryClient = new QueryClient()\n * \n * function App() {\n *   return (\n *     <MedusaProvider\n *       queryClientProviderProps={{ client: queryClient }}\n *       baseUrl=\"http://localhost:9000\"\n *     >\n *       <CartProvider>\n *         <Storefront />\n *       </CartProvider>\n *     </MedusaProvider>\n *   )\n * }\n * \n * export default App\n * ```\n * \n * @customNamespace Providers.Cart\n */\nexport const CartProvider = ({\n  children,\n  initialState = defaultInitialState,\n}: CartProps) => {\n  const [cart, setCart] = useState<Cart>(initialState)\n\n  const createCart = useCreateCart({\n    onSuccess: ({ cart }) => setCart(cart),\n  })\n\n  const updateCart = useUpdateCart(cart?.id, {\n    onSuccess: ({ cart }) => setCart(cart),\n  })\n\n  const addShippingMethod = useAddShippingMethodToCart(cart?.id, {\n    onSuccess: ({ cart }) => setCart(cart),\n  })\n\n  const startCheckout = useCreatePaymentSession(cart?.id, {\n    onSuccess: ({ cart }) => setCart(cart),\n  })\n\n  const pay = useSetPaymentSession(cart?.id, {\n    onSuccess: ({ cart }) => {\n      setCart(cart)\n    },\n  })\n\n  const completeCheckout = useCompleteCart(cart?.id)\n\n  const totalItems = cart?.items\n    .map(i => i.quantity)\n    .reduce((acc, curr) => acc + curr, 0)\n\n  return (\n    <CartContext.Provider\n      value={{\n        cart,\n        setCart,\n        createCart,\n        pay,\n        startCheckout,\n        completeCheckout,\n        updateCart,\n        addShippingMethod,\n        totalItems: totalItems || 0,\n      }}\n    >\n      {children}\n    </CartContext.Provider>\n  )\n}\n","import { StoreCartsRes } from \"@medusajs/medusa\"\nimport { Response } from \"@medusajs/medusa-js\"\nimport { useQuery } from \"@tanstack/react-query\"\nimport { useMedusa } from \"../../../contexts/medusa\"\nimport { UseQueryOptionsWrapper } from \"../../../types\"\nimport { queryKeysFactory } from \"../../utils/index\"\n\nconst CARTS_QUERY_KEY = `carts` as const\n\nexport const cartKeys = queryKeysFactory(CARTS_QUERY_KEY)\ntype CartQueryKey = typeof cartKeys\n\n/**\n * This hook retrieves a Cart's details. This includes recalculating its totals.\n * \n * @example\n * import React from \"react\"\n * import { useGetCart } from \"medusa-react\"\n * \n * type Props = {\n *   cartId: string\n * }\n * \n * const Cart = ({ cartId }: Props) => {\n *   const { cart, isLoading } = useGetCart(cartId)\n * \n *   return (\n *     <div>\n *       {isLoading && <span>Loading...</span>}\n *       {cart && cart.items.length === 0 && (\n *         <span>Cart is empty</span>\n *       )}\n *       {cart && cart.items.length > 0 && (\n *         <ul>\n *           {cart.items.map((item) => (\n *             <li key={item.id}>{item.title}</li>\n *           ))}\n *         </ul>\n *       )}\n *     </div>\n *   )\n * }\n * \n * export default Cart\n * \n * @customNamespace Hooks.Store.Carts\n * @category Queries\n */\nexport const useGetCart = (\n  /**\n   * The cart's ID.\n   */\n  id: string,\n  options?: UseQueryOptionsWrapper<\n    Response<StoreCartsRes>,\n    Error,\n    ReturnType<CartQueryKey[\"detail\"]>\n  >\n) => {\n  const { client } = useMedusa()\n  const { data, ...rest } = useQuery(\n    cartKeys.detail(id),\n    () => client.carts.retrieve(id),\n    options\n  )\n  return { ...data, ...rest } as const\n}\n","import {\n  StoreCartsRes,\n  StoreCompleteCartRes,\n  StorePostCartReq,\n  StorePostCartsCartPaymentSessionReq,\n  StorePostCartsCartPaymentSessionUpdateReq,\n  StorePostCartsCartReq,\n  StorePostCartsCartShippingMethodReq,\n} from \"@medusajs/medusa\"\nimport { useMutation, UseMutationOptions } from \"@tanstack/react-query\"\nimport { useMedusa } from \"../../../contexts/medusa\"\n\n/**\n * The details of the cart to create.\n */\nexport type CreateCartReq = StorePostCartReq | undefined\n\n/**\n * This hook creates a Cart. Although optional, specifying the cart's region and sales channel can affect the cart's pricing and\n * the products that can be added to the cart respectively.\n * \n * So, make sure to set those early on and change them if necessary, such as when the customer changes their region.\n * \n * If a customer is logged in, make sure to pass its ID or email within the cart's details so that the cart is attached to the customer.\n * \n * @example\n * import React from \"react\"\n * import { useCreateCart } from \"medusa-react\"\n * \n * type Props = {\n *   regionId: string\n * }\n * \n * const Cart = ({ regionId }: Props) => {\n *   const createCart = useCreateCart()\n * \n *   const handleCreate = () => {\n *     createCart.mutate({\n *       region_id: regionId\n *       // creates an empty cart\n *     }, {\n *       onSuccess: ({ cart }) => {\n *         console.log(cart.items)\n *       }\n *     })\n *   }\n *   \n *   // ...\n * }\n * \n * export default Cart\n * \n * @customNamespace Hooks.Store.Carts\n * @category Mutations\n */\nexport const useCreateCart = (\n  options?: UseMutationOptions<\n    StoreCartsRes,\n    Error,\n    StorePostCartReq | undefined\n  >\n) => {\n  const { client } = useMedusa()\n  return useMutation(\n    (data?: StorePostCartReq | undefined) => client.carts.create(data),\n    options\n  )\n}\n\n/**\n * This hook updates a Cart's details. If the cart has payment sessions and the region was not changed, \n * the payment sessions are updated. The cart's totals are also recalculated.\n * \n * @example\n * import React from \"react\"\n * import { useUpdateCart } from \"medusa-react\"\n * \n * type Props = {\n *   cartId: string\n * }\n * \n * const Cart = ({ cartId }: Props) => {\n *   const updateCart = useUpdateCart(cartId)\n * \n *   const handleUpdate = (\n *     email: string\n *   ) => {\n *     updateCart.mutate({\n *       email\n *     }, {\n *       onSuccess: ({ cart }) => {\n *         console.log(cart.email)\n *       }\n *     })\n *   }\n *   \n *   // ...\n * }\n * \n * export default Cart\n * \n * @customNamespace Hooks.Store.Carts\n * @category Mutations\n */\nexport const useUpdateCart = (\n  /**\n   * The cart's ID.\n   */\n  cartId: string,\n  options?: UseMutationOptions<StoreCartsRes, Error, StorePostCartsCartReq>\n) => {\n  const { client } = useMedusa()\n  return useMutation(\n    (data: StorePostCartsCartReq) => client.carts.update(cartId, data),\n    options\n  )\n}\n\n/**\n * This hook completes a cart and place an order or create a swap, based on the cart's type. This includes attempting to authorize the cart's payment.\n * If authorizing the payment requires more action, the cart will not be completed and the order will not be placed or the swap will not be created.\n * An idempotency key will be generated if none is provided in the header `Idempotency-Key` and added to\n * the response. If an error occurs during cart completion or the request is interrupted for any reason, the cart completion can be retried by passing the idempotency\n * key in the `Idempotency-Key` header.\n * \n * @example\n * import React from \"react\"\n * import { useCompleteCart } from \"medusa-react\"\n * \n * type Props = {\n *   cartId: string\n * }\n * \n * const Cart = ({ cartId }: Props) => {\n *   const completeCart = useCompleteCart(cartId)\n * \n *   const handleComplete = () => {\n *     completeCart.mutate(void 0, {\n *       onSuccess: ({ data, type }) => {\n *         console.log(data.id, type)\n *       }\n *     })\n *   }\n *   \n *   // ...\n * }\n * \n * export default Cart\n * \n * @customNamespace Hooks.Store.Carts\n * @category Mutations\n */\nexport const useCompleteCart = (\n  /**\n   * The cart's ID.\n   */\n  cartId: string,\n  options?: UseMutationOptions<StoreCompleteCartRes, Error>\n) => {\n  const { client } = useMedusa()\n  return useMutation(() => client.carts.complete(cartId), options)\n}\n\n/**\n * This hook creates Payment Sessions for each of the available Payment Providers in the Cart's Region. If there's only one payment session created,\n * it will be selected by default. The creation of the payment session uses the payment provider and may require sending requests to third-party services.\n * \n * @example\n * import React from \"react\"\n * import { useCreatePaymentSession } from \"medusa-react\"\n * \n * type Props = {\n *   cartId: string\n * }\n * \n * const Cart = ({ cartId }: Props) => {\n *   const createPaymentSession = useCreatePaymentSession(cartId)\n * \n *   const handleComplete = () => {\n *     createPaymentSession.mutate(void 0, {\n *       onSuccess: ({ cart }) => {\n *         console.log(cart.payment_sessions)\n *       }\n *     })\n *   }\n *   \n *   // ...\n * }\n * \n * export default Cart\n * \n * @customNamespace Hooks.Store.Carts\n * @category Mutations\n */\nexport const useCreatePaymentSession = (\n  /**\n   * The cart's ID.\n   */\n  cartId: string,\n  options?: UseMutationOptions<StoreCartsRes, Error>\n) => {\n  const { client } = useMedusa()\n  return useMutation(() => client.carts.createPaymentSessions(cartId), options)\n}\n\n/**\n * The details of the payment session to update.\n */\nexport type UpdatePaymentSessionReq = StorePostCartsCartPaymentSessionUpdateReq & {\n  /**\n   * The payment provider's identifier.\n   */\n  provider_id: string\n}\n\n/**\n * This hook updates a Payment Session with additional data. This can be useful depending on the payment provider used.\n * All payment sessions are updated and cart totals are recalculated afterwards.\n * \n * @example\n * import React from \"react\"\n * import { useUpdatePaymentSession } from \"medusa-react\"\n * \n * type Props = {\n *   cartId: string\n * }\n * \n * const Cart = ({ cartId }: Props) => {\n *   const updatePaymentSession = useUpdatePaymentSession(cartId)\n * \n *   const handleUpdate = (\n *     providerId: string,\n *     data: Record<string, unknown>\n *   ) => {\n *     updatePaymentSession.mutate({\n *       provider_id: providerId,\n *       data\n *     }, {\n *       onSuccess: ({ cart }) => {\n *         console.log(cart.payment_session)\n *       }\n *     })\n *   }\n *   \n *   // ...\n * }\n * \n * export default Cart\n * \n * @customNamespace Hooks.Store.Carts\n * @category Mutations\n */\nexport const useUpdatePaymentSession = (\n  /**\n   * The cart's ID.\n   */\n  cartId: string,\n  options?: UseMutationOptions<\n    StoreCartsRes,\n    Error,\n    UpdatePaymentSessionReq\n  >\n) => {\n  const { client } = useMedusa()\n  return useMutation(\n    ({ data, provider_id }: UpdatePaymentSessionReq) =>\n      client.carts.updatePaymentSession(cartId, provider_id, { data }),\n    options\n  )\n}\n\n/**\n * The details of the payment session to refresh.\n */\nexport type RefreshPaymentSessionMutationData = {\n  /**\n   * The payment provider's identifier.\n   */\n  provider_id: string\n}\n\n/**\n * This hook refreshes a Payment Session to ensure that it is in sync with the Cart. This is usually not necessary, but is provided for edge cases.\n * \n * @example\n * import React from \"react\"\n * import { useRefreshPaymentSession } from \"medusa-react\"\n * \n * type Props = {\n *   cartId: string\n * }\n * \n * const Cart = ({ cartId }: Props) => {\n *   const refreshPaymentSession = useRefreshPaymentSession(cartId)\n * \n *   const handleRefresh = (\n *     providerId: string\n *   ) => {\n *     refreshPaymentSession.mutate({\n *       provider_id: providerId,\n *     }, {\n *       onSuccess: ({ cart }) => {\n *         console.log(cart.payment_sessions)\n *       }\n *     })\n *   }\n *   \n *   // ...\n * }\n * \n * export default Cart\n * \n * @customNamespace Hooks.Store.Carts\n * @category Mutations\n */\nexport const useRefreshPaymentSession = (\n  /**\n   * The cart's ID.\n   */\n  cartId: string,\n  options?: UseMutationOptions<\n    StoreCartsRes,\n    Error,\n    RefreshPaymentSessionMutationData\n  >\n) => {\n  const { client } = useMedusa()\n  return useMutation(\n    ({ provider_id }: RefreshPaymentSessionMutationData) =>\n      client.carts.refreshPaymentSession(cartId, provider_id),\n    options\n  )\n}\n\n/**\n * This hook selects the Payment Session that will be used to complete the cart. This is typically used when the customer chooses their preferred payment method during checkout.\n * The totals of the cart will be recalculated.\n * \n * @example\n * import React from \"react\"\n * import { useSetPaymentSession } from \"medusa-react\"\n * \n * type Props = {\n *   cartId: string\n * }\n * \n * const Cart = ({ cartId }: Props) => {\n *   const setPaymentSession = useSetPaymentSession(cartId)\n * \n *   const handleSetPaymentSession = (\n *     providerId: string\n *   ) => {\n *     setPaymentSession.mutate({\n *       provider_id: providerId,\n *     }, {\n *       onSuccess: ({ cart }) => {\n *         console.log(cart.payment_session)\n *       }\n *     })\n *   }\n *   \n *   // ...\n * }\n * \n * export default Cart\n * \n * @customNamespace Hooks.Store.Carts\n * @category Mutations\n */\nexport const useSetPaymentSession = (\n  /**\n   * The cart's ID.\n   */\n  cartId: string,\n  options?: UseMutationOptions<\n    StoreCartsRes,\n    Error,\n    StorePostCartsCartPaymentSessionReq\n  >\n) => {\n  const { client } = useMedusa()\n  return useMutation(\n    (data: StorePostCartsCartPaymentSessionReq) =>\n      client.carts.setPaymentSession(cartId, data),\n    options\n  )\n}\n\n/**\n * This hook adds a shipping method to the cart. The validation of the `data` field is handled by the fulfillment provider of the chosen shipping option.\n * \n * @example\n * import React from \"react\"\n * import { useAddShippingMethodToCart } from \"medusa-react\"\n * \n * type Props = {\n *   cartId: string\n * }\n * \n * const Cart = ({ cartId }: Props) => {\n *   const addShippingMethod = useAddShippingMethodToCart(cartId)\n * \n *   const handleAddShippingMethod = (\n *     optionId: string\n *   ) => {\n *     addShippingMethod.mutate({\n *       option_id: optionId,\n *     }, {\n *       onSuccess: ({ cart }) => {\n *         console.log(cart.shipping_methods)\n *       }\n *     })\n *   }\n *   \n *   // ...\n * }\n * \n * export default Cart\n * \n * @customNamespace Hooks.Store.Carts\n * @category Mutations\n */\nexport const useAddShippingMethodToCart = (\n  /**\n   * The cart's ID.\n   */\n  cartId: string,\n  options?: UseMutationOptions<\n    StoreCartsRes,\n    Error,\n    StorePostCartsCartShippingMethodReq\n  >\n) => {\n  const { client } = useMedusa()\n  return useMutation(\n    (data: StorePostCartsCartShippingMethodReq) =>\n      client.carts.addShippingMethod(cartId, data),\n    options\n  )\n}\n\n/**\n * The details of the payment session to delete.\n */\nexport type DeletePaymentSessionMutationData = {\n  /**\n   * The payment provider's identifier.\n   */\n  provider_id: string\n}\n\n/**\n * This hook deletes a Payment Session in a Cart. May be useful if a payment has failed. The totals will be recalculated.\n * \n * @example\n * import React from \"react\"\n * import { useDeletePaymentSession } from \"medusa-react\"\n * \n * type Props = {\n *   cartId: string\n * }\n * \n * const Cart = ({ cartId }: Props) => {\n *   const deletePaymentSession = useDeletePaymentSession(cartId)\n * \n *   const handleDeletePaymentSession = (\n *     providerId: string\n *   ) => {\n *     deletePaymentSession.mutate({\n *       provider_id: providerId,\n *     }, {\n *       onSuccess: ({ cart }) => {\n *         console.log(cart.payment_sessions)\n *       }\n *     })\n *   }\n *   \n *   // ...\n * }\n * \n * export default Cart\n * \n * @customNamespace Hooks.Store.Carts\n * @category Mutations\n */\nexport const useDeletePaymentSession = (\n  /**\n   * The cart's ID.\n   */\n  cartId: string,\n  options?: UseMutationOptions<\n    StoreCartsRes,\n    Error,\n    DeletePaymentSessionMutationData\n  >\n) => {\n  const { client } = useMedusa()\n  return useMutation(\n    ({ provider_id }: DeletePaymentSessionMutationData) =>\n      client.carts.deletePaymentSession(cartId, provider_id),\n    options\n  )\n}\n\n/**\n * This hook allows you to create a cart and set its payment session as a preparation for checkout.\n * It performs the same actions as the {@link useCreateCart} and {@link useCreatePaymentSession} hooks.\n * \n * @example\n * import React from \"react\"\n * import { useStartCheckout } from \"medusa-react\"\n * \n * type Props = {\n *   regionId: string\n * }\n * \n * const Checkout = ({ regionId }: Props) => {\n *   const startCheckout = useStartCheckout()\n * \n *   const handleCheckout = () => {\n *     startCheckout.mutate({\n *       region_id: regionId,\n *     }, {\n *       onSuccess: (cart) => {\n *         console.log(cart.payment_sessions)\n *       }\n *     })\n *   }\n *   \n *   // ...\n * }\n * \n * export default Checkout\n * \n * @customNamespace Hooks.Store.Carts\n * @category Mutations\n */\nexport const useStartCheckout = (\n  options?: UseMutationOptions<StoreCartsRes[\"cart\"], Error, StorePostCartReq>\n) => {\n  const { client } = useMedusa()\n  const mutation = useMutation(async (data?: StorePostCartReq) => {\n    const { cart } = await client.carts.create(data)\n    const res = await client.carts.createPaymentSessions(cart.id)\n    return res.cart\n  }, options)\n\n  return mutation\n}\n","import {\n  StoreCollectionsListRes,\n  StoreCollectionsRes,\n  StoreGetCollectionsParams,\n} from \"@medusajs/medusa\"\nimport { Response } from \"@medusajs/medusa-js\"\nimport { useQuery } from \"@tanstack/react-query\"\nimport { useMedusa } from \"../../../contexts/medusa\"\nimport { UseQueryOptionsWrapper } from \"../../../types\"\nimport { queryKeysFactory } from \"../../utils/index\"\n\nconst COLLECTIONS_QUERY_KEY = `collections` as const\n\nexport const collectionKeys = queryKeysFactory(COLLECTIONS_QUERY_KEY)\n\ntype CollectionQueryKey = typeof collectionKeys\n\n/**\n * This hook retrieves a product collection's details.\n * \n * @example\n * import React from \"react\"\n * import { useCollection } from \"medusa-react\"\n * \n * type Props = {\n *   collectionId: string\n * }\n * \n * const ProductCollection = ({ collectionId }: Props) => {\n *   const { collection, isLoading } = useCollection(collectionId)\n * \n *   return (\n *     <div>\n *       {isLoading && <span>Loading...</span>}\n *       {collection && <span>{collection.title}</span>}\n *     </div>\n *   )\n * }\n * \n * export default ProductCollection\n * \n * @customNamespace Hooks.Store.Product Collections\n * @category Queries\n */\nexport const useCollection = (\n  /**\n   * The product collection's ID.\n   */\n  id: string,\n  options?: UseQueryOptionsWrapper<\n    Response<StoreCollectionsRes>,\n    Error,\n    ReturnType<CollectionQueryKey[\"detail\"]>\n  >\n) => {\n  const { client } = useMedusa()\n  const { data, ...rest } = useQuery(\n    collectionKeys.detail(id),\n    () => client.collections.retrieve(id),\n    options\n  )\n  return { ...data, ...rest } as const\n}\n\n/**\n * This hook retrieves a list of product collections. The product collections can be filtered by fields such as `handle` or `created_at` passed in the `query` parameter. \n * The product collections can also be paginated.\n * \n * @example\n * To list product collections:\n * \n * ```tsx\n * import React from \"react\"\n * import { useCollections } from \"medusa-react\"\n * \n * const ProductCollections = () => {\n *   const { collections, isLoading } = useCollections()\n * \n *   return (\n *     <div>\n *       {isLoading && <span>Loading...</span>}\n *       {collections && collections.length === 0 && (\n *         <span>No Product Collections</span>\n *       )}\n *       {collections && collections.length > 0 && (\n *         <ul>\n *           {collections.map((collection) => (\n *             <li key={collection.id}>{collection.title}</li>\n *           ))}\n *         </ul>\n *       )}\n *     </div>\n *   )\n * }\n * \n * export default ProductCollections\n * ```\n * \n * By default, only the first `10` records are retrieved. You can control pagination by specifying the `limit` and `offset` properties:\n * \n * ```tsx\n * import React from \"react\"\n * import { useCollections } from \"medusa-react\"\n * \n * const ProductCollections = () => {\n *   const { \n *     collections, \n *     limit,\n *     offset,\n *     isLoading\n *   } = useCollections({\n *     limit: 20,\n *     offset: 0\n *   })\n * \n *   return (\n *     <div>\n *       {isLoading && <span>Loading...</span>}\n *       {collections && collections.length === 0 && (\n *         <span>No Product Collections</span>\n *       )}\n *       {collections && collections.length > 0 && (\n *         <ul>\n *           {collections.map((collection) => (\n *             <li key={collection.id}>{collection.title}</li>\n *           ))}\n *         </ul>\n *       )}\n *     </div>\n *   )\n * }\n * \n * export default ProductCollections\n * ```\n * \n * @customNamespace Hooks.Store.Product Collections\n * @category Queries\n */\nexport const useCollections = (\n  /**\n   * Filters and pagination configurations to apply on the retrieved product collections.\n   */\n  query?: StoreGetCollectionsParams,\n  options?: UseQueryOptionsWrapper<\n    Response<StoreCollectionsListRes>,\n    Error,\n    ReturnType<CollectionQueryKey[\"list\"]>\n  >\n) => {\n  const { client } = useMedusa()\n  const { data, ...rest } = useQuery(\n    collectionKeys.list(query),\n    () => client.collections.list(query),\n    options\n  )\n  return { ...data, ...rest } as const\n}\n","import {\n  StoreCustomersListOrdersRes,\n  StoreCustomersRes,\n  StoreGetCustomersCustomerOrdersParams,\n} from \"@medusajs/medusa\"\nimport { Response } from \"@medusajs/medusa-js\"\nimport { useQuery } from \"@tanstack/react-query\"\nimport { useMedusa } from \"../../../contexts\"\nimport { UseQueryOptionsWrapper } from \"../../../types\"\nimport { queryKeysFactory } from \"../../utils/index\"\n\nconst CUSTOMERS_QUERY_KEY = `customers` as const\n\nexport const customerKeys = {\n  ...queryKeysFactory(CUSTOMERS_QUERY_KEY),\n  orders: (id: string) => [...customerKeys.detail(id), \"orders\"] as const,\n}\n\ntype CustomerQueryKey = typeof customerKeys\n\n/**\n * This hook retrieves the logged-in customer's details. It requires [customer authentication](https://docs.medusajs.com/medusa-react/overview#customer-authentication).\n * \n * @example\n * import React from \"react\"\n * import { useMeCustomer } from \"medusa-react\"\n * \n * const Customer = () => {\n *   const { customer, isLoading } = useMeCustomer()\n * \n *   return (\n *     <div>\n *       {isLoading && <span>Loading...</span>}\n *       {customer && (\n *         <span>{customer.first_name} {customer.last_name}</span>\n *       )}\n *     </div>\n *   )\n * }\n * \n * export default Customer\n * \n * @customNamespace Hooks.Store.Customers\n * @category Queries\n */\nexport const useMeCustomer = (\n  options?: UseQueryOptionsWrapper<\n    Response<StoreCustomersRes>,\n    Error,\n    ReturnType<CustomerQueryKey[\"detail\"]>\n  >\n) => {\n  const { client } = useMedusa()\n  const { data, ...rest } = useQuery(\n    customerKeys.detail(\"me\"),\n    () => client.customers.retrieve(),\n    options\n  )\n  return { ...data, ...rest } as const\n}\n\n/**\n * This hook retrieves a list of the logged-in customer's orders. The orders can be filtered by fields such as `status` or `fulfillment_status`. The orders can also be paginated.\n * This hook requires [customer authentication](https://docs.medusajs.com/medusa-react/overview#customer-authentication).\n * \n * @example\n * import React from \"react\"\n * import { useCustomerOrders } from \"medusa-react\"\n * \n * const Orders = () => {\n *   // refetch a function that can be used to\n *   // re-retrieve orders after the customer logs in\n *   const { orders, isLoading } = useCustomerOrders()\n * \n *   return (\n *     <div>\n *       {isLoading && <span>Loading orders...</span>}\n *       {orders?.length && (\n *         <ul>\n *           {orders.map((order) => (\n *             <li key={order.id}>{order.display_id}</li>\n *           ))}\n *         </ul>\n *       )}\n *     </div>\n *   )\n * }\n * \n * export default Orders\n * \n * @customNamespace Hooks.Store.Customers\n * @category Queries\n */\nexport const useCustomerOrders = (\n  /**\n   * Filters and pagination configurations to apply on the retrieved orders.\n   */\n  query: StoreGetCustomersCustomerOrdersParams = { limit: 10, offset: 0 },\n  options?: UseQueryOptionsWrapper<\n    Response<StoreCustomersListOrdersRes>,\n    Error,\n    ReturnType<CustomerQueryKey[\"orders\"]>\n  >\n) => {\n  const { client } = useMedusa()\n  const { data, ...rest } = useQuery(\n    customerKeys.orders(\"me\"),\n    () => client.customers.listOrders(query),\n    options\n  )\n\n  return { ...data, ...rest } as const\n}\n","import {\n  StoreCustomersRes,\n  StorePostCustomersCustomerReq,\n  StorePostCustomersReq,\n} from \"@medusajs/medusa\"\nimport { UseMutationOptions, useMutation } from \"@tanstack/react-query\"\nimport { useMedusa } from \"../../../contexts/medusa\"\n\n/**\n * This hook registers a new customer. This will also automatically authenticate the customer and set their login session in the response Cookie header.\n * Subsequent requests sent with other hooks are sent with the Cookie session automatically.\n * \n * @example\n * import React from \"react\"\n * import { useCreateCustomer } from \"medusa-react\"\n * \n * const RegisterCustomer = () => {\n *   const createCustomer = useCreateCustomer()\n *   // ...\n * \n *   const handleCreate = (\n *     customerData: {\n *       first_name: string\n *       last_name: string\n *       email: string\n *       password: string\n *     }\n *   ) => {\n *     // ...\n *     createCustomer.mutate(customerData, {\n *       onSuccess: ({ customer }) => {\n *         console.log(customer.id)\n *       }\n *     })\n *   }\n * \n *   // ...\n * }\n * \n * export default RegisterCustomer\n * \n * @customNamespace Hooks.Store.Customers\n * @category Mutations\n */\nexport const useCreateCustomer = (\n  options?: UseMutationOptions<StoreCustomersRes, Error, StorePostCustomersReq>\n) => {\n  const { client } = useMedusa()\n  return useMutation(\n    (data: StorePostCustomersReq) => client.customers.create(data),\n    options\n  )\n}\n\nexport type UpdateMeReq = StorePostCustomersCustomerReq & { \n  /**\n   * The customer's ID.\n   */\n  id: string\n}\n\n/**\n * This hook updates the logged-in customer's details. This hook requires [customer authentication](https://docs.medusajs.com/medusa-react/overview#customer-authentication).\n * \n * @example\n * import React from \"react\"\n * import { useUpdateMe } from \"medusa-react\"\n * \n * type Props = {\n *   customerId: string\n * }\n * \n * const Customer = ({ customerId }: Props) => {\n *   const updateCustomer = useUpdateMe()\n *   // ...\n * \n *   const handleUpdate = (\n *     firstName: string\n *   ) => {\n *     // ...\n *     updateCustomer.mutate({\n *       id: customerId,\n *       first_name: firstName,\n *     }, {\n *       onSuccess: ({ customer }) => {\n *         console.log(customer.first_name)\n *       }\n *     })\n *   }\n * \n *   // ...\n * }\n * \n * export default Customer\n * \n * @customNamespace Hooks.Store.Customers\n * @category Mutations\n */\nexport const useUpdateMe = (\n  options?: UseMutationOptions<\n    StoreCustomersRes,\n    Error,\n    UpdateMeReq\n  >\n) => {\n  const { client } = useMedusa()\n  return useMutation(\n    ({ id, ...data }: UpdateMeReq) =>\n      client.customers.update(data),\n    options\n  )\n}\n","import { StoreGiftCardsRes } from \"@medusajs/medusa\"\nimport { Response } from \"@medusajs/medusa-js\"\nimport { useQuery } from \"@tanstack/react-query\"\nimport { useMedusa } from \"../../../contexts\"\nimport { UseQueryOptionsWrapper } from \"../../../types\"\nimport { queryKeysFactory } from \"../../utils/index\"\n\nconst GIFT_CARDS_QUERY_KEY = `gift_cards` as const\n\nexport const giftCardKeys = queryKeysFactory(GIFT_CARDS_QUERY_KEY)\n\ntype GiftCardQueryKey = typeof giftCardKeys\n\n/**\n * This hook retrieves a Gift Card's details by its associated unique code.\n * \n * @example\n * import React from \"react\"\n * import { useGiftCard } from \"medusa-react\"\n * \n * type Props = {\n *   giftCardCode: string\n * }\n * \n * const GiftCard = ({ giftCardCode }: Props) => {\n *   const { gift_card, isLoading, isError } = useGiftCard(\n *     giftCardCode\n *   )\n * \n *   return (\n *     <div>\n *       {isLoading && <span>Loading...</span>}\n *       {gift_card && <span>{gift_card.value}</span>}\n *       {isError && <span>Gift Card does not exist</span>}\n *     </div>\n *   )\n * }\n * \n * export default GiftCard\n * \n * @customNamespace Hooks.Store.Gift Cards\n * @category Queries\n */\nexport const useGiftCard = (\n  /**\n   * The gift card's ID.\n   */\n  id: string,\n  options?: UseQueryOptionsWrapper<\n    Response<StoreGiftCardsRes>,\n    Error,\n    ReturnType<GiftCardQueryKey[\"detail\"]>\n  >\n) => {\n  const { client } = useMedusa()\n  const { data, ...rest } = useQuery(\n    giftCardKeys.detail(id),\n    () => client.giftCards.retrieve(id),\n    options\n  )\n  return { ...data, ...rest } as const\n}\n","import {\n  StoreCartsRes,\n  StorePostCartsCartLineItemsItemReq,\n  StorePostCartsCartLineItemsReq,\n} from \"@medusajs/medusa\"\nimport { useMutation, UseMutationOptions } from \"@tanstack/react-query\"\nimport { useMedusa } from \"../../../contexts\"\n\n/**\n * This hook generates a Line Item with a given Product Variant and adds it to the Cart.\n * \n * @example\n * import React from \"react\"\n * import { useCreateLineItem } from \"medusa-react\"\n * \n * type Props = {\n *   cartId: string\n * }\n * \n * const Cart = ({ cartId }: Props) => {\n *   const createLineItem = useCreateLineItem(cartId)\n * \n *   const handleAddItem = (\n *     variantId: string,\n *     quantity: number\n *   ) => {\n *     createLineItem.mutate({\n *       variant_id: variantId,\n *       quantity,\n *     }, {\n *       onSuccess: ({ cart }) => {\n *         console.log(cart.items)\n *       }\n *     })\n *   }\n * \n *   // ...\n * }\n * \n * export default Cart\n * \n * @customNamespace Hooks.Store.Line Items\n * @category Mutations\n */\nexport const useCreateLineItem = (\n  /**\n   * The cart's ID.\n   */\n  cartId: string,\n  options?: UseMutationOptions<\n    StoreCartsRes,\n    Error,\n    StorePostCartsCartLineItemsReq\n  >\n) => {\n  const { client } = useMedusa()\n  return useMutation(\n    (data: StorePostCartsCartLineItemsReq) =>\n      client.carts.lineItems.create(cartId, data),\n    options\n  )\n}\n\nexport type UpdateLineItemReq = StorePostCartsCartLineItemsItemReq & { \n  /**\n   * The line item's ID.\n   */\n  lineId: string\n}\n\n/**\n * This hook updates a line item's data.\n * \n * @example\n * import React from \"react\"\n * import { useUpdateLineItem } from \"medusa-react\"\n * \n * type Props = {\n *   cartId: string\n * }\n * \n * const Cart = ({ cartId }: Props) => {\n *   const updateLineItem = useUpdateLineItem(cartId)\n * \n *   const handleUpdateItem = (\n *     lineItemId: string,\n *     quantity: number\n *   ) => {\n *     updateLineItem.mutate({\n *       lineId: lineItemId,\n *       quantity,\n *     }, {\n *       onSuccess: ({ cart }) => {\n *         console.log(cart.items)\n *       }\n *     })\n *   }\n * \n *   // ...\n * }\n * \n * export default Cart\n * \n * @customNamespace Hooks.Store.Line Items\n * @category Mutations\n */\nexport const useUpdateLineItem = (\n  /**\n   * The cart's ID.\n   */\n  cartId: string,\n  options?: UseMutationOptions<\n    StoreCartsRes,\n    Error,\n    UpdateLineItemReq\n  >\n) => {\n  const { client } = useMedusa()\n  return useMutation(\n    ({\n      lineId,\n      ...data\n    }: UpdateLineItemReq) =>\n      client.carts.lineItems.update(cartId, lineId, data),\n    options\n  )\n}\n\n/**\n * This hook deletes a line item from a cart. The payment sessions will be updated and the totals will be recalculated.\n * \n * @example\n * import React from \"react\"\n * import { useDeleteLineItem } from \"medusa-react\"\n * \n * type Props = {\n *   cartId: string\n * }\n * \n * const Cart = ({ cartId }: Props) => {\n *   const deleteLineItem = useDeleteLineItem(cartId)\n * \n *   const handleDeleteItem = (\n *     lineItemId: string\n *   ) => {\n *     deleteLineItem.mutate({\n *       lineId: lineItemId,\n *     }, {\n *       onSuccess: ({ cart }) => {\n *         console.log(cart.items)\n *       }\n *     })\n *   }\n * \n *   // ...\n * }\n * \n * export default Cart\n * \n * @customNamespace Hooks.Store.Line Items\n * @category Mutations\n */\nexport const useDeleteLineItem = (\n  /**\n   * The cart's ID.\n   */\n  cartId: string,\n  options?: UseMutationOptions<StoreCartsRes, Error, { \n    /**\n     * The line item's ID.\n     */\n    lineId: string\n  }>\n) => {\n  const { client } = useMedusa()\n  return useMutation(\n    ({ lineId }: { lineId: string }) =>\n      client.carts.lineItems.delete(cartId, lineId),\n    options\n  )\n}\n","import { StoreOrderEditsRes } from \"@medusajs/medusa\"\nimport { Response } from \"@medusajs/medusa-js\"\nimport { useQuery } from \"@tanstack/react-query\"\nimport { useMedusa } from \"../../../contexts\"\nimport { UseQueryOptionsWrapper } from \"../../../types\"\nimport { queryKeysFactory } from \"../../utils\"\n\nconst ORDER_EDITS_QUERY_KEY = `orderEdit` as const\n\nexport const orderEditQueryKeys = queryKeysFactory<\n  typeof ORDER_EDITS_QUERY_KEY\n>(ORDER_EDITS_QUERY_KEY)\n\ntype OrderQueryKey = typeof orderEditQueryKeys\n\n/**\n * This hook retrieves an Order Edit's details.\n * \n * @example\n * import React from \"react\"\n * import { useOrderEdit } from \"medusa-react\"\n * \n * type Props = {\n *   orderEditId: string\n * }\n * \n * const OrderEdit = ({ orderEditId }: Props) => {\n *   const { order_edit, isLoading } = useOrderEdit(orderEditId)\n * \n *   return (\n *     <div>\n *       {isLoading && <span>Loading...</span>}\n *       {order_edit && (\n *         <ul>\n *           {order_edit.changes.map((change) => (\n *             <li key={change.id}>{change.type}</li>\n *           ))}\n *         </ul>\n *       )}\n *     </div>\n *   )\n * }\n * \n * export default OrderEdit\n * \n * @customNamespace Hooks.Store.Order Edits\n * @category Queries\n */\nexport const useOrderEdit = (\n  /**\n   * The order edit's ID.\n   */\n  id: string,\n  options?: UseQueryOptionsWrapper<\n    Response<StoreOrderEditsRes>,\n    Error,\n    ReturnType<OrderQueryKey[\"detail\"]>\n  >\n) => {\n  const { client } = useMedusa()\n  const { data, ...rest } = useQuery(\n    orderEditQueryKeys.detail(id),\n    () => client.orderEdits.retrieve(id),\n    options\n  )\n\n  return { ...data, ...rest } as const\n}\n","import { Response } from \"@medusajs/medusa-js\"\nimport {\n  useMutation,\n  UseMutationOptions,\n  useQueryClient,\n} from \"@tanstack/react-query\"\n\nimport {\n  StoreOrderEditsRes,\n  StorePostOrderEditsOrderEditDecline,\n} from \"@medusajs/medusa\"\n\nimport { useMedusa } from \"../../../contexts\"\nimport { buildOptions } from \"../../utils/buildOptions\"\nimport { orderEditQueryKeys } from \"./queries\"\n\n/**\n * This hook declines an Order Edit. The changes are not reflected on the original order.\n * \n * @example\n * import React from \"react\"\n * import { useDeclineOrderEdit } from \"medusa-react\"\n * \n * type Props = {\n *   orderEditId: string\n * }\n * \n * const OrderEdit = ({ orderEditId }: Props) => {\n *   const declineOrderEdit = useDeclineOrderEdit(orderEditId)\n *   // ...\n * \n *   const handleDeclineOrderEdit = (\n *     declinedReason: string\n *   ) => {\n *     declineOrderEdit.mutate({\n *       declined_reason: declinedReason,\n *     }, {\n *       onSuccess: ({ order_edit }) => {\n *         console.log(order_edit.declined_at)\n *       }\n *     })\n *   }\n * \n *   // ...\n * }\n * \n * export default OrderEdit\n * \n * @customNamespace Hooks.Store.Order Edits\n * @category Mutations\n */\nexport const useDeclineOrderEdit = (\n  /**\n   * The order edit's ID.\n   */\n  id: string,\n  options?: UseMutationOptions<\n    Response<StoreOrderEditsRes>,\n    Error,\n    StorePostOrderEditsOrderEditDecline\n  >\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n\n  return useMutation(\n    (payload: StorePostOrderEditsOrderEditDecline) =>\n      client.orderEdits.decline(id, payload),\n    buildOptions(\n      queryClient,\n      [orderEditQueryKeys.lists(), orderEditQueryKeys.detail(id)],\n      options\n    )\n  )\n}\n\n/**\n * This hook completes and confirms an Order Edit and reflect its changes on the original order. Any additional payment required must \n * be authorized first using the {@link Hooks.Store.\"Payment Collections\".useAuthorizePaymentSession | useAuthorizePaymentSession} hook.\n * \n * @example\n * import React from \"react\"\n * import { useCompleteOrderEdit } from \"medusa-react\"\n * \n * type Props = {\n *   orderEditId: string\n * }\n * \n * const OrderEdit = ({ orderEditId }: Props) => {\n *   const completeOrderEdit = useCompleteOrderEdit(\n *     orderEditId\n *   )\n *   // ...\n * \n *   const handleCompleteOrderEdit = () => {\n *     completeOrderEdit.mutate(void 0, {\n *       onSuccess: ({ order_edit }) => {\n *         console.log(order_edit.confirmed_at)\n *       }\n *     })\n *   }\n * \n *   // ...\n * }\n * \n * export default OrderEdit\n * \n * @customNamespace Hooks.Store.Order Edits\n * @category Mutations\n */\nexport const useCompleteOrderEdit = (\n  /**\n   * The order edit's ID.\n   */\n  id: string,\n  options?: UseMutationOptions<Response<StoreOrderEditsRes>, Error>\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n\n  return useMutation(\n    () => client.orderEdits.complete(id),\n    buildOptions(\n      queryClient,\n      [orderEditQueryKeys.lists(), orderEditQueryKeys.detail(id)],\n      options\n    )\n  )\n}\n","import {\n  QueryClient,\n  QueryKey,\n  UseMutationOptions,\n} from \"@tanstack/react-query\"\n\nexport const buildOptions = <\n  TData,\n  TError,\n  TVariables,\n  TContext,\n  TKey extends QueryKey\n>(\n  queryClient: QueryClient,\n  queryKey?: TKey,\n  options?: UseMutationOptions<TData, TError, TVariables, TContext>\n): UseMutationOptions<TData, TError, TVariables, TContext> => {\n  return {\n    ...options,\n    onSuccess: (...args) => {\n      if (options?.onSuccess) {\n        return options.onSuccess(...args)\n      }\n\n      if (queryKey !== undefined) {\n        queryKey.forEach((key) => {\n          queryClient.invalidateQueries({ queryKey: key as QueryKey })\n        })\n      }\n    },\n  }\n}\n","import { StoreGetOrdersParams, StoreOrdersRes } from \"@medusajs/medusa\"\nimport { Response } from \"@medusajs/medusa-js\"\nimport { useQuery } from \"@tanstack/react-query\"\nimport { useMedusa } from \"../../../contexts\"\nimport { UseQueryOptionsWrapper } from \"../../../types\"\nimport { queryKeysFactory } from \"../../utils/index\"\n\nconst ORDERS_QUERY_KEY = `orders` as const\n\nexport const orderKeys = {\n  ...queryKeysFactory<typeof ORDERS_QUERY_KEY, StoreGetOrdersParams>(\n    ORDERS_QUERY_KEY\n  ),\n  cart: (cartId: string) => [...orderKeys.details(), \"cart\", cartId] as const,\n}\n\ntype OrderQueryKey = typeof orderKeys\n\n/**\n * This hook retrieves an Order's details.\n * \n * @example\n * import React from \"react\"\n * import { useOrder } from \"medusa-react\"\n * \n * type Props = {\n *   orderId: string\n * }\n * \n * const Order = ({ orderId }: Props) => {\n *   const { \n *     order, \n *     isLoading, \n *   } = useOrder(orderId)\n * \n *   return (\n *     <div>\n *       {isLoading && <span>Loading...</span>}\n *       {order && <span>{order.display_id}</span>}\n *       \n *     </div>\n *   )\n * }\n * \n * export default Order\n * \n * @customNamespace Hooks.Store.Orders\n * @category Queries\n */\nexport const useOrder = (\n  /**\n   * The order's ID.\n   */\n  id: string,\n  options?: UseQueryOptionsWrapper<\n    Response<StoreOrdersRes>,\n    Error,\n    ReturnType<OrderQueryKey[\"detail\"]>\n  >\n) => {\n  const { client } = useMedusa()\n  const { data, ...rest } = useQuery(\n    orderKeys.detail(id),\n    () => client.orders.retrieve(id),\n    options\n  )\n\n  return { ...data, ...rest } as const\n}\n\n/**\n * This hook retrieves an order's details by the ID of the cart that was used to create the order.\n * \n * @example\n * import React from \"react\"\n * import { useCartOrder } from \"medusa-react\"\n * \n * type Props = {\n *   cartId: string\n * }\n * \n * const Order = ({ cartId }: Props) => {\n *   const { \n *     order, \n *     isLoading, \n *   } = useCartOrder(cartId)\n * \n *   return (\n *     <div>\n *       {isLoading && <span>Loading...</span>}\n *       {order && <span>{order.display_id}</span>}\n *       \n *     </div>\n *   )\n * }\n * \n * export default Order\n * \n * @customNamespace Hooks.Store.Orders\n * @category Queries\n */\nexport const useCartOrder = (\n  /**\n   * The cart's ID.\n   */\n  cartId: string,\n  options?: UseQueryOptionsWrapper<\n    Response<StoreOrdersRes>,\n    Error,\n    ReturnType<OrderQueryKey[\"cart\"]>\n  >\n) => {\n  const { client } = useMedusa()\n  const { data, ...rest } = useQuery(\n    orderKeys.cart(cartId),\n    () => client.orders.retrieveByCartId(cartId),\n    options\n  )\n\n  return { ...data, ...rest } as const\n}\n\n/**\n * This hook looks up an order using filters. If the filters don't narrow down the results to a single order, a `404` response is returned with no orders.\n * \n * @example\n * import React from \"react\"\n * import { useOrders } from \"medusa-react\"\n * \n * type Props = {\n *   displayId: number\n *   email: string\n * }\n * \n * const Order = ({\n *   displayId,\n *   email\n * }: Props) => {\n *   const { \n *     order, \n *     isLoading, \n *   } = useOrders({\n *     display_id: displayId,\n *     email,\n *   })\n * \n *   return (\n *     <div>\n *       {isLoading && <span>Loading...</span>}\n *       {order && <span>{order.display_id}</span>}\n *       \n *     </div>\n *   )\n * }\n * \n * export default Order\n * \n * @customNamespace Hooks.Store.Orders\n * @category Queries\n */\nexport const useOrders = (\n  /**\n   * Filters used to retrieve the order.\n   */\n  query: StoreGetOrdersParams,\n  options?: UseQueryOptionsWrapper<\n    Response<StoreOrdersRes>,\n    Error,\n    ReturnType<OrderQueryKey[\"list\"]>\n  >\n) => {\n  const { client } = useMedusa()\n  const { data, ...rest } = useQuery(\n    orderKeys.list(query),\n    () => client.orders.lookupOrder(query),\n    options\n  )\n\n  return { ...data, ...rest } as const\n}\n","import { Response } from \"@medusajs/medusa-js\"\nimport {\n  useMutation,\n  UseMutationOptions,\n  useQueryClient,\n} from \"@tanstack/react-query\"\n\nimport {\n  StorePostCustomersCustomerAcceptClaimReq,\n  StorePostCustomersCustomerOrderClaimReq,\n} from \"@medusajs/medusa\"\n\nimport { useMedusa } from \"../../../contexts\"\nimport { buildOptions } from \"../../utils/buildOptions\"\nimport { orderKeys } from \"./queries\"\n\n/**\n * This hook allows the logged-in customer to claim ownership of one or more orders. This generates a token that can be used later on to verify the claim \n * using the {@link useGrantOrderAccess} hook. This also emits the event `order-update-token.created`. So, if you have a notification provider installed \n * that handles this event and sends the customer a notification, such as an email, the customer should receive instructions on how to \n * finalize their claim ownership.\n * \n * @example\n * import React from \"react\"\n * import { useRequestOrderAccess } from \"medusa-react\"\n * \n * const ClaimOrder = () => {\n *   const claimOrder = useRequestOrderAccess()\n * \n *   const handleClaimOrder = (\n *     orderIds: string[]\n *   ) => {\n *     claimOrder.mutate({\n *       order_ids: orderIds\n *     }, {\n *       onSuccess: () => {\n *         // successful\n *       },\n *       onError: () => {\n *         // an error occurred.\n *       }\n *     })\n *   }\n *   \n *   // ...\n * }\n * \n * export default ClaimOrder\n * \n * @customNamespace Hooks.Store.Orders\n * @category Mutations\n */\nexport const useRequestOrderAccess = (\n  options?: UseMutationOptions<\n    Response<{}>,\n    Error,\n    StorePostCustomersCustomerOrderClaimReq\n  >\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n\n  return useMutation(\n    (payload: StorePostCustomersCustomerOrderClaimReq) =>\n      client.orders.requestCustomerOrders(payload),\n    buildOptions(queryClient, [orderKeys.all], options)\n  )\n}\n\n/**\n * This hook verifies the claim order token provided to the customer when they request ownership of an order.\n * \n * @example\n * import React from \"react\"\n * import { useGrantOrderAccess } from \"medusa-react\"\n * \n * const ClaimOrder = () => {\n *   const confirmOrderRequest = useGrantOrderAccess()\n * \n *   const handleOrderRequestConfirmation = (\n *     token: string\n *   ) => {\n *     confirmOrderRequest.mutate({\n *       token\n *     }, {\n *       onSuccess: () => {\n *         // successful\n *       },\n *       onError: () => {\n *         // an error occurred.\n *       }\n *     })\n *   }\n *   \n *   // ...\n * }\n * \n * export default ClaimOrder\n * \n * @customNamespace Hooks.Store.Orders\n * @category Mutations\n */\nexport const useGrantOrderAccess = (\n  options?: UseMutationOptions<\n    Response<{}>,\n    Error,\n    StorePostCustomersCustomerAcceptClaimReq\n  >\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n\n  return useMutation(\n    (payload: StorePostCustomersCustomerAcceptClaimReq) =>\n      client.orders.confirmRequest(payload),\n    buildOptions(queryClient, [orderKeys.all], options)\n  )\n}\n","import { StorePaymentCollectionsRes } from \"@medusajs/medusa\"\nimport { Response } from \"@medusajs/medusa-js\"\nimport { useQuery } from \"@tanstack/react-query\"\nimport { useMedusa } from \"../../../contexts\"\nimport { UseQueryOptionsWrapper } from \"../../../types\"\nimport { queryKeysFactory } from \"../../utils\"\n\nconst PAYMENT_COLLECTION_QUERY_KEY = `paymentCollection` as const\n\nexport const paymentCollectionQueryKeys = queryKeysFactory<\n  typeof PAYMENT_COLLECTION_QUERY_KEY\n>(PAYMENT_COLLECTION_QUERY_KEY)\n\ntype PaymentCollectionKey = typeof paymentCollectionQueryKeys\n\n/**\n * This hook retrieves a Payment Collection's details.\n * \n * @example\n * import React from \"react\"\n * import { usePaymentCollection } from \"medusa-react\"\n * \n * type Props = {\n *   paymentCollectionId: string\n * }\n * \n * const PaymentCollection = ({\n *   paymentCollectionId\n * }: Props) => {\n *   const { \n *     payment_collection, \n *     isLoading\n *   } = usePaymentCollection(\n *     paymentCollectionId\n *   )\n * \n *   return (\n *     <div>\n *       {isLoading && <span>Loading...</span>}\n *       {payment_collection && (\n *         <span>{payment_collection.status}</span>\n *       )}\n *     </div>\n *   )\n * }\n * \n * export default PaymentCollection\n * \n * @customNamespace Hooks.Store.Payment Collections\n * @category Queries\n */\nexport const usePaymentCollection = (\n  /**\n   * The payment collection's ID.\n   */\n  id: string,\n  options?: UseQueryOptionsWrapper<\n    Response<StorePaymentCollectionsRes>,\n    Error,\n    ReturnType<PaymentCollectionKey[\"detail\"]>\n  >\n) => {\n  const { client } = useMedusa()\n  const { data, ...rest } = useQuery(\n    paymentCollectionQueryKeys.detail(id),\n    () => client.paymentCollections.retrieve(id),\n    options\n  )\n\n  return { ...data, ...rest } as const\n}\n","import { Response } from \"@medusajs/medusa-js\"\nimport {\n  useMutation,\n  UseMutationOptions,\n  useQueryClient,\n} from \"@tanstack/react-query\"\n\nimport {\n  StorePaymentCollectionSessionsReq,\n  StorePaymentCollectionsRes,\n  StorePaymentCollectionsSessionRes,\n  StorePostPaymentCollectionsBatchSessionsAuthorizeReq,\n  StorePostPaymentCollectionsBatchSessionsReq,\n} from \"@medusajs/medusa\"\n\nimport { useMedusa } from \"../../../contexts\"\nimport { buildOptions } from \"../../utils/buildOptions\"\nimport { paymentCollectionQueryKeys } from \"./queries\"\n\n/**\n * This hook creates, updates, or deletes a list of payment sessions of a Payment Collections. If a payment session is not provided in the `sessions` array, it's deleted.\n * \n * @example\n * To add two new payment sessions:\n * \n * ```tsx\n * import React from \"react\"\n * import { useManageMultiplePaymentSessions } from \"medusa-react\"\n * \n * type Props = {\n *   paymentCollectionId: string\n * }\n * \n * const PaymentCollection = ({\n *   paymentCollectionId\n * }: Props) => {\n *   const managePaymentSessions = useManageMultiplePaymentSessions(\n *     paymentCollectionId\n *   )\n * \n *   const handleManagePaymentSessions = () => {\n *     managePaymentSessions.mutate({\n *       // Total amount = 10000\n *       sessions: [\n *         {\n *           provider_id: \"stripe\",\n *           amount: 5000,\n *         },\n *         {\n *           provider_id: \"manual\",\n *           amount: 5000,\n *         },\n *       ]\n *     }, {\n *       onSuccess: ({ payment_collection }) => {\n *         console.log(payment_collection.payment_sessions)\n *       }\n *     })\n *   }\n *   \n *   // ...\n * }\n * \n * export default PaymentCollection\n * ```\n * \n * To update a payment session and another one by not including it in the payload:\n * \n * ```tsx\n * import React from \"react\"\n * import { useManageMultiplePaymentSessions } from \"medusa-react\"\n * \n * type Props = {\n *   paymentCollectionId: string\n * }\n * \n * const PaymentCollection = ({\n *   paymentCollectionId\n * }: Props) => {\n *   const managePaymentSessions = useManageMultiplePaymentSessions(\n *     paymentCollectionId\n *   )\n * \n *   const handleManagePaymentSessions = () => {\n *     managePaymentSessions.mutate({\n *       // Total amount = 10000\n *       sessions: [\n *         {\n *           provider_id: \"stripe\",\n *           amount: 10000,\n *           session_id: \"ps_123456\"\n *         },\n *       ]\n *     }, {\n *       onSuccess: ({ payment_collection }) => {\n *         console.log(payment_collection.payment_sessions)\n *       }\n *     })\n *   }\n *   \n *   // ...\n * }\n * \n * export default PaymentCollection\n * ```\n * \n * @customNamespace Hooks.Store.Payment Collections\n * @category Mutations\n */\nexport const useManageMultiplePaymentSessions = (\n  /**\n   * The payment collection's ID.\n   */\n  id: string,\n  options?: UseMutationOptions<\n    Response<StorePaymentCollectionsRes>,\n    Error,\n    StorePostPaymentCollectionsBatchSessionsReq\n  >\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n\n  return useMutation(\n    (payload: StorePostPaymentCollectionsBatchSessionsReq) =>\n      client.paymentCollections.managePaymentSessionsBatch(id, payload),\n    buildOptions(\n      queryClient,\n      [\n        paymentCollectionQueryKeys.lists(),\n        paymentCollectionQueryKeys.detail(id),\n      ],\n      options\n    )\n  )\n}\n\n/**\n * This hook creates a Payment Session for a payment provider in a Payment Collection.\n * \n * @example\n * import React from \"react\"\n * import { useManagePaymentSession } from \"medusa-react\"\n * \n * type Props = {\n *   paymentCollectionId: string\n * }\n * \n * const PaymentCollection = ({\n *   paymentCollectionId\n * }: Props) => {\n *   const managePaymentSession = useManagePaymentSession(\n *     paymentCollectionId\n *   )\n * \n *   const handleManagePaymentSession = (\n *     providerId: string\n *   ) => {\n *     managePaymentSession.mutate({\n *       provider_id: providerId\n *     }, {\n *       onSuccess: ({ payment_collection }) => {\n *         console.log(payment_collection.payment_sessions)\n *       }\n *     })\n *   }\n *   \n *   // ...\n * }\n * \n * export default PaymentCollection\n * \n * @customNamespace Hooks.Store.Payment Collections\n * @category Mutations\n */\nexport const useManagePaymentSession = (\n  /**\n   * The payment collection's ID.\n   */\n  id: string,\n  options?: UseMutationOptions<\n    Response<StorePaymentCollectionsRes>,\n    Error,\n    StorePaymentCollectionSessionsReq\n  >\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n\n  return useMutation(\n    (payload: StorePaymentCollectionSessionsReq) =>\n      client.paymentCollections.managePaymentSession(id, payload),\n    buildOptions(\n      queryClient,\n      [\n        paymentCollectionQueryKeys.lists(),\n        paymentCollectionQueryKeys.detail(id),\n      ],\n      options\n    )\n  )\n}\n\n/**\n * This hook authorizes a Payment Session of a Payment Collection.\n * \n * @typeParamDefinition string - The payment session's ID.\n * \n * @example\n * import React from \"react\"\n * import { useAuthorizePaymentSession } from \"medusa-react\"\n * \n * type Props = {\n *   paymentCollectionId: string\n * }\n * \n * const PaymentCollection = ({\n *   paymentCollectionId\n * }: Props) => {\n *   const authorizePaymentSession = useAuthorizePaymentSession(\n *     paymentCollectionId\n *   )\n *   // ...\n * \n *   const handleAuthorizePayment = (paymentSessionId: string) => {\n *     authorizePaymentSession.mutate(paymentSessionId, {\n *       onSuccess: ({ payment_collection }) => {\n *         console.log(payment_collection.payment_sessions)\n *       }\n *     })\n *   }\n * \n *   // ...\n * }\n * \n * export default PaymentCollection\n * \n * @customNamespace Hooks.Store.Payment Collections\n * @category Mutations\n */\nexport const useAuthorizePaymentSession = (\n  /**\n   * The payment collection's ID.\n   */\n  id: string,\n  options?: UseMutationOptions<\n    Response<StorePaymentCollectionsRes>,\n    Error,\n    /**\n     * The payment session's ID.\n     */\n    string\n  >\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n\n  return useMutation(\n    (session_id: string) =>\n      client.paymentCollections.authorizePaymentSession(id, session_id),\n    buildOptions(\n      queryClient,\n      [\n        paymentCollectionQueryKeys.lists(),\n        paymentCollectionQueryKeys.detail(id),\n      ],\n      options\n    )\n  )\n}\n\n/**\n * This hook authorize the Payment Sessions of a Payment Collection.\n * \n * @example\n * import React from \"react\"\n * import { useAuthorizePaymentSessionsBatch } from \"medusa-react\"\n * \n * type Props = {\n *   paymentCollectionId: string\n * }\n * \n * const PaymentCollection = ({\n *   paymentCollectionId\n * }: Props) => {\n *   const authorizePaymentSessions = useAuthorizePaymentSessionsBatch(\n *     paymentCollectionId\n *   )\n *   // ...\n * \n *   const handleAuthorizePayments = (paymentSessionIds: string[]) => {\n *     authorizePaymentSessions.mutate({\n *       session_ids: paymentSessionIds\n *     }, {\n *       onSuccess: ({ payment_collection }) => {\n *         console.log(payment_collection.payment_sessions)\n *       }\n *     })\n *   }\n * \n *   // ...\n * }\n * \n * export default PaymentCollection\n * \n * @customNamespace Hooks.Store.Payment Collections\n * @category Mutations\n */\nexport const useAuthorizePaymentSessionsBatch = (\n  /**\n   * The payment collection's ID.\n   */\n  id: string,\n  options?: UseMutationOptions<\n    Response<StorePaymentCollectionsRes>,\n    Error,\n    StorePostPaymentCollectionsBatchSessionsAuthorizeReq\n  >\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n\n  return useMutation(\n    (payload) =>\n      client.paymentCollections.authorizePaymentSessionsBatch(id, payload),\n    buildOptions(\n      queryClient,\n      [\n        paymentCollectionQueryKeys.lists(),\n        paymentCollectionQueryKeys.detail(id),\n      ],\n      options\n    )\n  )\n}\n\n/**\n * This hook refreshes a Payment Session's data to ensure that it is in sync with the Payment Collection.\n * \n * @typeParamDefinition string - The payment session's ID.\n * \n * @example\n * import React from \"react\"\n * import { usePaymentCollectionRefreshPaymentSession } from \"medusa-react\"\n * \n * type Props = {\n *   paymentCollectionId: string\n * }\n * \n * const PaymentCollection = ({\n *   paymentCollectionId\n * }: Props) => {\n *   const refreshPaymentSession = usePaymentCollectionRefreshPaymentSession(\n *     paymentCollectionId\n *   )\n *   // ...\n * \n *   const handleRefreshPaymentSession = (paymentSessionId: string) => {\n *     refreshPaymentSession.mutate(paymentSessionId, {\n *       onSuccess: ({ payment_session }) => {\n *         console.log(payment_session.status)\n *       }\n *     })\n *   }\n * \n *   // ...\n * }\n * \n * export default PaymentCollection\n * \n * @customNamespace Hooks.Store.Payment Collections\n * @category Mutations\n */\nexport const usePaymentCollectionRefreshPaymentSession = (\n  /**\n   * The payment collection's ID.\n   */\n  id: string,\n  options?: UseMutationOptions<\n    Response<StorePaymentCollectionsSessionRes>,\n    Error,\n    /**\n     * The payment session's ID.\n     */\n    string\n  >\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n\n  return useMutation(\n    (session_id: string) =>\n      client.paymentCollections.refreshPaymentSession(id, session_id),\n    buildOptions(\n      queryClient,\n      [\n        paymentCollectionQueryKeys.lists(),\n        paymentCollectionQueryKeys.detail(id),\n      ],\n      options\n    )\n  )\n}\n","import {\n  StoreGetProductCategoriesParams,\n  StoreGetProductCategoriesRes,\n  StoreGetProductCategoriesCategoryParams,\n  StoreGetProductCategoriesCategoryRes,\n} from \"@medusajs/medusa\"\nimport { Response } from \"@medusajs/medusa-js\"\nimport { useQuery } from \"@tanstack/react-query\"\n\nimport { useMedusa } from \"../../../contexts\"\nimport { UseQueryOptionsWrapper } from \"../../../types\"\nimport { queryKeysFactory } from \"../../utils\"\n\nconst STORE_PRODUCT_CATEGORIES_QUERY_KEY = `product_categories` as const\nexport const storeProductCategoryKeys = queryKeysFactory(\n  STORE_PRODUCT_CATEGORIES_QUERY_KEY\n)\ntype ProductCategoryQueryKeys = typeof storeProductCategoryKeys\n\n/**\n * This hook retrieves a list of product categories. The product categories can be filtered by fields such as `handle` or `q` passed in the `query` parameter. \n * The product categories can also be paginated. This hook can also be used to retrieve a product category by its handle.\n * \n * @example\n * To list product categories:\n * \n * ```tsx\n * import React from \"react\"\n * import { useProductCategories } from \"medusa-react\"\n * \n * function Categories() {\n *   const { \n *     product_categories, \n *     isLoading,\n *   } = useProductCategories()\n * \n *   return (\n *     <div>\n *       {isLoading && <span>Loading...</span>}\n *       {product_categories && !product_categories.length && (\n *         <span>No Categories</span>\n *       )}\n *       {product_categories && product_categories.length > 0 && (\n *         <ul>\n *           {product_categories.map(\n *             (category) => (\n *               <li key={category.id}>{category.name}</li>\n *             )\n *           )}\n *         </ul>\n *       )}\n *     </div>\n *   )\n * }\n * \n * export default Categories\n * ```\n * \n * To retrieve a product category by its handle:\n * \n * ```tsx\n * import React from \"react\"\n * import { useProductCategories } from \"medusa-react\"\n * \n * function Categories(\n *   handle: string\n * ) {\n *   const { \n *     product_categories, \n *     isLoading,\n *   } = useProductCategories({\n *     handle\n *   })\n * \n *   return (\n *     <div>\n *       {isLoading && <span>Loading...</span>}\n *       {product_categories && !product_categories.length && (\n *         <span>No Categories</span>\n *       )}\n *       {product_categories && product_categories.length > 0 && (\n *         <ul>\n *           {product_categories.map(\n *             (category) => (\n *               <li key={category.id}>{category.name}</li>\n *             )\n *           )}\n *         </ul>\n *       )}\n *     </div>\n *   )\n * }\n * \n * export default Categories\n * ```\n * \n * To specify relations that should be retrieved within the product categories:\n * \n * ```tsx\n * import React from \"react\"\n * import { useProductCategories } from \"medusa-react\"\n * \n * function Categories(\n *   handle: string\n * ) {\n *   const { \n *     product_categories, \n *     isLoading,\n *   } = useProductCategories({\n *     handle,\n *     expand: \"products\"\n *   })\n * \n *   return (\n *     <div>\n *       {isLoading && <span>Loading...</span>}\n *       {product_categories && !product_categories.length && (\n *         <span>No Categories</span>\n *       )}\n *       {product_categories && product_categories.length > 0 && (\n *         <ul>\n *           {product_categories.map(\n *             (category) => (\n *               <li key={category.id}>{category.name}</li>\n *             )\n *           )}\n *         </ul>\n *       )}\n *     </div>\n *   )\n * }\n * \n * export default Categories\n * ```\n * \n * By default, only the first `100` records are retrieved. You can control pagination by specifying the `limit` and `offset` properties:\n * \n * ```tsx\n * import { useProductCategories } from \"medusa-react\"\n * \n * function Categories(\n *   handle: string\n * ) {\n *   const { \n *     product_categories,\n *     limit,\n *     offset, \n *     isLoading,\n *   } = useProductCategories({\n *     handle,\n *     expand: \"products\",\n *     limit: 50,\n *     offset: 0\n *   })\n * \n *   return (\n *     <div>\n *       {isLoading && <span>Loading...</span>}\n *       {product_categories && !product_categories.length && (\n *         <span>No Categories</span>\n *       )}\n *       {product_categories && product_categories.length > 0 && (\n *         <ul>\n *           {product_categories.map(\n *             (category) => (\n *               <li key={category.id}>{category.name}</li>\n *             )\n *           )}\n *         </ul>\n *       )}\n *     </div>\n *   )\n * }\n * \n * export default Categories\n * ```\n * \n * @customNamespace Hooks.Store.Product Categories\n * @category Queries\n */\nexport const useProductCategories = (\n  /**\n   * Filters and pagination configurations to apply on the retrieved product categories.\n   */\n  query?: StoreGetProductCategoriesParams,\n  options?: UseQueryOptionsWrapper<\n    Response<StoreGetProductCategoriesRes>,\n    Error,\n    ReturnType<ProductCategoryQueryKeys[\"list\"]>\n  >\n) => {\n  const { client } = useMedusa()\n  const { data, ...rest } = useQuery(\n    storeProductCategoryKeys.list(query),\n    () => client.productCategories.list(query),\n    options\n  )\n  return { ...data, ...rest } as const\n}\n\n/**\n * This hook retrieves a Product Category's details.\n * \n * @example\n * A simple example that retrieves a product category by its ID:\n * \n * ```tsx\n * import React from \"react\"\n * import { useProductCategory } from \"medusa-react\"\n * \n * type Props = {\n *   categoryId: string\n * }\n * \n * const Category = ({ categoryId }: Props) => {\n *   const { product_category, isLoading } = useProductCategory(\n *     categoryId\n *   )\n * \n *   return (\n *     <div>\n *       {isLoading && <span>Loading...</span>}\n *       {product_category && <span>{product_category.name}</span>}\n *     </div>\n *   )\n * }\n * \n * export default Category\n * ```\n * \n * To specify relations that should be retrieved:\n * \n * ```tsx\n * import React from \"react\"\n * import { useProductCategory } from \"medusa-react\"\n * \n * type Props = {\n *   categoryId: string\n * }\n * \n * const Category = ({ categoryId }: Props) => {\n *   const { product_category, isLoading } = useProductCategory(\n *     categoryId,\n *     {\n *       expand: \"products\"\n *     }\n *   )\n * \n *   return (\n *     <div>\n *       {isLoading && <span>Loading...</span>}\n *       {product_category && <span>{product_category.name}</span>}\n *     </div>\n *   )\n * }\n * \n * export default Category\n * ```\n * \n * @customNamespace Hooks.Store.Product Categories\n * @category Queries\n */\nexport const useProductCategory = (\n  /**\n   * The product category's ID.\n   */\n  id: string,\n  /**\n   * Configurations to apply on the retrieved product categories.\n   */\n  query?: StoreGetProductCategoriesCategoryParams,\n  options?: UseQueryOptionsWrapper<\n    Response<StoreGetProductCategoriesCategoryRes>,\n    Error,\n    ReturnType<ProductCategoryQueryKeys[\"detail\"]>\n  >\n) => {\n  const { client } = useMedusa()\n  const { data, ...rest } = useQuery(\n    storeProductCategoryKeys.detail(id),\n    () => client.productCategories.retrieve(id, query),\n    options\n  )\n\n  return { ...data, ...rest } as const\n}\n","import {\n  StoreGetProductTagsParams,\n  StoreProductTagsListRes,\n} from \"@medusajs/medusa\"\nimport { Response } from \"@medusajs/medusa-js\"\nimport { useQuery } from \"@tanstack/react-query\"\nimport { useMedusa } from \"../../../contexts\"\nimport { UseQueryOptionsWrapper } from \"../../../types\"\nimport { queryKeysFactory } from \"../../utils\"\n\nconst PRODUCT_TAGS_QUERY_KEY = `product_tags` as const\n\nexport const productTagKeys = queryKeysFactory(PRODUCT_TAGS_QUERY_KEY)\n\ntype ProductTypesQueryKeys = typeof productTagKeys\n\n/**\n * This hook retrieves a list of product tags. The product tags can be filtered by fields such as `id` or `q` \n * passed in the `query` parameter. The product tags can also be sorted or paginated.\n * \n * @example\n * To list product tags:\n * \n * ```tsx\n * import React from \"react\"\n * import { useProductTags } from \"medusa-react\"\n * \n * function Tags() {\n *   const { \n *     product_tags, \n *     isLoading,\n *   } = useProductTags()\n * \n *   return (\n *     <div>\n *       {isLoading && <span>Loading...</span>}\n *       {product_tags && !product_tags.length && (\n *         <span>No Product Tags</span>\n *       )}\n *       {product_tags && product_tags.length > 0 && (\n *         <ul>\n *           {product_tags.map(\n *             (tag) => (\n *               <li key={tag.id}>{tag.value}</li>\n *             )\n *           )}\n *         </ul>\n *       )}\n *     </div>\n *   )\n * }\n * \n * export default Tags\n * ```\n * \n * By default, only the first `20` records are retrieved. You can control pagination by specifying the `limit` and `offset` properties:\n * \n * ```tsx\n * import React from \"react\"\n * import { useProductTags } from \"medusa-react\"\n * \n * function Tags() {\n *   const { \n *     product_tags, \n *     limit,\n *     offset,\n *     isLoading,\n *   } = useProductTags({\n *     limit: 10,\n *     offset: 0\n *   })\n * \n *   return (\n *     <div>\n *       {isLoading && <span>Loading...</span>}\n *       {product_tags && !product_tags.length && (\n *         <span>No Product Tags</span>\n *       )}\n *       {product_tags && product_tags.length > 0 && (\n *         <ul>\n *           {product_tags.map(\n *             (tag) => (\n *               <li key={tag.id}>{tag.value}</li>\n *             )\n *           )}\n *         </ul>\n *       )}\n *     </div>\n *   )\n * }\n * \n * export default Tags\n * ```\n * \n * @customNamespace Hooks.Store.Product Tags\n * @category Queries\n */\nexport const useProductTags = (\n  /**\n   * Filters and pagination configurations to apply on the retrieved product tags.\n   */\n  query?: StoreGetProductTagsParams,\n  options?: UseQueryOptionsWrapper<\n    Response<StoreProductTagsListRes>,\n    Error,\n    ReturnType<ProductTypesQueryKeys[\"list\"]>\n  >\n) => {\n  const { client } = useMedusa()\n  const { data, ...rest } = useQuery(\n    productTagKeys.list(query),\n    () => client.productTags.list(query),\n    options\n  )\n  return { ...data, ...rest } as const\n}\n","import {\n  StoreGetProductTypesParams,\n  StoreProductTypesListRes,\n} from \"@medusajs/medusa\"\nimport { Response } from \"@medusajs/medusa-js\"\nimport { useQuery } from \"@tanstack/react-query\"\nimport { useMedusa } from \"../../../contexts\"\nimport { UseQueryOptionsWrapper } from \"../../../types\"\nimport { queryKeysFactory } from \"../../utils\"\n\nconst PRODUCT_TYPES_QUERY_KEY = `product_types` as const\n\nexport const productTypeKeys = queryKeysFactory(PRODUCT_TYPES_QUERY_KEY)\n\ntype ProductTypesQueryKeys = typeof productTypeKeys\n\n/**\n * This hook retrieves a list of product types. The product types can be filtered by fields such as `value` or `q` passed \n * in the `query` parameter. The product types can also be sorted or paginated.\n * \n * @example\n * To list product types:\n * \n * ```tsx\n * import React from \"react\"\n * import { useProductTypes } from \"medusa-react\"\n * \n * function Types() {\n *   const { \n *     product_types, \n *     isLoading,\n *   } = useProductTypes()\n * \n *   return (\n *     <div>\n *       {isLoading && <span>Loading...</span>}\n *       {product_types && !product_types.length && (\n *         <span>No Product Types</span>\n *       )}\n *       {product_types && product_types.length > 0 && (\n *         <ul>\n *           {product_types.map(\n *             (type) => (\n *               <li key={type.id}>{type.value}</li>\n *             )\n *           )}\n *         </ul>\n *       )}\n *     </div>\n *   )\n * }\n * \n * export default Types\n * ```\n * \n * By default, only the first `20` records are retrieved. You can control pagination by specifying the `limit` and `offset` properties:\n * \n * ```tsx\n * import React from \"react\"\n * import { useProductTypes } from \"medusa-react\"\n * \n * function Types() {\n *   const { \n *     product_types,\n *     limit,\n *     offset, \n *     isLoading,\n *   } = useProductTypes({\n *     limit: 10,\n *     offset: 0\n *   })\n * \n *   return (\n *     <div>\n *       {isLoading && <span>Loading...</span>}\n *       {product_types && !product_types.length && (\n *         <span>No Product Types</span>\n *       )}\n *       {product_types && product_types.length > 0 && (\n *         <ul>\n *           {product_types.map(\n *             (type) => (\n *               <li key={type.id}>{type.value}</li>\n *             )\n *           )}\n *         </ul>\n *       )}\n *     </div>\n *   )\n * }\n * \n * export default Types\n * ```\n * \n * @customNamespace Hooks.Store.Product Types\n * @category Queries\n */\nexport const useProductTypes = (\n  /**\n   * Filters and pagination configurations to apply on retrieved product types.\n   */\n  query?: StoreGetProductTypesParams,\n  options?: UseQueryOptionsWrapper<\n    Response<StoreProductTypesListRes>,\n    Error,\n    ReturnType<ProductTypesQueryKeys[\"list\"]>\n  >\n) => {\n  const { client } = useMedusa()\n  const { data, ...rest } = useQuery(\n    productTypeKeys.list(query),\n    () => client.productTypes.list(query),\n    options\n  )\n  return { ...data, ...rest } as const\n}\n","import {\n  StoreGetProductsParams,\n  StoreProductsListRes,\n  StoreProductsRes,\n} from \"@medusajs/medusa\"\nimport { Response } from \"@medusajs/medusa-js\"\nimport { useQuery } from \"@tanstack/react-query\"\nimport { useMedusa } from \"../../../contexts\"\nimport { UseQueryOptionsWrapper } from \"../../../types\"\nimport { queryKeysFactory } from \"../../utils/index\"\n\nconst PRODUCTS_QUERY_KEY = `products` as const\n\nexport const productKeys = queryKeysFactory<\n  typeof PRODUCTS_QUERY_KEY,\n  StoreGetProductsParams\n>(PRODUCTS_QUERY_KEY)\ntype ProductQueryKey = typeof productKeys\n\n/**\n * This hook retrieves a list of products. The products can be filtered by fields such as `id` or `q` passed in the `query` parameter. The products can also be sorted or paginated.\n * This hook can also be used to retrieve a product by its handle.\n * \n * For accurate and correct pricing of the products based on the customer's context, it's highly recommended to pass fields such as\n * `region_id`, `currency_code`, and `cart_id` when available.\n * \n * Passing `sales_channel_id` ensures retrieving only products available in the specified sales channel.\n * You can alternatively use a publishable API key in the request header instead of passing a `sales_channel_id`.\n * \n * @example\n * To list products:\n * \n * ```tsx\n * import React from \"react\"\n * import { useProducts } from \"medusa-react\"\n * \n * const Products = () => {\n *   const { products, isLoading } = useProducts()\n * \n *   return (\n *     <div>\n *       {isLoading && <span>Loading...</span>}\n *       {products && !products.length && <span>No Products</span>}\n *       {products && products.length > 0 && (\n *         <ul>\n *           {products.map((product) => (\n *             <li key={product.id}>{product.title}</li>\n *           ))}\n *         </ul>\n *       )}\n *     </div>\n *   )\n * }\n * \n * export default Products\n * ```\n * \n * To specify relations that should be retrieved within the products:\n * \n * ```tsx\n * import React from \"react\"\n * import { useProducts } from \"medusa-react\"\n * \n * const Products = () => {\n *   const { products, isLoading } = useProducts({\n *     expand: \"variants\"\n *   })\n * \n *   return (\n *     <div>\n *       {isLoading && <span>Loading...</span>}\n *       {products && !products.length && <span>No Products</span>}\n *       {products && products.length > 0 && (\n *         <ul>\n *           {products.map((product) => (\n *             <li key={product.id}>{product.title}</li>\n *           ))}\n *         </ul>\n *       )}\n *     </div>\n *   )\n * }\n * \n * export default Products\n * ```\n * \n * By default, only the first `100` records are retrieved. You can control pagination by specifying the `limit` and `offset` properties:\n * \n * ```tsx\n * import React from \"react\"\n * import { useProducts } from \"medusa-react\"\n * \n * const Products = () => {\n *   const { \n *     products,\n *     limit,\n *     offset, \n *     isLoading\n *   } = useProducts({\n *     expand: \"variants\",\n *     limit: 50,\n *     offset: 0\n *   })\n * \n *   return (\n *     <div>\n *       {isLoading && <span>Loading...</span>}\n *       {products && !products.length && <span>No Products</span>}\n *       {products && products.length > 0 && (\n *         <ul>\n *           {products.map((product) => (\n *             <li key={product.id}>{product.title}</li>\n *           ))}\n *         </ul>\n *       )}\n *     </div>\n *   )\n * }\n * \n * export default Products\n * ```\n * \n * @customNamespace Hooks.Store.Products\n * @category Queries\n */\nexport const useProducts = (\n  /**\n   * Filters and pagination configurations to apply on the retrieved products.\n   */\n  query?: StoreGetProductsParams,\n  options?: UseQueryOptionsWrapper<\n    Response<StoreProductsListRes>,\n    Error,\n    ReturnType<ProductQueryKey[\"list\"]>\n  >\n) => {\n  const { client } = useMedusa()\n  const { data, ...rest } = useQuery(\n    productKeys.list(query),\n    () => client.products.list(query),\n    options\n  )\n  return { ...data, ...rest } as const\n}\n\n/**\n * This hook retrieves a Product's details. For accurate and correct pricing of the product based on the customer's context, it's highly recommended to pass fields such as\n * `region_id`, `currency_code`, and `cart_id` when available.\n * \n * Passing `sales_channel_id` ensures retrieving only products available in the current sales channel.\n * You can alternatively use a publishable API key in the request header instead of passing a `sales_channel_id`.\n * \n * @example\n * import React from \"react\"\n * import { useProduct } from \"medusa-react\"\n * \n * type Props = {\n *   productId: string\n * }\n * \n * const Product = ({ productId }: Props) => {\n *   const { product, isLoading } = useProduct(productId)\n * \n *   return (\n *     <div>\n *       {isLoading && <span>Loading...</span>}\n *       {product && <span>{product.title}</span>}\n *     </div>\n *   )\n * }\n * \n * export default Product\n * \n * @customNamespace Hooks.Store.Products\n * @category Queries\n */\nexport const useProduct = (\n  /**\n   * The product's ID.\n   */\n  id: string,\n  options?: UseQueryOptionsWrapper<\n    Response<StoreProductsRes>,\n    Error,\n    ReturnType<ProductQueryKey[\"detail\"]>\n  >\n) => {\n  const { client } = useMedusa()\n  const { data, ...rest } = useQuery(\n    productKeys.detail(id),\n    () => client.products.retrieve(id),\n    options\n  )\n\n  return { ...data, ...rest } as const\n}\n","import { StoreRegionsListRes, StoreRegionsRes } from \"@medusajs/medusa\"\nimport { Response } from \"@medusajs/medusa-js\"\nimport { useQuery } from \"@tanstack/react-query\"\nimport { useMedusa } from \"../../../contexts\"\nimport { UseQueryOptionsWrapper } from \"../../../types\"\nimport { queryKeysFactory } from \"../../utils/index\"\n\nconst REGIONS_QUERY_KEY = `regions` as const\n\nconst regionsKey = queryKeysFactory(REGIONS_QUERY_KEY)\n\ntype RegionQueryType = typeof regionsKey\n\n/**\n * This hook retrieves a list of regions. This hook is useful to show the customer all available regions to choose from.\n * \n * @example\n * import React from \"react\"\n * import { useRegions } from \"medusa-react\"\n * \n * const Regions = () => {\n *   const { regions, isLoading } = useRegions()\n * \n *   return (\n *     <div>\n *       {isLoading && <span>Loading...</span>}\n *       {regions?.length && (\n *         <ul>\n *           {regions.map((region) => (\n *             <li key={region.id}>\n *               {region.name}\n *             </li>\n *           ))}\n *         </ul>\n *       )}\n *     </div>\n *   )\n * }\n * \n * export default Regions\n * \n * @customNamespace Hooks.Store.Regions\n * @category Queries\n */\nexport const useRegions = (\n  options?: UseQueryOptionsWrapper<\n    Response<StoreRegionsListRes>,\n    Error,\n    ReturnType<RegionQueryType[\"lists\"]>\n  >\n) => {\n  const { client } = useMedusa()\n  const { data, ...rest } = useQuery(\n    regionsKey.lists(),\n    () => client.regions.list(),\n    options\n  )\n  return { ...data, ...rest } as const\n}\n\n/**\n * This hook retrieves a Region's details.\n * \n * @example\n * import React from \"react\"\n * import { useRegion } from \"medusa-react\"\n * \n * type Props = {\n *   regionId: string\n * }\n * \n * const Region = ({ regionId }: Props) => {\n *   const { region, isLoading } = useRegion(\n *     regionId\n *   )\n * \n *   return (\n *     <div>\n *       {isLoading && <span>Loading...</span>}\n *       {region && <span>{region.name}</span>}\n *     </div>\n *   )\n * }\n * \n * export default Region\n * \n * @customNamespace Hooks.Store.Regions\n * @category Queries\n */\nexport const useRegion = (\n  /**\n   * The region's ID.\n   */\n  id: string,\n  options?: UseQueryOptionsWrapper<\n    Response<StoreRegionsRes>,\n    Error,\n    ReturnType<RegionQueryType[\"detail\"]>\n  >\n) => {\n  const { client } = useMedusa()\n  const { data, ...rest } = useQuery(\n    regionsKey.detail(id),\n    () => client.regions.retrieve(id),\n    options\n  )\n  return { ...data, ...rest } as const\n}\n","import {\n  StoreReturnReasonsListRes,\n  StoreReturnReasonsRes,\n} from \"@medusajs/medusa\"\nimport { Response } from \"@medusajs/medusa-js\"\nimport { useQuery } from \"@tanstack/react-query\"\nimport { useMedusa } from \"../../../contexts\"\nimport { UseQueryOptionsWrapper } from \"../../../types\"\nimport { queryKeysFactory } from \"../../utils/index\"\n\nconst RETURNS_REASONS_QUERY_KEY = `return_reasons` as const\n\nconst returnReasonsKey = queryKeysFactory(RETURNS_REASONS_QUERY_KEY)\n\ntype ReturnReasonsQueryKey = typeof returnReasonsKey\n\n/**\n * This hook retrieves a list of Return Reasons. This is useful when implementing a Create Return flow in the storefront.\n * \n * @example\n * import React from \"react\"\n * import { useReturnReasons } from \"medusa-react\"\n * \n * const ReturnReasons = () => {\n *   const { \n *     return_reasons, \n *     isLoading\n *   } = useReturnReasons()\n * \n *   return (\n *     <div>\n *       {isLoading && <span>Loading...</span>}\n *       {return_reasons?.length && (\n *         <ul>\n *           {return_reasons.map((returnReason) => (\n *             <li key={returnReason.id}>\n *               {returnReason.label}\n *             </li>\n *           ))}\n *         </ul>\n *       )}\n *     </div>\n *   )\n * }\n * \n * export default ReturnReasons\n * \n * @customNamespace Hooks.Store.Return Reasons\n * @category Queries\n */\nexport const useReturnReasons = (\n  options?: UseQueryOptionsWrapper<\n    Response<StoreReturnReasonsListRes>,\n    Error,\n    ReturnType<ReturnReasonsQueryKey[\"lists\"]>\n  >\n) => {\n  const { client } = useMedusa()\n  const { data, ...rest } = useQuery(\n    returnReasonsKey.lists(),\n    () => client.returnReasons.list(),\n    options\n  )\n  return { ...data, ...rest } as const\n}\n\n/**\n * This hook retrieves a Return Reason's details.\n * \n * @example\n * import React from \"react\"\n * import { useReturnReason } from \"medusa-react\"\n * \n * type Props = {\n *   returnReasonId: string\n * }\n * \n * const ReturnReason = ({ returnReasonId }: Props) => {\n *   const { \n *     return_reason, \n *     isLoading\n *   } = useReturnReason(\n *     returnReasonId\n *   )\n * \n *   return (\n *     <div>\n *       {isLoading && <span>Loading...</span>}\n *       {return_reason && <span>{return_reason.label}</span>}\n *     </div>\n *   )\n * }\n * \n * export default ReturnReason\n * \n * @customNamespace Hooks.Store.Return Reasons\n * @category Queries\n */\nexport const useReturnReason = (\n  /**\n   * The return reason's ID.\n   */\n  id: string,\n  options?: UseQueryOptionsWrapper<\n    Response<StoreReturnReasonsRes>,\n    Error,\n    ReturnType<ReturnReasonsQueryKey[\"detail\"]>\n  >\n) => {\n  const { client } = useMedusa()\n  const { data, ...rest } = useQuery(\n    returnReasonsKey.detail(id),\n    () => client.returnReasons.retrieve(id),\n    options\n  )\n  return { ...data, ...rest } as const\n}\n","import { StorePostReturnsReq, StoreReturnsRes } from \"@medusajs/medusa\"\nimport { useMutation, UseMutationOptions } from \"@tanstack/react-query\"\nimport { useMedusa } from \"../../../contexts\"\n\n/**\n * This hook creates a return for an order. If a return shipping method is specified, the return is automatically fulfilled.\n * \n * @example\n * import React from \"react\"\n * import { useCreateReturn } from \"medusa-react\"\n * \n * type CreateReturnData = {\n *   items: {\n *     item_id: string,\n *     quantity: number\n *   }[]\n *   return_shipping: {\n *     option_id: string\n *   }\n * }\n * \n * type Props = {\n *   orderId: string\n * }\n * \n * const CreateReturn = ({ orderId }: Props) => {\n *   const createReturn = useCreateReturn()\n *   // ...\n * \n *   const handleCreate = (data: CreateReturnData) => {\n *     createReturn.mutate({\n *       ...data,\n *       order_id: orderId\n *     }, {\n *       onSuccess: ({ return: returnData }) => {\n *         console.log(returnData.id)\n *       }\n *     })\n *   }\n * \n *   // ...\n * }\n * \n * export default CreateReturn\n * \n * @customNamespace Hooks.Store.Returns\n * @category Mutations\n */\nexport const useCreateReturn = (\n  options?: UseMutationOptions<StoreReturnsRes, Error, StorePostReturnsReq>\n) => {\n  const { client } = useMedusa()\n  return useMutation(\n    (data: StorePostReturnsReq) => client.returns.create(data),\n    options\n  )\n}\n","import {\n  StoreGetShippingOptionsParams,\n  StoreShippingOptionsListRes,\n} from \"@medusajs/medusa\"\nimport { Response } from \"@medusajs/medusa-js\"\nimport { useQuery } from \"@tanstack/react-query\"\nimport { useMedusa } from \"../../../contexts\"\nimport { UseQueryOptionsWrapper } from \"../../../types\"\nimport { queryKeysFactory } from \"../../utils/index\"\n\nconst SHIPPING_OPTION_QUERY_KEY = `shipping_options` as const\n\nconst shippingOptionKey = {\n  ...queryKeysFactory(SHIPPING_OPTION_QUERY_KEY),\n  cart: (cartId: string) => [...shippingOptionKey.all, \"cart\", cartId] as const,\n}\n\ntype ShippingOptionQueryKey = typeof shippingOptionKey\n\n/**\n * This hook retrieves a list of shipping options. The shipping options can be filtered using the `query` parameter.\n * \n * @example\n * import React from \"react\"\n * import { useShippingOptions } from \"medusa-react\"\n * \n * const ShippingOptions = () => {\n *   const { \n *     shipping_options, \n *     isLoading, \n *   } = useShippingOptions()\n * \n *   return (\n *     <div>\n *       {isLoading && <span>Loading...</span>}\n *       {shipping_options?.length && \n *         shipping_options?.length > 0 && (\n *         <ul>\n *           {shipping_options?.map((shipping_option) => (\n *             <li key={shipping_option.id}>\n *               {shipping_option.id}\n *             </li>\n *           ))}\n *         </ul>\n *       )}\n *     </div>\n *   )\n * }\n * \n * export default ShippingOptions\n * \n * @customNamespace Hooks.Store.Shipping Options\n * @category Queries\n */\nexport const useShippingOptions = (\n  /**\n   * The filters to apply on the shipping options.\n   */\n  query?: StoreGetShippingOptionsParams,\n  options?: UseQueryOptionsWrapper<\n    Response<StoreShippingOptionsListRes>,\n    Error,\n    ReturnType<ShippingOptionQueryKey[\"list\"]>\n  >\n) => {\n  const { client } = useMedusa()\n  const { data, ...rest } = useQuery(\n    shippingOptionKey.list(query),\n    async () => client.shippingOptions.list(query),\n    options\n  )\n  return { ...data, ...rest } as const\n}\n\n/**\n * This hook retrieves a list of shipping options available for a cart.\n * \n * @example\n * import React from \"react\"\n * import { useCartShippingOptions } from \"medusa-react\"\n * \n * type Props = {\n *   cartId: string\n * }\n * \n * const ShippingOptions = ({ cartId }: Props) => {\n *   const { shipping_options, isLoading } =\n *     useCartShippingOptions(cartId)\n * \n *   return (\n *     <div>\n *       {isLoading && <span>Loading...</span>}\n *       {shipping_options && !shipping_options.length && (\n *         <span>No shipping options</span>\n *       )}\n *       {shipping_options && (\n *         <ul>\n *           {shipping_options.map(\n *             (shipping_option) => (\n *               <li key={shipping_option.id}>\n *                 {shipping_option.name}\n *               </li>\n *             )\n *           )}\n *         </ul>\n *       )}\n *     </div>\n *   )\n * }\n * \n * export default ShippingOptions\n * \n * @customNamespace Hooks.Store.Shipping Options\n * @category Queries\n */\nexport const useCartShippingOptions = (\n  /**\n   * The cart's ID.\n   */\n  cartId: string,\n  options?: UseQueryOptionsWrapper<\n    Response<StoreShippingOptionsListRes>,\n    Error,\n    ReturnType<ShippingOptionQueryKey[\"cart\"]>\n  >\n) => {\n  const { client } = useMedusa()\n  const { data, ...rest } = useQuery(\n    shippingOptionKey.cart(cartId),\n    async () => client.shippingOptions.listCartOptions(cartId),\n    options\n  )\n  return { ...data, ...rest } as const\n}\n","import { StoreSwapsRes } from \"@medusajs/medusa\"\nimport { Response } from \"@medusajs/medusa-js\"\nimport { useQuery } from \"@tanstack/react-query\"\nimport { useMedusa } from \"../../../contexts\"\nimport { UseQueryOptionsWrapper } from \"../../../types\"\nimport { queryKeysFactory } from \"../../utils/index\"\n\nconst SWAPS_QUERY_KEY = `swaps` as const\n\nconst swapKey = {\n  ...queryKeysFactory(SWAPS_QUERY_KEY),\n  cart: (cartId: string) => [...swapKey.all, \"cart\", cartId] as const,\n}\n\ntype SwapQueryKey = typeof swapKey\n\n/**\n * This hook retrieves a Swap's details by the ID of its cart.\n * \n * @example\n * import React from \"react\"\n * import { useCartSwap } from \"medusa-react\"\n * \n * type Props = {\n *   cartId: string\n * }\n * \n * const Swap = ({ cartId }: Props) => {\n *   const { \n *     swap, \n *     isLoading, \n *   } = useCartSwap(cartId)\n * \n *   return (\n *     <div>\n *       {isLoading && <span>Loading...</span>}\n *       {swap && <span>{swap.id}</span>}\n *       \n *     </div>\n *   )\n * }\n * \n * export default Swap\n * \n * @customNamespace Hooks.Store.Swaps\n * @category Queries\n */\nexport const useCartSwap = (\n  /**\n   * The ID of the swap's cart.\n   */\n  cartId: string,\n  options?: UseQueryOptionsWrapper<\n    Response<StoreSwapsRes>,\n    Error,\n    ReturnType<SwapQueryKey[\"cart\"]>\n  >\n) => {\n  const { client } = useMedusa()\n  const { data, ...rest } = useQuery(\n    swapKey.cart(cartId),\n    () => client.swaps.retrieveByCartId(cartId),\n    options\n  )\n\n  return { ...data, ...rest } as const\n}\n","import { StorePostSwapsReq, StoreSwapsRes } from \"@medusajs/medusa\"\nimport { useMutation, UseMutationOptions } from \"@tanstack/react-query\"\nimport { useMedusa } from \"../../../contexts\"\n\n/**\n * This hook creates a Swap for an Order. This will also create a return and associate it with the swap. If a return shipping option is specified, the return will automatically be fulfilled.\n * To complete the swap, you must use the {@link Hooks.Store.Carts.useCompleteCart | useCompleteCart} hook passing it the ID of the swap's cart.\n * \n * An idempotency key will be generated if none is provided in the header `Idempotency-Key` and added to\n * the response. If an error occurs during swap creation or the request is interrupted for any reason, the swap creation can be retried by passing the idempotency\n * key in the `Idempotency-Key` header.\n * \n * @example\n * import React from \"react\"\n * import { useCreateSwap } from \"medusa-react\"\n * \n * type Props = {\n *   orderId: string\n * }\n * \n * type CreateData = {\n *   return_items: {\n *     item_id: string\n *     quantity: number\n *   }[]\n *   additional_items: {\n *     variant_id: string\n *     quantity: number\n *   }[]\n *   return_shipping_option: string\n * }\n * \n * const CreateSwap = ({\n *   orderId\n * }: Props) => {\n *   const createSwap = useCreateSwap()\n *   // ...\n * \n *   const handleCreate = (\n *     data: CreateData\n *   ) => {\n *     createSwap.mutate({\n *       ...data,\n *       order_id: orderId\n *     }, {\n *       onSuccess: ({ swap }) => {\n *         console.log(swap.id)\n *       }\n *     })\n *   }\n * \n *   // ...\n * }\n * \n * export default CreateSwap\n * \n * @customNamespace Hooks.Store.Swaps\n * @category Mutations\n */\nexport const useCreateSwap = (\n  options?: UseMutationOptions<StoreSwapsRes, Error, StorePostSwapsReq>\n) => {\n  const { client } = useMedusa()\n  return useMutation(\n    (data: StorePostSwapsReq) => client.swaps.create(data),\n    options\n  )\n}\n","import { AdminAuthRes } from \"@medusajs/medusa\"\nimport { Response } from \"@medusajs/medusa-js\"\nimport { useQuery } from \"@tanstack/react-query\"\nimport { useMedusa } from \"../../../contexts\"\nimport { UseQueryOptionsWrapper } from \"../../../types\"\nimport { queryKeysFactory } from \"../../utils/index\"\n\nconst ADMIN_AUTH_QUERY_KEY = `admin_auth` as const\n\nexport const adminAuthKeys = queryKeysFactory(ADMIN_AUTH_QUERY_KEY)\n\ntype AuthQueryKey = typeof adminAuthKeys\n\n/**\n * This hook is used to get the currently logged in user's details. Can also be used to check if there is an authenticated user.\n * \n * This hook requires {@link Hooks~Admin~Auth~useAdminLogin | user authentication}.\n * \n * @example\n * import React from \"react\"\n * import { useAdminGetSession } from \"medusa-react\"\n * \n * const Profile = () => {\n *   const { user, isLoading } = useAdminGetSession()\n * \n *   return (\n *     <div>\n *       {isLoading && <span>Loading...</span>}\n *       {user && <span>{user.email}</span>}\n *     </div>\n *   )\n * }\n * \n * export default Profile\n * \n * @customNamespace Hooks.Admin.Auth\n * @category Queries\n */\nexport const useAdminGetSession = (\n  options?: UseQueryOptionsWrapper<\n    Response<AdminAuthRes>,\n    Error,\n    ReturnType<AuthQueryKey[\"details\"]>\n  >\n) => {\n  const { client } = useMedusa()\n  const { data, ...rest } = useQuery(\n    adminAuthKeys.details(),\n    () => client.admin.auth.getSession(),\n    options\n  )\n  return { ...data, ...rest } as const\n}\n","import { AdminAuthRes, AdminPostAuthReq } from \"@medusajs/medusa\"\nimport { Response } from \"@medusajs/medusa-js\"\nimport {\n  useMutation,\n  UseMutationOptions,\n  useQueryClient,\n} from \"@tanstack/react-query\"\nimport { useMedusa } from \"../../../contexts/medusa\"\nimport { buildOptions } from \"../../utils/buildOptions\"\nimport { adminAuthKeys } from \"./queries\"\n\n/**\n * This hook is used to log a User in using their credentials. If the user is authenticated successfully, \n * the cookie is automatically attached to subsequent requests sent with other hooks.\n * \n * @example\n * import React from \"react\"\n * import { useAdminLogin } from \"medusa-react\"\n *\n * const Login = () => {\n *   const adminLogin = useAdminLogin()\n *   // ...\n *\n *   const handleLogin = () => {\n *     adminLogin.mutate({\n *       email: \"user@example.com\",\n *       password: \"supersecret\",\n *     }, {\n *       onSuccess: ({ user }) => {\n *         console.log(user)\n *       }\n *     })\n *   }\n *\n *   // ...\n * }\n *\n * export default Login\n * \n * @customNamespace Hooks.Admin.Auth\n * @category Mutations\n */\nexport const useAdminLogin = (\n  options?: UseMutationOptions<Response<AdminAuthRes>, Error, AdminPostAuthReq>\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n\n  return useMutation(\n    (payload: AdminPostAuthReq) => client.admin.auth.createSession(payload),\n    buildOptions(queryClient, adminAuthKeys.details(), options)\n  )\n}\n\n/**\n * This hook is used to Log out the user and remove their authentication session. This will only work if you're using Cookie session for authentication. If the API token is still passed in the header,\n * the user is still authorized to perform admin functionalities in other API Routes.\n * \n * This hook requires {@link Hooks.Admin.Auth.useAdminLogin | user authentication}.\n * \n * @example\n * import React from \"react\"\n * import { useAdminDeleteSession } from \"medusa-react\"\n * \n * const Logout = () => {\n *   const adminLogout = useAdminDeleteSession()\n *   // ...\n * \n *   const handleLogout = () => {\n *     adminLogout.mutate(undefined, {\n *       onSuccess: () => {\n *         // user logged out.\n *       }\n *     })\n *   }\n * \n *   // ...\n * }\n * \n * export default Logout\n * \n * @customNamespace Hooks.Admin.Auth\n * @category Mutations\n */\nexport const useAdminDeleteSession = (\n  options?: UseMutationOptions<Response<void>, Error, void>\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n\n  return useMutation(\n    () => client.admin.auth.deleteSession(),\n    buildOptions(queryClient, adminAuthKeys.details(), options)\n  )\n}\n","import {\n  AdminBatchJobListRes,\n  AdminBatchJobRes,\n  AdminGetBatchParams,\n} from \"@medusajs/medusa\"\nimport { Response } from \"@medusajs/medusa-js\"\nimport { useQuery } from \"@tanstack/react-query\"\nimport { useMedusa } from \"../../../contexts\"\nimport { UseQueryOptionsWrapper } from \"../../../types\"\nimport { queryKeysFactory } from \"../../utils/index\"\n\nconst ADMIN_COLLECTIONS_QUERY_KEY = `admin_batches` as const\n\nexport const adminBatchJobsKeys = queryKeysFactory(ADMIN_COLLECTIONS_QUERY_KEY)\n\ntype BatchJobsQueryKey = typeof adminBatchJobsKeys\n\n/**\n * This hook retrieves a list of Batch Jobs. The batch jobs can be filtered by fields such as `type` or `confirmed_at`. The batch jobs can also be sorted or paginated.\n * \n * @example\n * To list batch jobs:\n * \n * ```ts\n * import React from \"react\"\n * import { useAdminBatchJobs } from \"medusa-react\"\n * \n * const BatchJobs = () => {\n *   const { \n *     batch_jobs, \n *     limit,\n *     offset,\n *     count,\n *     isLoading\n *   } = useAdminBatchJobs()\n * \n *   return (\n *     <div>\n *       {isLoading && <span>Loading...</span>}\n *       {batch_jobs?.length && (\n *         <ul>\n *           {batch_jobs.map((batchJob) => (\n *             <li key={batchJob.id}>\n *               {batchJob.id}\n *             </li>\n *           ))}\n *         </ul>\n *       )}\n *     </div>\n *   )\n * }\n * \n * export default BatchJobs\n * ```\n * \n * To specify relations that should be retrieved within the batch jobs:\n * \n * ```ts\n * import React from \"react\"\n * import { useAdminBatchJobs } from \"medusa-react\"\n * \n * const BatchJobs = () => {\n *   const { \n *     batch_jobs, \n *     limit,\n *     offset,\n *     count,\n *     isLoading\n *   } = useAdminBatchJobs({\n *     expand: \"created_by_user\",\n *     limit: 10,\n *     offset: 0\n *   })\n * \n *   return (\n *     <div>\n *       {isLoading && <span>Loading...</span>}\n *       {batch_jobs?.length && (\n *         <ul>\n *           {batch_jobs.map((batchJob) => (\n *             <li key={batchJob.id}>\n *               {batchJob.id}\n *             </li>\n *           ))}\n *         </ul>\n *       )}\n *     </div>\n *   )\n * }\n * \n * export default BatchJobs\n * ```\n * \n * By default, only the first `10` records are retrieved. You can control pagination by specifying the `limit` and `offset` properties:\n * \n * ```ts\n * import React from \"react\"\n * import { useAdminBatchJobs } from \"medusa-react\"\n * \n * const BatchJobs = () => {\n *   const { \n *     batch_jobs, \n *     limit,\n *     offset,\n *     count,\n *     isLoading\n *   } = useAdminBatchJobs({\n *     expand: \"created_by_user\",\n *     limit: 20,\n *     offset: 0\n *   })\n * \n *   return (\n *     <div>\n *       {isLoading && <span>Loading...</span>}\n *       {batch_jobs?.length && (\n *         <ul>\n *           {batch_jobs.map((batchJob) => (\n *             <li key={batchJob.id}>\n *               {batchJob.id}\n *             </li>\n *           ))}\n *         </ul>\n *       )}\n *     </div>\n *   )\n * }\n * \n * export default BatchJobs\n * ```\n * \n * @customNamespace Hooks.Admin.Batch Jobs\n * @category Queries\n */\nexport const useAdminBatchJobs = (\n  /**\n   * Filters and pagination configurations to apply on the retrieved batch jobs.\n   */\n  query?: AdminGetBatchParams,\n  options?: UseQueryOptionsWrapper<\n    Response<AdminBatchJobListRes>,\n    Error,\n    ReturnType<BatchJobsQueryKey[\"list\"]>\n  >\n) => {\n  const { client } = useMedusa()\n  const { data, ...rest } = useQuery(\n    adminBatchJobsKeys.list(query),\n    () => client.admin.batchJobs.list(query),\n    options\n  )\n  return { ...data, ...rest } as const\n}\n\n/**\n * This hook retrieves the details of a batch job.\n * \n * @example\n * import React from \"react\"\n * import { useAdminBatchJob } from \"medusa-react\"\n * \n * type Props = {\n *   batchJobId: string\n * }\n * \n * const BatchJob = ({ batchJobId }: Props) => {\n *   const { batch_job, isLoading } = useAdminBatchJob(batchJobId)\n * \n *   return (\n *     <div>\n *       {isLoading && <span>Loading...</span>}\n *       {batch_job && <span>{batch_job.created_by}</span>}\n *     </div>\n *   )\n * }\n * \n * export default BatchJob\n * \n * @customNamespace Hooks.Admin.Batch Jobs\n * @category Queries\n */\nexport const useAdminBatchJob = (\n  /**\n   * The ID of the batch job.\n   */\n  id: string,\n  options?: UseQueryOptionsWrapper<\n    Response<AdminBatchJobRes>,\n    Error,\n    ReturnType<BatchJobsQueryKey[\"detail\"]>\n  >\n) => {\n  const { client } = useMedusa()\n  const { data, ...rest } = useQuery(\n    adminBatchJobsKeys.detail(id),\n    () => client.admin.batchJobs.retrieve(id),\n    options\n  )\n  return { ...data, ...rest } as const\n}\n","import { AdminBatchJobRes, AdminPostBatchesReq } from \"@medusajs/medusa\"\nimport { Response } from \"@medusajs/medusa-js\"\nimport {\n  useMutation,\n  UseMutationOptions,\n  useQueryClient,\n} from \"@tanstack/react-query\"\n\nimport { useMedusa } from \"../../../contexts\"\nimport { buildOptions } from \"../../utils/buildOptions\"\nimport { adminBatchJobsKeys } from \"./queries\"\n\n/**\n * This hook creates a Batch Job to be executed asynchronously in the Medusa backend. If `dry_run` is set to `true`, the batch job will not be executed until the it is confirmed,\n * which can be done using the {@link useAdminConfirmBatchJob} hook.\n * \n * @example\n * import React from \"react\"\n * import { useAdminCreateBatchJob } from \"medusa-react\"\n * \n * const CreateBatchJob = () => {\n *   const createBatchJob = useAdminCreateBatchJob()\n *   // ...\n * \n *   const handleCreateBatchJob = () => {\n *     createBatchJob.mutate({\n *       type: \"publish-products\",\n *       context: {},\n *       dry_run: true\n *     }, {\n *       onSuccess: ({ batch_job }) => {\n *         console.log(batch_job)\n *       }\n *     })\n *   }\n * \n *   // ...\n * }\n * \n * export default CreateBatchJob\n * \n * @customNamespace Hooks.Admin.Batch Jobs\n * @category Mutations\n */\nexport const useAdminCreateBatchJob = (\n  options?: UseMutationOptions<\n    Response<AdminBatchJobRes>,\n    Error,\n    AdminPostBatchesReq\n  >\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n\n  return useMutation(\n    (payload: AdminPostBatchesReq) => client.admin.batchJobs.create(payload),\n    buildOptions(queryClient, adminBatchJobsKeys.lists(), options)\n  )\n}\n\n/**\n * This hook marks a batch job as canceled. When a batch job is canceled, the processing of the batch job doesn’t automatically stop.\n * \n * @example\n * import React from \"react\"\n * import { useAdminCancelBatchJob } from \"medusa-react\"\n * \n * type Props = {\n *   batchJobId: string\n * }\n * \n * const BatchJob = ({ batchJobId }: Props) => {\n *   const cancelBatchJob = useAdminCancelBatchJob(batchJobId)\n *   // ...\n * \n *   const handleCancel = () => {\n *     cancelBatchJob.mutate(undefined, {\n *       onSuccess: ({ batch_job }) => {\n *         console.log(batch_job)\n *       }\n *     })\n *   }\n * \n *   // ...\n * }\n * \n * export default BatchJob\n * \n * @customNamespace Hooks.Admin.Batch Jobs\n * @category Mutations\n */\nexport const useAdminCancelBatchJob = (\n  /**\n   * The ID of the batch job.\n   */\n  id: string,\n  options?: UseMutationOptions<Response<AdminBatchJobRes>, Error>\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n\n  return useMutation(\n    () => client.admin.batchJobs.cancel(id),\n    buildOptions(\n      queryClient,\n      [adminBatchJobsKeys.lists(), adminBatchJobsKeys.detail(id)],\n      options\n    )\n  )\n}\n\n/**\n * When a batch job is created, it's not executed automatically if `dry_run` is set to `true`. This hook confirms that the batch job should be executed.\n * \n * @example\n * import React from \"react\"\n * import { useAdminConfirmBatchJob } from \"medusa-react\"\n * \n * type Props = {\n *   batchJobId: string\n * }\n * \n * const BatchJob = ({ batchJobId }: Props) => {\n *   const confirmBatchJob = useAdminConfirmBatchJob(batchJobId)\n *   // ...\n * \n *   const handleConfirm = () => {\n *     confirmBatchJob.mutate(undefined, {\n *       onSuccess: ({ batch_job }) => {\n *         console.log(batch_job)\n *       }\n *     })\n *   }\n * \n *   // ...\n * }\n * \n * export default BatchJob\n */\nexport const useAdminConfirmBatchJob = (\n  /**\n   * The ID of the batch job.\n   */\n  id: string,\n  options?: UseMutationOptions<Response<AdminBatchJobRes>, Error>\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n\n  return useMutation(\n    () => client.admin.batchJobs.confirm(id),\n    buildOptions(\n      queryClient,\n      [adminBatchJobsKeys.lists(), adminBatchJobsKeys.detail(id)],\n      options\n    )\n  )\n}\n","import {\n  AdminOrdersRes,\n  AdminPostOrdersOrderClaimsClaimFulfillmentsReq,\n  AdminPostOrdersOrderClaimsClaimReq,\n  AdminPostOrdersOrderClaimsClaimShipmentsReq,\n  AdminPostOrdersOrderClaimsReq,\n} from \"@medusajs/medusa\"\nimport { Response } from \"@medusajs/medusa-js\"\nimport {\n  useMutation,\n  UseMutationOptions,\n  useQueryClient,\n} from \"@tanstack/react-query\"\nimport { useMedusa } from \"../../../contexts/medusa\"\nimport { buildOptions } from \"../../utils/buildOptions\"\nimport { adminProductKeys } from \"../products\"\nimport { adminVariantKeys } from \"../variants\"\nimport { adminOrderKeys } from \"./../orders/queries\"\n\n/**\n * This hook creates a claim for an order. If a return shipping method is specified, a return will also be created and associated with the claim. If the claim's type is `refund`,\n * the refund is processed as well.\n * \n * @example\n * import React from \"react\"\n * import { useAdminCreateClaim } from \"medusa-react\"\n * \n * type Props = {\n *   orderId: string\n * }\n * \n * const CreateClaim = ({ orderId }: Props) => {\n *   const createClaim = useAdminCreateClaim(orderId)\n *   // ...\n * \n *   const handleCreate = (itemId: string) => {\n *     createClaim.mutate({\n *       type: \"refund\",\n *       claim_items: [\n *         {\n *           item_id: itemId,\n *           quantity: 1,\n *         },\n *       ],\n *     }, {\n *       onSuccess: ({ order }) => {\n *         console.log(order.claims)\n *       }\n *     })\n *   }\n * \n *   // ...\n * }\n * \n * export default CreateClaim\n * \n * @customNamespace Hooks.Admin.Claims\n * @category Mutations\n */\nexport const useAdminCreateClaim = (\n  /**\n   * The ID of the order the claim is associated with.\n   */\n  orderId: string,\n  options?: UseMutationOptions<\n    Response<AdminOrdersRes>,\n    Error,\n    AdminPostOrdersOrderClaimsReq\n  >\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n\n  return useMutation(\n    (payload: AdminPostOrdersOrderClaimsReq) =>\n      client.admin.orders.createClaim(orderId, payload),\n    buildOptions(queryClient, adminOrderKeys.detail(orderId), options)\n  )\n}\n\nexport type AdminUpdateClaimReq = AdminPostOrdersOrderClaimsClaimReq & { \n  /**\n   * The claim's ID.\n   */\n  claim_id: string\n}\n\n/**\n * This hook updates a claim's details.\n * \n * @example\n * import React from \"react\"\n * import { useAdminUpdateClaim } from \"medusa-react\"\n * \n * type Props = {\n *   orderId: string\n *   claimId: string\n * }\n * \n * const Claim = ({ orderId, claimId }: Props) => {\n *   const updateClaim = useAdminUpdateClaim(orderId)\n *   // ...\n * \n *   const handleUpdate = () => {\n *     updateClaim.mutate({\n *       claim_id: claimId,\n *       no_notification: false\n *     }, {\n *       onSuccess: ({ order }) => {\n *         console.log(order.claims)\n *       }\n *     })\n *   }\n * \n *   // ...\n * }\n * \n * export default Claim\n * \n * @customNamespace Hooks.Admin.Claims\n * @category Mutations\n */\nexport const useAdminUpdateClaim = (\n  /**\n   * The ID of the order the claim is associated with.\n   */\n  orderId: string,\n  options?: UseMutationOptions<\n    Response<AdminOrdersRes>,\n    Error,\n    AdminUpdateClaimReq\n  >\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n\n  return useMutation(\n    ({\n      claim_id,\n      ...payload\n    }: AdminUpdateClaimReq) =>\n      client.admin.orders.updateClaim(orderId, claim_id, payload),\n    buildOptions(queryClient, adminOrderKeys.detail(orderId), options)\n  )\n}\n\n/**\n * This hook cancels a claim and change its status. A claim can't be canceled if it has a refund, if its fulfillments haven't been canceled, \n * of if its associated return hasn't been canceled.\n * \n * @typeParamDefinition string - The claim's ID.\n * \n * @example\n * import React from \"react\"\n * import { useAdminCancelClaim } from \"medusa-react\"\n * \n * type Props = {\n *   orderId: string\n *   claimId: string\n * }\n * \n * const Claim = ({ orderId, claimId }: Props) => {\n *   const cancelClaim = useAdminCancelClaim(orderId)\n *   // ...\n * \n *   const handleCancel = () => {\n *     cancelClaim.mutate(claimId)\n *   }\n * \n *   // ...\n * }\n * \n * export default Claim\n * \n * @customNamespace Hooks.Admin.Claims\n * @category Mutations\n */\nexport const useAdminCancelClaim = (\n  /**\n   * The ID of the order the claim is associated with.\n   */\n  orderId: string,\n  options?: UseMutationOptions<\n    Response<AdminOrdersRes>, \n    Error, \n    string\n  >\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n\n  return useMutation(\n    (claimId: string) => client.admin.orders.cancelClaim(orderId, claimId),\n    buildOptions(queryClient, adminOrderKeys.detail(orderId), options)\n  )\n}\n\n/**\n * The details of the claim's fulfillment.\n */\nexport type AdminFulfillClaimReq =  AdminPostOrdersOrderClaimsClaimFulfillmentsReq & { \n  /**\n   * The claim's ID.\n   */\n  claim_id: string\n}\n\n/**\n * This hook creates a Fulfillment for a Claim, and change its fulfillment status to `partially_fulfilled` or `fulfilled` depending on whether all the items were fulfilled.\n * It may also change the status to `requires_action` if any actions are required.\n * \n * @example\n * import React from \"react\"\n * import { useAdminFulfillClaim } from \"medusa-react\"\n * \n * type Props = {\n *   orderId: string\n *   claimId: string\n * }\n * \n * const Claim = ({ orderId, claimId }: Props) => {\n *   const fulfillClaim = useAdminFulfillClaim(orderId)\n *   // ...\n * \n *   const handleFulfill = () => {\n *     fulfillClaim.mutate({\n *       claim_id: claimId,\n *     }, {\n *       onSuccess: ({ order }) => {\n *         console.log(order.claims)\n *       }\n *     })\n *   }\n * \n *   // ...\n * }\n * \n * export default Claim\n * \n * @customNamespace Hooks.Admin.Claims\n * @category Mutations\n */\nexport const useAdminFulfillClaim = (\n  /**\n   * The ID of the order the claim is associated with.\n   */\n  orderId: string,\n  options?: UseMutationOptions<\n    Response<AdminOrdersRes>,\n    Error,\n    AdminFulfillClaimReq\n  >\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n\n  return useMutation(\n    ({\n      claim_id,\n      ...payload\n    }: AdminFulfillClaimReq) =>\n      client.admin.orders.fulfillClaim(orderId, claim_id, payload),\n    buildOptions(\n      queryClient,\n      [\n        adminOrderKeys.detail(orderId),\n        adminVariantKeys.all,\n        adminProductKeys.lists(),\n      ],\n      options\n    )\n  )\n}\n\n/**\n * The cancelation details.\n */\nexport type AdminCancelClaimFulfillmentReq = { \n  /**\n   * The claim's ID.\n   */\n  claim_id: string; \n  /**\n   * The fulfillment's ID.\n   */\n  fulfillment_id: string\n}\n\n/**\n * This hook cancels a claim's fulfillment and change its fulfillment status to `canceled`.\n * \n * @example\n * import React from \"react\"\n * import { useAdminCancelClaimFulfillment } from \"medusa-react\"\n * \n * type Props = {\n *   orderId: string\n *   claimId: string\n * }\n * \n * const Claim = ({ orderId, claimId }: Props) => {\n *   const cancelFulfillment = useAdminCancelClaimFulfillment(\n *     orderId\n *   )\n *   // ...\n * \n *   const handleCancel = (fulfillmentId: string) => {\n *     cancelFulfillment.mutate({\n *       claim_id: claimId,\n *       fulfillment_id: fulfillmentId,\n *     }, {\n *       onSuccess: ({ order }) => {\n *         console.log(order.claims)\n *       }\n *     })\n *   }\n * \n *   // ...\n * }\n * \n * export default Claim\n * \n * @customNamespace Hooks.Admin.Claims\n * @category Mutations\n */\nexport const useAdminCancelClaimFulfillment = (\n  /**\n   * The ID of the order the claim is associated with.\n   */\n  orderId: string,\n  options?: UseMutationOptions<\n    Response<AdminOrdersRes>,\n    Error,\n    AdminCancelClaimFulfillmentReq\n  >\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n\n  return useMutation(\n    ({\n      claim_id,\n      fulfillment_id,\n    }: AdminCancelClaimFulfillmentReq) =>\n      client.admin.orders.cancelClaimFulfillment(\n        orderId,\n        claim_id,\n        fulfillment_id\n      ),\n    buildOptions(queryClient, adminOrderKeys.detail(orderId), options)\n  )\n}\n\n/**\n * This hook creates a shipment for the claim and mark its fulfillment as shipped. If the shipment is created successfully, this changes the claim's fulfillment status\n * to either `partially_shipped` or `shipped`, depending on whether all the items were shipped.\n * \n * @example\n * import React from \"react\"\n * import { useAdminCreateClaimShipment } from \"medusa-react\"\n * \n * type Props = {\n *   orderId: string\n *   claimId: string\n * }\n * \n * const Claim = ({ orderId, claimId }: Props) => {\n *   const createShipment = useAdminCreateClaimShipment(orderId)\n *   // ...\n * \n *   const handleCreateShipment = (fulfillmentId: string) => {\n *     createShipment.mutate({\n *       claim_id: claimId,\n *       fulfillment_id: fulfillmentId,\n *     }, {\n *       onSuccess: ({ order }) => {\n *         console.log(order.claims)\n *       }\n *     })\n *   }\n * \n *   // ...\n * }\n * \n * export default Claim\n * \n * @customNamespace Hooks.Admin.Claims\n * @category Mutations\n */\nexport const useAdminCreateClaimShipment = (\n  /**\n   * The ID of the order the claim is associated with.\n   */\n  orderId: string,\n  options?: UseMutationOptions<\n    Response<AdminOrdersRes>,\n    Error,\n    AdminPostOrdersOrderClaimsClaimShipmentsReq & { \n      /**\n       * The claim's ID.\n       */\n      claim_id: string\n    }\n  >\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n\n  return useMutation(\n    ({\n      claim_id,\n      ...payload\n    }: AdminPostOrdersOrderClaimsClaimShipmentsReq & { claim_id: string }) =>\n      client.admin.orders.createClaimShipment(orderId, claim_id, payload),\n    buildOptions(queryClient, adminOrderKeys.detail(orderId), options)\n  )\n}\n","import {\n  AdminGetProductParams,\n  AdminGetProductsParams,\n  AdminGetProductsVariantsParams,\n  AdminProductsListRes,\n  AdminProductsListTagsRes,\n  AdminProductsListVariantsRes,\n  AdminProductsRes,\n} from \"@medusajs/medusa\"\nimport { Response } from \"@medusajs/medusa-js\"\nimport { useQuery } from \"@tanstack/react-query\"\nimport { useMedusa } from \"../../../contexts\"\nimport { UseQueryOptionsWrapper } from \"../../../types\"\nimport { queryKeysFactory } from \"../../utils/index\"\n\nconst ADMIN_PRODUCTS_QUERY_KEY = `admin_products` as const\n\nexport const adminProductKeys = {\n  ...queryKeysFactory(ADMIN_PRODUCTS_QUERY_KEY),\n  detailVariants(id: string, query?: any) {\n    return [\n      ...this.detail(id),\n      \"variants\" as const,\n      { ...(query || {}) },\n    ] as const\n  },\n}\n\ntype ProductQueryKeys = typeof adminProductKeys\n\n/**\n * This hook retrieves a list of products. The products can be filtered by fields such as `q` or `status` passed in\n * the `query` parameter. The products can also be sorted or paginated.\n *\n * @example\n * To list products:\n *\n * ```tsx\n * import React from \"react\"\n * import { useAdminProducts } from \"medusa-react\"\n *\n * const Products = () => {\n *   const { products, isLoading } = useAdminProducts()\n *\n *   return (\n *     <div>\n *       {isLoading && <span>Loading...</span>}\n *       {products && !products.length && <span>No Products</span>}\n *       {products && products.length > 0 && (\n *         <ul>\n *           {products.map((product) => (\n *             <li key={product.id}>{product.title}</li>\n *           ))}\n *         </ul>\n *       )}\n *     </div>\n *   )\n * }\n *\n * export default Products\n * ```\n *\n * To specify relations that should be retrieved within the products:\n *\n * ```tsx\n * import React from \"react\"\n * import { useAdminProducts } from \"medusa-react\"\n *\n * const Products = () => {\n *   const { products, isLoading } = useAdminProducts({\n *     expand: \"images\"\n *   })\n *\n *   return (\n *     <div>\n *       {isLoading && <span>Loading...</span>}\n *       {products && !products.length && <span>No Products</span>}\n *       {products && products.length > 0 && (\n *         <ul>\n *           {products.map((product) => (\n *             <li key={product.id}>{product.title}</li>\n *           ))}\n *         </ul>\n *       )}\n *     </div>\n *   )\n * }\n *\n * export default Products\n * ```\n *\n * By default, only the first `50` records are retrieved. You can control pagination by specifying the `limit` and `offset` properties:\n *\n * ```tsx\n * import React from \"react\"\n * import { useAdminProducts } from \"medusa-react\"\n *\n * const Products = () => {\n *   const {\n *     products,\n *     limit,\n *     offset,\n *     isLoading\n *   } = useAdminProducts({\n *     expand: \"images\",\n *     limit: 20,\n *     offset: 0\n *   })\n *\n *   return (\n *     <div>\n *       {isLoading && <span>Loading...</span>}\n *       {products && !products.length && <span>No Products</span>}\n *       {products && products.length > 0 && (\n *         <ul>\n *           {products.map((product) => (\n *             <li key={product.id}>{product.title}</li>\n *           ))}\n *         </ul>\n *       )}\n *     </div>\n *   )\n * }\n *\n * export default Products\n * ```\n *\n * @customNamespace Hooks.Admin.Products\n * @category Queries\n */\nexport const useAdminProducts = (\n  /**\n   * Filters and pagination configurations to apply on the retrieved products.\n   */\n  query?: AdminGetProductsParams,\n  options?: UseQueryOptionsWrapper<\n    Response<AdminProductsListRes>,\n    Error,\n    ReturnType<ProductQueryKeys[\"list\"]>\n  >\n) => {\n  const { client } = useMedusa()\n  const { data, ...rest } = useQuery(\n    adminProductKeys.list(query),\n    () => client.admin.products.list(query),\n    options\n  )\n  return { ...data, ...rest } as const\n}\n\n/**\n * This hook retrieves a product's details.\n *\n * @example\n * import React from \"react\"\n * import { useAdminProduct } from \"medusa-react\"\n *\n * type Props = {\n *   productId: string\n * }\n *\n * const Product = ({ productId }: Props) => {\n *   const {\n *     product,\n *     isLoading,\n *   } = useAdminProduct(productId)\n *\n *   return (\n *     <div>\n *       {isLoading && <span>Loading...</span>}\n *       {product && <span>{product.title}</span>}\n *\n *     </div>\n *   )\n * }\n *\n * export default Product\n *\n * @customNamespace Hooks.Admin.Products\n * @category Queries\n */\nexport const useAdminProduct = (\n  /**\n   * The product's ID.\n   */\n  id: string,\n  /**\n   * Configurations to apply on the retrieved product.\n   */\n  query?: AdminGetProductParams,\n  options?: UseQueryOptionsWrapper<\n    Response<AdminProductsRes>,\n    Error,\n    ReturnType<ProductQueryKeys[\"detail\"]>\n  >\n) => {\n  const { client } = useMedusa()\n  const { data, ...rest } = useQuery(\n    adminProductKeys.detail(id),\n    () => client.admin.products.retrieve(id, query),\n    options\n  )\n  return { ...data, ...rest } as const\n}\n\nexport const useAdminProductVariants = (\n  /**\n   * The product's ID.\n   */\n  id: string,\n  /**\n   * Configurations to apply on the retrieved product variants.\n   */\n  query?: AdminGetProductsVariantsParams,\n  options?: UseQueryOptionsWrapper<\n    Response<AdminProductsListVariantsRes>,\n    Error,\n    ReturnType<ProductQueryKeys[\"detailVariants\"]>\n  >\n) => {\n  const { client } = useMedusa()\n  const { data, ...rest } = useQuery(\n    adminProductKeys.detailVariants(id, query),\n    () => client.admin.products.listVariants(id, query),\n    options\n  )\n  return { ...data, ...rest } as const\n}\n\n/**\n * This hook retrieves a list of Product Tags with how many times each is used in products.\n *\n * @example\n * import React from \"react\"\n * import { useAdminProductTagUsage } from \"medusa-react\"\n *\n * const ProductTags = (productId: string) => {\n *   const { tags, isLoading } = useAdminProductTagUsage()\n *\n *   return (\n *     <div>\n *       {isLoading && <span>Loading...</span>}\n *       {tags && !tags.length && <span>No Product Tags</span>}\n *       {tags && tags.length > 0 && (\n *         <ul>\n *           {tags.map((tag) => (\n *             <li key={tag.id}>{tag.value} - {tag.usage_count}</li>\n *           ))}\n *         </ul>\n *       )}\n *     </div>\n *   )\n * }\n *\n * export default ProductTags\n *\n * @customNamespace Hooks.Admin.Products\n * @category Queries\n */\nexport const useAdminProductTagUsage = (\n  options?: UseQueryOptionsWrapper<\n    Response<AdminProductsListTagsRes>,\n    Error,\n    ReturnType<ProductQueryKeys[\"detail\"]>\n  >\n) => {\n  const { client } = useMedusa()\n  const { data, ...rest } = useQuery(\n    adminProductKeys.detail(\"tags\"),\n    () => client.admin.products.listTags(),\n    options\n  )\n  return { ...data, ...rest } as const\n}\n","import {\n  AdminPostProductsProductOptionsOption,\n  AdminPostProductsProductOptionsReq,\n  AdminPostProductsProductReq,\n  AdminPostProductsProductVariantsReq,\n  AdminPostProductsProductVariantsVariantReq,\n  AdminPostProductsReq,\n  AdminProductsDeleteOptionRes,\n  AdminProductsDeleteRes,\n  AdminProductsDeleteVariantRes,\n  AdminProductsRes,\n} from \"@medusajs/medusa\"\nimport { Response } from \"@medusajs/medusa-js\"\nimport {\n  useMutation,\n  UseMutationOptions,\n  useQueryClient,\n} from \"@tanstack/react-query\"\nimport { useMedusa } from \"../../../contexts\"\nimport { buildOptions } from \"../../utils/buildOptions\"\nimport { adminProductKeys } from \"./queries\"\n\n/**\n * This hook creates a new Product. This hook can also be used to create a gift card if the `is_giftcard` field is set to `true`.\n * \n * @example\n * import React from \"react\"\n * import { useAdminCreateProduct } from \"medusa-react\"\n * \n * type CreateProductData = {\n *   title: string\n *   is_giftcard: boolean\n *   discountable: boolean\n *   options: {\n *     title: string\n *   }[]\n *   variants: {\n *     title: string\n *     prices: {\n *       amount: number\n *       currency_code :string\n *     }[]\n *     options: {\n *       value: string\n *     }[]\n *   }[],\n *   collection_id: string\n *   categories: {\n *     id: string\n *   }[]\n *   type: {\n *     value: string\n *   }\n *   tags: {\n *     value: string\n *   }[]\n * }\n * \n * const CreateProduct = () => {\n *   const createProduct = useAdminCreateProduct()\n *   // ...\n * \n *   const handleCreate = (productData: CreateProductData) => {\n *     createProduct.mutate(productData, {\n *       onSuccess: ({ product }) => {\n *         console.log(product.id)\n *       }\n *     })\n *   }\n * \n *   // ...\n * }\n * \n * export default CreateProduct\n * \n * @customNamespace Hooks.Admin.Products\n * @category Mutations\n */\nexport const useAdminCreateProduct = (\n  options?: UseMutationOptions<\n    Response<AdminProductsRes>,\n    Error,\n    AdminPostProductsReq\n  >\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n  return useMutation(\n    (payload: AdminPostProductsReq) => client.admin.products.create(payload),\n    buildOptions(queryClient, adminProductKeys.lists(), options)\n  )\n}\n\n/**\n * This hook updates a Product's details.\n * \n * @example\n * import React from \"react\"\n * import { useAdminUpdateProduct } from \"medusa-react\"\n * \n * type Props = {\n *   productId: string\n * }\n * \n * const Product = ({ productId }: Props) => {\n *   const updateProduct = useAdminUpdateProduct(\n *     productId\n *   )\n *   // ...\n * \n *   const handleUpdate = (\n *     title: string\n *   ) => {\n *     updateProduct.mutate({\n *       title,\n *     }, {\n *       onSuccess: ({ product }) => {\n *         console.log(product.id)\n *       }\n *     })\n *   }\n * \n *   // ...\n * }\n * \n * export default Product\n * \n * @customNamespace Hooks.Admin.Products\n * @category Mutations\n */\nexport const useAdminUpdateProduct = (\n  /**\n   * The product's ID.\n   */\n  id: string,\n  options?: UseMutationOptions<\n    Response<AdminProductsRes>,\n    Error,\n    AdminPostProductsProductReq\n  >\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n\n  return useMutation(\n    (payload: AdminPostProductsProductReq) =>\n      client.admin.products.update(id, payload),\n    buildOptions(\n      queryClient,\n      [adminProductKeys.lists(), adminProductKeys.detail(id)],\n      options\n    )\n  )\n}\n\n/**\n * This hook deletes a product and its associated product variants and options.\n * \n * @example\n * import React from \"react\"\n * import { useAdminDeleteProduct } from \"medusa-react\"\n * \n * type Props = {\n *   productId: string\n * }\n * \n * const Product = ({ productId }: Props) => {\n *   const deleteProduct = useAdminDeleteProduct(\n *     productId\n *   )\n *   // ...\n * \n *   const handleDelete = () => {\n *     deleteProduct.mutate(void 0, {\n *       onSuccess: ({ id, object, deleted}) => {\n *         console.log(id)\n *       }\n *     })\n *   }\n * \n *   // ...\n * }\n * \n * export default Product\n * \n * @customNamespace Hooks.Admin.Products\n * @category Mutations\n */\nexport const useAdminDeleteProduct = (\n  /**\n   * The product's ID.\n   */\n  id: string,\n  options?: UseMutationOptions<Response<AdminProductsDeleteRes>, Error, void>\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n\n  return useMutation(\n    () => client.admin.products.delete(id),\n    buildOptions(\n      queryClient,\n      [adminProductKeys.lists(), adminProductKeys.detail(id)],\n      options\n    )\n  )\n}\n\n/**\n * This hook creates a product variant associated with a product. Each product variant must have a unique combination of product option values.\n * \n * @example\n * import React from \"react\"\n * import { useAdminCreateVariant } from \"medusa-react\"\n * \n * type CreateVariantData = {\n *   title: string\n *   prices: {\n *     amount: number\n *     currency_code: string\n *   }[]\n *   options: {\n *     option_id: string\n *     value: string\n *   }[]\n * }\n * \n * type Props = {\n *   productId: string\n * }\n * \n * const CreateProductVariant = ({ productId }: Props) => {\n *   const createVariant = useAdminCreateVariant(\n *     productId\n *   )\n *   // ...\n * \n *   const handleCreate = (\n *     variantData: CreateVariantData\n *   ) => {\n *     createVariant.mutate(variantData, {\n *       onSuccess: ({ product }) => {\n *         console.log(product.variants)\n *       }\n *     })\n *   }\n * \n *   // ...\n * }\n * \n * export default CreateProductVariant\n * \n * @customNamespace Hooks.Admin.Products\n * @category Mutations\n */\nexport const useAdminCreateVariant = (\n  /**\n   * The product's ID.\n   */\n  productId: string,\n  options?: UseMutationOptions<\n    Response<AdminProductsRes>,\n    Error,\n    AdminPostProductsProductVariantsReq\n  >\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n\n  return useMutation(\n    (payload: AdminPostProductsProductVariantsReq) =>\n      client.admin.products.createVariant(productId, payload),\n    buildOptions(\n      queryClient,\n      [adminProductKeys.lists(), adminProductKeys.detail(productId)],\n      options\n    )\n  )\n}\n\nexport type AdminUpdateVariantReq = AdminPostProductsProductVariantsVariantReq & { \n  /**\n   * The product variant's ID.\n   */\n  variant_id: string\n}\n\n/**\n * This hook updates a product variant's details.\n * \n * @example\n * import React from \"react\"\n * import { useAdminUpdateVariant } from \"medusa-react\"\n * \n * type Props = {\n *   productId: string\n *   variantId: string\n * }\n * \n * const ProductVariant = ({\n *   productId,\n *   variantId\n * }: Props) => {\n *   const updateVariant = useAdminUpdateVariant(\n *     productId\n *   )\n *   // ...\n * \n *   const handleUpdate = (title: string) => {\n *     updateVariant.mutate({\n *       variant_id: variantId,\n *       title,\n *     }, {\n *       onSuccess: ({ product }) => {\n *         console.log(product.variants)\n *       }\n *     })\n *   }\n * \n *   // ...\n * }\n * \n * export default ProductVariant\n * \n * @customNamespace Hooks.Admin.Products\n * @category Mutations\n */\nexport const useAdminUpdateVariant = (\n  /**\n   * The product's ID.\n   */\n  productId: string,\n  options?: UseMutationOptions<\n    Response<AdminProductsRes>,\n    Error,\n    AdminUpdateVariantReq\n  >\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n\n  return useMutation(\n    ({\n      variant_id,\n      ...payload\n    }: AdminUpdateVariantReq) =>\n      client.admin.products.updateVariant(productId, variant_id, payload),\n    buildOptions(\n      queryClient,\n      [adminProductKeys.lists(), adminProductKeys.detail(productId)],\n      options\n    )\n  )\n}\n\n/**\n * This hook deletes a product variant.\n * \n * @typeParamDefinition string - The ID of the product variant to delete.\n * \n * @example\n * import React from \"react\"\n * import { useAdminDeleteVariant } from \"medusa-react\"\n * \n * type Props = {\n *   productId: string\n *   variantId: string\n * }\n * \n * const ProductVariant = ({\n *   productId,\n *   variantId\n * }: Props) => {\n *   const deleteVariant = useAdminDeleteVariant(\n *     productId\n *   )\n *   // ...\n * \n *   const handleDelete = () => {\n *     deleteVariant.mutate(variantId, {\n *       onSuccess: ({ variant_id, object, deleted, product }) => {\n *         console.log(product.variants)\n *       }\n *     })\n *   }\n * \n *   // ...\n * }\n * \n * export default ProductVariant\n * \n * @customNamespace Hooks.Admin.Products\n * @category Mutations\n */\nexport const useAdminDeleteVariant = (\n  /**\n   * The product's ID.\n   */\n  productId: string,\n  options?: UseMutationOptions<\n    Response<AdminProductsDeleteVariantRes>,\n    Error,\n    string\n  >\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n\n  return useMutation(\n    (variantId: string) =>\n      client.admin.products.deleteVariant(productId, variantId),\n    buildOptions(\n      queryClient,\n      [adminProductKeys.lists(), adminProductKeys.detail(productId)],\n      options\n    )\n  )\n}\n\n/**\n * This hook adds a product option to a product.\n * \n * @example\n * import React from \"react\"\n * import { useAdminCreateProductOption } from \"medusa-react\"\n * \n * type Props = {\n *   productId: string\n * }\n * \n * const CreateProductOption = ({ productId }: Props) => {\n *   const createOption = useAdminCreateProductOption(\n *     productId\n *   )\n *   // ...\n * \n *   const handleCreate = (\n *     title: string\n *   ) => {\n *     createOption.mutate({\n *       title\n *     }, {\n *       onSuccess: ({ product }) => {\n *         console.log(product.options)\n *       }\n *     })\n *   }\n * \n *   // ...\n * }\n * \n * export default CreateProductOption\n * \n * @customNamespace Hooks.Admin.Products\n * @category Mutations\n */\nexport const useAdminCreateProductOption = (\n  /**\n   * The product's ID.\n   */\n  productId: string,\n  options?: UseMutationOptions<\n    Response<AdminProductsRes>,\n    Error,\n    AdminPostProductsProductOptionsReq\n  >\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n\n  return useMutation(\n    (payload: AdminPostProductsProductOptionsReq) =>\n      client.admin.products.addOption(productId, payload),\n    buildOptions(queryClient, adminProductKeys.detail(productId), options)\n  )\n}\n\nexport type AdminUpdateProductOptionReq = AdminPostProductsProductOptionsOption & { \n  /**\n   * The ID of the product option to update.\n   */\n  option_id: string\n}\n\n/**\n * This hook updates a product option's details.\n * \n * @example\n * import React from \"react\"\n * import { useAdminUpdateProductOption } from \"medusa-react\"\n * \n * type Props = {\n *   productId: string\n *   optionId: string\n * }\n * \n * const ProductOption = ({\n *   productId,\n *   optionId\n * }: Props) => {\n *   const updateOption = useAdminUpdateProductOption(\n *     productId\n *   )\n *   // ...\n * \n *   const handleUpdate = (\n *     title: string\n *   ) => {\n *     updateOption.mutate({\n *       option_id: optionId,\n *       title,\n *     }, {\n *       onSuccess: ({ product }) => {\n *         console.log(product.options)\n *       }\n *     })\n *   }\n * \n *   // ...\n * }\n * \n * export default ProductOption\n * \n * @customNamespace Hooks.Admin.Products\n * @category Mutations\n */\nexport const useAdminUpdateProductOption = (\n  /**\n   * The product's ID.\n   */\n  productId: string,\n  options?: UseMutationOptions<\n    Response<AdminProductsRes>,\n    Error,\n    AdminUpdateProductOptionReq\n  >\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n\n  return useMutation(\n    ({\n      option_id,\n      ...payload\n    }: AdminUpdateProductOptionReq) =>\n      client.admin.products.updateOption(productId, option_id, payload),\n    buildOptions(queryClient, adminProductKeys.detail(productId), options)\n  )\n}\n\n/**\n * This hook deletes a product option. If there are product variants that use this product option, \n * they must be deleted before deleting the product option.\n * \n * @typeParamDefinition string - The ID of the product option to delete.\n * \n * @example\n * import React from \"react\"\n * import { useAdminDeleteProductOption } from \"medusa-react\"\n * \n * type Props = {\n *   productId: string\n *   optionId: string\n * }\n * \n * const ProductOption = ({\n *   productId,\n *   optionId\n * }: Props) => {\n *   const deleteOption = useAdminDeleteProductOption(\n *     productId\n *   )\n *   // ...\n * \n *   const handleDelete = () => {\n *     deleteOption.mutate(optionId, {\n *       onSuccess: ({ option_id, object, deleted, product }) => {\n *         console.log(product.options)\n *       }\n *     })\n *   }\n * \n *   // ...\n * }\n * \n * export default ProductOption\n * \n * @customNamespace Hooks.Admin.Products\n * @category Mutations\n */\nexport const useAdminDeleteProductOption = (\n  /**\n   * The product's ID.\n   */\n  productId: string,\n  options?: UseMutationOptions<\n    Response<AdminProductsDeleteOptionRes>,\n    Error,\n    string\n  >\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n\n  return useMutation(\n    (optionId: string) =>\n      client.admin.products.deleteOption(productId, optionId),\n    buildOptions(queryClient, adminProductKeys.detail(productId), options)\n  )\n}\n","import {\n  AdminGetVariantParams,\n  AdminGetVariantsParams,\n  AdminGetVariantsVariantInventoryRes,\n  AdminVariantsListRes,\n  AdminVariantsRes,\n} from \"@medusajs/medusa\"\nimport { Response } from \"@medusajs/medusa-js\"\nimport { useQuery } from \"@tanstack/react-query\"\nimport { useMedusa } from \"../../../contexts\"\nimport { UseQueryOptionsWrapper } from \"../../../types\"\nimport { queryKeysFactory } from \"../../utils/index\"\n\nconst ADMIN_VARIANT_QUERY_KEY = `admin_variants` as const\n\nexport const adminVariantKeys = queryKeysFactory(ADMIN_VARIANT_QUERY_KEY)\n\ntype VariantQueryKeys = typeof adminVariantKeys\n\n/**\n * This hook retrieves a list of product variants. The product variant can be filtered by fields such as `id` or `title` \n * passed in the `query` parameter. The product variant can also be paginated.\n * \n * @example\n * To list product variants:\n * \n * ```tsx\n * import React from \"react\"\n * import { useAdminVariants } from \"medusa-react\"\n * \n * const Variants = () => {\n *   const { variants, isLoading } = useAdminVariants()\n * \n *   return (\n *     <div>\n *       {isLoading && <span>Loading...</span>}\n *       {variants && !variants.length && (\n *         <span>No Variants</span>\n *       )}\n *       {variants && variants.length > 0 && (\n *         <ul>\n *           {variants.map((variant) => (\n *             <li key={variant.id}>{variant.title}</li>\n *           ))}\n *         </ul>\n *       )}\n *     </div>\n *   )\n * }\n * \n * export default Variants\n * ```\n * \n * To specify relations that should be retrieved within the product variants:\n * \n * ```tsx\n * import React from \"react\"\n * import { useAdminVariants } from \"medusa-react\"\n * \n * const Variants = () => {\n *   const { variants, isLoading } = useAdminVariants({\n *     expand: \"options\"\n *   })\n * \n *   return (\n *     <div>\n *       {isLoading && <span>Loading...</span>}\n *       {variants && !variants.length && (\n *         <span>No Variants</span>\n *       )}\n *       {variants && variants.length > 0 && (\n *         <ul>\n *           {variants.map((variant) => (\n *             <li key={variant.id}>{variant.title}</li>\n *           ))}\n *         </ul>\n *       )}\n *     </div>\n *   )\n * }\n * \n * export default Variants\n * ```\n * \n * By default, only the first `100` records are retrieved. You can control pagination by specifying the `limit` and `offset` properties:\n * \n * ```tsx\n * import React from \"react\"\n * import { useAdminVariants } from \"medusa-react\"\n * \n * const Variants = () => {\n *   const { \n *     variants, \n *     limit,\n *     offset,\n *     isLoading\n *   } = useAdminVariants({\n *     expand: \"options\",\n *     limit: 50,\n *     offset: 0\n *   })\n * \n *   return (\n *     <div>\n *       {isLoading && <span>Loading...</span>}\n *       {variants && !variants.length && (\n *         <span>No Variants</span>\n *       )}\n *       {variants && variants.length > 0 && (\n *         <ul>\n *           {variants.map((variant) => (\n *             <li key={variant.id}>{variant.title}</li>\n *           ))}\n *         </ul>\n *       )}\n *     </div>\n *   )\n * }\n * \n * export default Variants\n * ```\n * \n * @customNamespace Hooks.Admin.Product Variants\n * @category Queries\n */\nexport const useAdminVariants = (\n  /**\n   * Filters and pagination configurations to apply on the retrieved product variants.\n   */\n  query?: AdminGetVariantsParams,\n  options?: UseQueryOptionsWrapper<\n    Response<AdminVariantsListRes>,\n    Error,\n    ReturnType<VariantQueryKeys[\"list\"]>\n  >\n) => {\n  const { client } = useMedusa()\n  const { data, ...rest } = useQuery(\n    adminVariantKeys.list(query),\n    () => client.admin.variants.list(query),\n    options\n  )\n  return { ...data, ...rest } as const\n}\n\n/**\n * This hook retrieves a product variant's details.\n * \n * @example\n * A simple example that retrieves a product variant by its ID:\n * \n * ```tsx\n * import React from \"react\"\n * import { useAdminVariant } from \"medusa-react\"\n * \n * type Props = {\n *   variantId: string\n * }\n * \n * const Variant = ({ variantId }: Props) => {\n *   const { variant, isLoading } = useAdminVariant(\n *     variantId\n *   )\n * \n *   return (\n *     <div>\n *       {isLoading && <span>Loading...</span>}\n *       {variant && <span>{variant.title}</span>}\n *     </div>\n *   )\n * }\n * \n * export default Variant\n * ```\n * \n * To specify relations that should be retrieved:\n * \n * ```tsx\n * import React from \"react\"\n * import { useAdminVariant } from \"medusa-react\"\n * \n * type Props = {\n *   variantId: string\n * }\n * \n * const Variant = ({ variantId }: Props) => {\n *   const { variant, isLoading } = useAdminVariant(\n *     variantId, {\n *       expand: \"options\"\n *     }\n *   )\n * \n *   return (\n *     <div>\n *       {isLoading && <span>Loading...</span>}\n *       {variant && <span>{variant.title}</span>}\n *     </div>\n *   )\n * }\n * \n * export default Variant\n * ```\n * \n * @customNamespace Hooks.Admin.Product Variants\n * @category Queries\n */\nexport const useAdminVariant = (\n  /**\n   * The product variant's ID.\n   */\n  id: string,\n  /**\n   * Configurations to apply on the retrieved product variant.\n   */\n  query?: AdminGetVariantParams,\n  options?: UseQueryOptionsWrapper<\n    Response<AdminVariantsRes>,\n    Error,\n    ReturnType<VariantQueryKeys[\"detail\"]>\n  >\n) => {\n  const { client } = useMedusa()\n  const { data, ...rest } = useQuery(\n    adminVariantKeys.detail(id),\n    () => client.admin.variants.retrieve(id, query),\n    options\n  )\n  return { ...data, ...rest } as const\n}\n\n/**\n * This hook retrieves the available inventory of a product variant.\n * \n * @example\n * import React from \"react\"\n * import { useAdminVariantsInventory } from \"medusa-react\"\n * \n * type Props = {\n *   variantId: string\n * }\n * \n * const VariantInventory = ({ variantId }: Props) => {\n *   const { variant, isLoading } = useAdminVariantsInventory(\n *     variantId\n *   )\n * \n *   return (\n *     <div>\n *       {isLoading && <span>Loading...</span>}\n *       {variant && variant.inventory.length === 0 && (\n *         <span>Variant doesn't have inventory details</span>\n *       )}\n *       {variant && variant.inventory.length > 0 && (\n *         <ul>\n *           {variant.inventory.map((inventory) => (\n *             <li key={inventory.id}>{inventory.title}</li>\n *           ))}\n *         </ul>\n *       )}\n *     </div>\n *   )\n * }\n * \n * export default VariantInventory\n * \n * @customNamespace Hooks.Admin.Product Variants\n * @category Queries\n */\nexport const useAdminVariantsInventory = (\n  /**\n   * The product variant's ID.\n   */\n  id: string,\n  options?: UseQueryOptionsWrapper<\n    Response<AdminGetVariantsVariantInventoryRes>,\n    Error,\n    ReturnType<VariantQueryKeys[\"detail\"]>\n  >\n) => {\n  const { client } = useMedusa()\n  const { data, ...rest } = useQuery(\n    adminVariantKeys.detail(id),\n    () => client.admin.variants.getInventory(id),\n    options\n  )\n  return { ...data, ...rest } as const\n}\n","import {\n  AdminGetOrdersParams,\n  AdminOrdersListRes,\n  AdminOrdersRes,\n} from \"@medusajs/medusa\"\nimport { Response } from \"@medusajs/medusa-js\"\nimport { FindParams } from \"@medusajs/medusa/dist/types/common\"\nimport { useQuery } from \"@tanstack/react-query\"\nimport { useMedusa } from \"../../../contexts\"\nimport { UseQueryOptionsWrapper } from \"../../../types\"\nimport { queryKeysFactory } from \"../../utils/index\"\n\nconst ADMIN_ORDERS_QUERY_KEY = `admin_orders` as const\n\nexport const adminOrderKeys = {\n  ...queryKeysFactory(ADMIN_ORDERS_QUERY_KEY),\n  detailOrder(id: string, query?: FindParams) {\n    return [...this.detail(id), { ...(query || {}) }]\n  },\n}\n\ntype OrderQueryKeys = typeof adminOrderKeys\n\n/**\n * This hook retrieves a list of orders. The orders can be filtered by fields such as `status` or `display_id` passed \n * in the `query` parameter. The order can also be paginated.\n * \n * @example\n * To list orders:\n * \n * ```tsx\n * import React from \"react\"\n * import { useAdminOrders } from \"medusa-react\"\n * \n * const Orders = () => {\n *   const { orders, isLoading } = useAdminOrders()\n * \n *   return (\n *     <div>\n *       {isLoading && <span>Loading...</span>}\n *       {orders && !orders.length && <span>No Orders</span>}\n *       {orders && orders.length > 0 && (\n *         <ul>\n *           {orders.map((order) => (\n *             <li key={order.id}>{order.display_id}</li>\n *           ))}\n *         </ul>\n *       )}\n *     </div>\n *   )\n * }\n * \n * export default Orders\n * ```\n * \n * You can use the `query` parameter to pass filters and specify relations that should be retrieved within the orders. In addition,\n * By default, only the first `50` records are retrieved. You can control pagination by specifying the `limit` and `offset` properties:\n * \n * ```tsx\n * import React from \"react\"\n * import { useAdminOrders } from \"medusa-react\"\n * \n * const Orders = () => {\n *   const { \n *     orders,\n *     limit,\n *     offset,\n *     isLoading\n *   } = useAdminOrders({\n *     expand: \"customers\",\n *     limit: 20,\n *     offset: 0\n *   })\n * \n *   return (\n *     <div>\n *       {isLoading && <span>Loading...</span>}\n *       {orders && !orders.length && <span>No Orders</span>}\n *       {orders && orders.length > 0 && (\n *         <ul>\n *           {orders.map((order) => (\n *             <li key={order.id}>{order.display_id}</li>\n *           ))}\n *         </ul>\n *       )}\n *     </div>\n *   )\n * }\n * \n * export default Orders\n * ```\n * \n * @customNamespace Hooks.Admin.Orders\n * @category Queries\n */\nexport const useAdminOrders = (\n  /**\n   * Filters and pagination configurations applied on the retrieved orders.\n   */\n  query?: AdminGetOrdersParams,\n  options?: UseQueryOptionsWrapper<\n    Response<AdminOrdersListRes>,\n    Error,\n    ReturnType<OrderQueryKeys[\"list\"]>\n  >\n) => {\n  const { client } = useMedusa()\n  const { data, ...rest } = useQuery(\n    adminOrderKeys.list(query),\n    () => client.admin.orders.list(query),\n    options\n  )\n  return { ...data, ...rest } as const\n}\n\n/**\n * This hook retrieve an order's details.\n * \n * @example\n * A simple example that retrieves an order by its ID:\n * \n * ```tsx\n * import React from \"react\"\n * import { useAdminOrder } from \"medusa-react\"\n * \n * type Props = {\n *   orderId: string\n * }\n * \n * const Order = ({ orderId }: Props) => {\n *   const { \n *     order, \n *     isLoading, \n *   } = useAdminOrder(orderId)\n * \n *   return (\n *     <div>\n *       {isLoading && <span>Loading...</span>}\n *       {order && <span>{order.display_id}</span>}\n *       \n *     </div>\n *   )\n * }\n * \n * export default Order\n * ```\n * \n * To specify relations that should be retrieved:\n * \n * ```tsx\n * import React from \"react\"\n * import { useAdminOrder } from \"medusa-react\"\n * \n * const Order = (\n *   orderId: string\n * ) => {\n *   const { \n *     order, \n *     isLoading, \n *   } = useAdminOrder(orderId, {\n *     expand: \"customer\"\n *   })\n * \n *   return (\n *     <div>\n *       {isLoading && <span>Loading...</span>}\n *       {order && <span>{order.display_id}</span>}\n *       \n *     </div>\n *   )\n * }\n * \n * export default Order\n * ```\n * \n * @customNamespace Hooks.Admin.Orders\n * @category Queries\n */\nexport const useAdminOrder = (\n  /**\n   * The order's ID.\n   */\n  id: string,\n  /**\n   * Configurations to apply on the retrieved order.\n   */\n  query?: FindParams,\n  options?: UseQueryOptionsWrapper<\n    Response<AdminOrdersRes>,\n    Error,\n    ReturnType<OrderQueryKeys[\"detailOrder\"]>\n  >\n) => {\n  const { client } = useMedusa()\n  const { data, ...rest } = useQuery(\n    adminOrderKeys.detailOrder(id, query),\n    () => client.admin.orders.retrieve(id, query),\n    options\n  )\n  return { ...data, ...rest } as const\n}\n","import {\n  AdminCollectionsListRes,\n  AdminCollectionsRes,\n  AdminGetCollectionsParams,\n} from \"@medusajs/medusa\"\nimport { Response } from \"@medusajs/medusa-js\"\nimport { useQuery } from \"@tanstack/react-query\"\nimport { useMedusa } from \"../../../contexts\"\nimport { UseQueryOptionsWrapper } from \"../../../types\"\nimport { queryKeysFactory } from \"../../utils/index\"\n\nconst ADMIN_COLLECTIONS_QUERY_KEY = `admin_collections` as const\n\nexport const adminCollectionKeys = queryKeysFactory(ADMIN_COLLECTIONS_QUERY_KEY)\n\ntype CollectionsQueryKey = typeof adminCollectionKeys\n\n/**\n * This hook retrieves a list of product collections. The product collections can be filtered by fields such as `handle` or `title`.\n * The collections can also be sorted or paginated.\n * \n * @example\n * To list product collections:\n * \n * ```tsx\n * import React from \"react\"\n * import { useAdminCollections } from \"medusa-react\"\n * \n * const Collections = () => {\n *   const { collections, isLoading } = useAdminCollections()\n * \n *   return (\n *     <div>\n *       {isLoading && <span>Loading...</span>}\n *       {collections && !collections.length && <span>\n *         No Product Collections\n *       </span>}\n *       {collections && collections.length > 0 && (\n *         <ul>\n *           {collections.map((collection) => (\n *             <li key={collection.id}>{collection.title}</li>\n *           ))}\n *         </ul>\n *       )}\n *     </div>\n *   )\n * }\n * \n * export default Collections\n * ```\n * \n * By default, only the first `10` records are retrieved. You can control pagination by specifying the `limit` and `offset` properties:\n * \n * ```tsx\n * import React from \"react\"\n * import { useAdminCollections } from \"medusa-react\"\n * \n * const Collections = () => {\n *   const { collections, limit, offset, isLoading } = useAdminCollections({\n *     limit: 15,\n *     offset: 0\n *   })\n * \n *   return (\n *     <div>\n *       {isLoading && <span>Loading...</span>}\n *       {collections && !collections.length && <span>\n *         No Product Collections\n *       </span>}\n *       {collections && collections.length > 0 && (\n *         <ul>\n *           {collections.map((collection) => (\n *             <li key={collection.id}>{collection.title}</li>\n *           ))}\n *         </ul>\n *       )}\n *     </div>\n *   )\n * }\n * \n * export default Collections\n * ```\n * \n * @customNamespace Hooks.Admin.Product Collections\n * @category Queries\n */\nexport const useAdminCollections = (\n  /**\n   * Filters and pagination configurations to apply on the retrieved product collections.\n   */\n  query?: AdminGetCollectionsParams,\n  options?: UseQueryOptionsWrapper<\n    Response<AdminCollectionsListRes>,\n    Error,\n    ReturnType<CollectionsQueryKey[\"list\"]>\n  >\n) => {\n  const { client } = useMedusa()\n  const { data, ...rest } = useQuery(\n    adminCollectionKeys.list(query),\n    () => client.admin.collections.list(query),\n    options\n  )\n  return { ...data, ...rest } as const\n}\n\n/**\n * This hook retrieves a product collection by its ID. The products associated with it are expanded and returned as well.\n * \n * @example\n * import React from \"react\"\n * import { useAdminCollection } from \"medusa-react\"\n * \n * type Props = {\n *   collectionId: string\n * }\n * \n * const Collection = ({ collectionId }: Props) => {\n *   const { collection, isLoading } = useAdminCollection(collectionId)\n * \n *   return (\n *     <div>\n *       {isLoading && <span>Loading...</span>}\n *       {collection && <span>{collection.title}</span>}\n *     </div>\n *   )\n * }\n * \n * export default Collection\n * \n * @customNamespace Hooks.Admin.Product Collections\n * @category Queries\n */\nexport const useAdminCollection = (\n  /**\n   * The product collection's ID.\n   */\n  id: string,\n  options?: UseQueryOptionsWrapper<\n    Response<AdminCollectionsRes>,\n    Error,\n    ReturnType<CollectionsQueryKey[\"detail\"]>\n  >\n) => {\n  const { client } = useMedusa()\n  const { data, ...rest } = useQuery(\n    adminCollectionKeys.detail(id),\n    () => client.admin.collections.retrieve(id),\n    options\n  )\n  return { ...data, ...rest } as const\n}\n","import {\n  AdminCollectionsDeleteRes,\n  AdminCollectionsRes,\n  AdminDeleteProductsFromCollectionReq,\n  AdminDeleteProductsFromCollectionRes,\n  AdminPostCollectionsCollectionReq,\n  AdminPostCollectionsReq,\n  AdminPostProductsToCollectionReq,\n} from \"@medusajs/medusa\"\nimport { Response } from \"@medusajs/medusa-js\"\nimport {\n  UseMutationOptions,\n  useMutation,\n  useQueryClient,\n} from \"@tanstack/react-query\"\nimport { useMedusa } from \"../../../contexts/medusa\"\nimport { buildOptions } from \"../../utils/buildOptions\"\nimport { adminCollectionKeys } from \"./queries\"\n\n/**\n * This hook creates a product collection.\n * \n * @example\n * import React from \"react\"\n * import { useAdminCreateCollection } from \"medusa-react\"\n * \n * const CreateCollection = () => {\n *   const createCollection = useAdminCreateCollection()\n *   // ...\n * \n *   const handleCreate = (title: string) => {\n *     createCollection.mutate({\n *       title\n *     }, {\n *       onSuccess: ({ collection }) => {\n *         console.log(collection.id)\n *       }\n *     })\n *   }\n * \n *   // ...\n * }\n * \n * export default CreateCollection\n * \n * @customNamespace Hooks.Admin.Product Collections\n * @category Mutations\n */\nexport const useAdminCreateCollection = (\n  options?: UseMutationOptions<\n    Response<AdminCollectionsRes>, \n    Error,\n    AdminPostCollectionsReq\n  >\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n  return useMutation(\n    (payload: AdminPostCollectionsReq) =>\n      client.admin.collections.create(payload),\n    buildOptions(queryClient, adminCollectionKeys.lists(), options)\n  )\n}\n\n/**\n * This hook updates a product collection's details.\n * \n * @example\n * import React from \"react\"\n * import { useAdminUpdateCollection } from \"medusa-react\"\n * \n * type Props = {\n *   collectionId: string\n * }\n * \n * const Collection = ({ collectionId }: Props) => {\n *   const updateCollection = useAdminUpdateCollection(collectionId)\n *   // ...\n * \n *   const handleUpdate = (title: string) => {\n *     updateCollection.mutate({\n *       title\n *     }, {\n *       onSuccess: ({ collection }) => {\n *         console.log(collection.id)\n *       }\n *     })\n *   }\n * \n *   // ...\n * }\n * \n * export default Collection\n * \n * @customNamespace Hooks.Admin.Product Collections\n * @category Mutations\n */\nexport const useAdminUpdateCollection = (\n  /**\n   * The product collection's ID.\n   */\n  id: string,\n  options?: UseMutationOptions<\n    Response<AdminCollectionsRes>,\n    Error,\n    AdminPostCollectionsCollectionReq\n  >\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n  return useMutation(\n    (payload: AdminPostCollectionsCollectionReq) =>\n      client.admin.collections.update(id, payload),\n    buildOptions(\n      queryClient,\n      [adminCollectionKeys.lists(), adminCollectionKeys.detail(id)],\n      options\n    )\n  )\n}\n\n/**\n * This hook deletes a product collection. This does not delete associated products.\n * \n * @example\n * import React from \"react\"\n * import { useAdminDeleteCollection } from \"medusa-react\"\n * \n * type Props = {\n *   collectionId: string\n * }\n * \n * const Collection = ({ collectionId }: Props) => {\n *   const deleteCollection = useAdminDeleteCollection(collectionId)\n *   // ...\n * \n *   const handleDelete = (title: string) => {\n *     deleteCollection.mutate(void 0, {\n *       onSuccess: ({ id, object, deleted }) => {\n *         console.log(id)\n *       }\n *     })\n *   }\n * \n *   // ...\n * }\n * \n * export default Collection\n * \n * @customNamespace Hooks.Admin.Product Collections\n * @category Mutations\n */\nexport const useAdminDeleteCollection = (\n  /**\n   * The product collection's ID.\n   */\n  id: string,\n  options?: UseMutationOptions<Response<AdminCollectionsDeleteRes>, Error, void>\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n  return useMutation(\n    () => client.admin.collections.delete(id),\n    buildOptions(\n      queryClient,\n      [adminCollectionKeys.lists(), adminCollectionKeys.detail(id)],\n      options\n    )\n  )\n}\n\n/**\n * This hook adds products to a collection.\n * \n * @example\n * import React from \"react\"\n * import { useAdminAddProductsToCollection } from \"medusa-react\"\n * \n * type Props = {\n *   collectionId: string\n * }\n * \n * const Collection = ({ collectionId }: Props) => {\n *   const addProducts = useAdminAddProductsToCollection(collectionId)\n *   // ...\n * \n *   const handleAddProducts = (productIds: string[]) => {\n *     addProducts.mutate({\n *       product_ids: productIds\n *     }, {\n *       onSuccess: ({ collection }) => {\n *         console.log(collection.products)\n *       }\n *     })\n *   }\n * \n *   // ...\n * }\n * \n * export default Collection\n * \n * @customNamespace Hooks.Admin.Product Collections\n * @category Mutations\n */\nexport const useAdminAddProductsToCollection = (\n  /**\n   * The product collection's ID.\n   */\n  id: string,\n  options?: UseMutationOptions<\n    Response<AdminCollectionsRes>,\n    Error,\n    AdminPostProductsToCollectionReq\n  >\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n\n  return useMutation(\n    (payload: AdminPostProductsToCollectionReq) =>\n      client.admin.collections.addProducts(id, payload),\n    buildOptions(\n      queryClient,\n      [adminCollectionKeys.lists(), adminCollectionKeys.detail(id)],\n      options\n    )\n  )\n}\n\n/**\n * This hook removes a list of products from a collection. This would not delete the product, \n * only the association between the product and the collection.\n * \n * @example\n * import React from \"react\"\n * import { useAdminRemoveProductsFromCollection } from \"medusa-react\"\n * \n * type Props = {\n *   collectionId: string\n * }\n * \n * const Collection = ({ collectionId }: Props) => {\n *   const removeProducts = useAdminRemoveProductsFromCollection(collectionId)\n *   // ...\n * \n *   const handleRemoveProducts = (productIds: string[]) => {\n *     removeProducts.mutate({\n *       product_ids: productIds\n *     }, {\n *       onSuccess: ({ id, object, removed_products }) => {\n *         console.log(removed_products)\n *       }\n *     })\n *   }\n * \n *   // ...\n * }\n * \n * export default Collection\n * \n * @customNamespace Hooks.Admin.Product Collections\n * @category Mutations\n */\nexport const useAdminRemoveProductsFromCollection = (\n  /**\n   * The product collection's ID.\n   */\n  id: string,\n  options?: UseMutationOptions<\n    Response<AdminDeleteProductsFromCollectionRes>,\n    Error,\n    AdminDeleteProductsFromCollectionReq\n  >\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n\n  return useMutation(\n    (payload: AdminDeleteProductsFromCollectionReq) =>\n      client.admin.collections.removeProducts(id, payload),\n    buildOptions(\n      queryClient,\n      [adminCollectionKeys.lists(), adminCollectionKeys.detail(id)],\n      options\n    )\n  )\n}\n","import {\n  AdminCurrenciesRes,\n  AdminPostCurrenciesCurrencyReq,\n} from \"@medusajs/medusa\"\nimport { Response } from \"@medusajs/medusa-js\"\nimport {\n  useMutation,\n  UseMutationOptions,\n  useQueryClient,\n} from \"@tanstack/react-query\"\nimport { useMedusa } from \"../../../contexts/medusa\"\nimport { buildOptions } from \"../../utils/buildOptions\"\nimport { adminCurrenciesKeys } from \"./queries\"\n\n/**\n * This hook updates a currency's details.\n * \n * @example\n * import React from \"react\"\n * import { useAdminUpdateCurrency } from \"medusa-react\"\n * \n * type Props = {\n *   currencyCode: string\n * }\n * \n * const Currency = ({ currencyCode }: Props) => {\n *   const updateCurrency = useAdminUpdateCurrency(currencyCode)\n *   // ...\n * \n *   const handleUpdate = (includes_tax: boolean) => {\n *     updateCurrency.mutate({\n *       includes_tax,\n *     }, {\n *       onSuccess: ({ currency }) => {\n *         console.log(currency)\n *       }\n *     })\n *   }\n * \n *   // ...\n * }\n * \n * export default Currency\n * \n * @customNamespace Hooks.Admin.Currencies\n * @category Mutations\n */\nexport const useAdminUpdateCurrency = (\n  /**\n   * The currency's code.\n   */\n  code: string,\n  options?: UseMutationOptions<\n    Response<AdminCurrenciesRes>,\n    Error,\n    AdminPostCurrenciesCurrencyReq\n  >\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n  return useMutation(\n    (payload: AdminPostCurrenciesCurrencyReq) =>\n      client.admin.currencies.update(code, payload),\n    buildOptions(\n      queryClient,\n      [adminCurrenciesKeys.lists(), adminCurrenciesKeys.detail(code)],\n      options\n    )\n  )\n}\n","import {\n  AdminCurrenciesListRes,\n  AdminGetCurrenciesParams,\n} from \"@medusajs/medusa\"\nimport { Response } from \"@medusajs/medusa-js\"\nimport { useQuery } from \"@tanstack/react-query\"\nimport { useMedusa } from \"../../../contexts\"\nimport { UseQueryOptionsWrapper } from \"../../../types\"\nimport { queryKeysFactory } from \"../../utils/index\"\n\nconst ADMIN_CURRENCIES_QUERY_KEY = `admin_currencies` as const\n\nexport const adminCurrenciesKeys = queryKeysFactory(ADMIN_CURRENCIES_QUERY_KEY)\n\ntype CurrenciesQueryKey = typeof adminCurrenciesKeys\n\n/**\n * This hook retrieves a list of currencies. The currencies can be filtered by fields such as `code`. \n * The currencies can also be sorted or paginated.\n * \n * @example\n * To list currencies:\n * \n * ```ts\n * import React from \"react\"\n * import { useAdminCurrencies } from \"medusa-react\"\n * \n * const Currencies = () => {\n *   const { currencies, isLoading } = useAdminCurrencies()\n * \n *   return (\n *     <div>\n *       {isLoading && <span>Loading...</span>}\n *       {currencies && !currencies.length && (\n *         <span>No Currencies</span>\n *       )}\n *       {currencies && currencies.length > 0 && (\n *         <ul>\n *           {currencies.map((currency) => (\n *             <li key={currency.code}>{currency.name}</li>\n *           ))}\n *         </ul>\n *       )}\n *     </div>\n *   )\n * }\n * \n * export default Currencies\n * ```\n * \n * By default, only the first `20` records are retrieved. You can control pagination by specifying the `limit` and `offset` properties:\n * \n * ```ts\n * import React from \"react\"\n * import { useAdminCurrencies } from \"medusa-react\"\n * \n * const Currencies = () => {\n *   const { currencies, limit, offset, isLoading } = useAdminCurrencies({\n *     limit: 10,\n *     offset: 0\n *   })\n * \n *   return (\n *     <div>\n *       {isLoading && <span>Loading...</span>}\n *       {currencies && !currencies.length && (\n *         <span>No Currencies</span>\n *       )}\n *       {currencies && currencies.length > 0 && (\n *         <ul>\n *           {currencies.map((currency) => (\n *             <li key={currency.code}>{currency.name}</li>\n *           ))}\n *         </ul>\n *       )}\n *     </div>\n *   )\n * }\n * \n * export default Currencies\n * ```\n * \n * @customNamespace Hooks.Admin.Currencies\n * @category Queries\n */\nexport const useAdminCurrencies = (\n  /**\n   * Filters and pagination configurations to apply on retrieved currencies.\n   */\n  query?: AdminGetCurrenciesParams,\n  options?: UseQueryOptionsWrapper<\n    Response<AdminCurrenciesListRes>,\n    Error,\n    ReturnType<CurrenciesQueryKey[\"list\"]>\n  >\n) => {\n  const { client } = useMedusa()\n  const { data, ...rest } = useQuery(\n    adminCurrenciesKeys.list(query),\n    () => client.admin.currencies.list(query),\n    options\n  )\n  return { ...data, ...rest } as const\n}\n","import { Response } from \"@medusajs/medusa-js\"\nimport {\n  QueryClient,\n  QueryKey,\n  useMutation,\n  UseMutationOptions,\n  useQueryClient,\n} from \"@tanstack/react-query\"\nimport { useMedusa } from \"../../../contexts\"\nimport { adminCustomerGroupKeys } from \"../customer-groups\"\nimport { adminCustomerKeys } from \"../customers\"\nimport { adminDiscountKeys } from \"../discounts\"\nimport { adminGiftCardKeys } from \"../gift-cards\"\nimport { adminOrderKeys } from \"../orders\"\nimport { adminPriceListKeys } from \"../price-lists\"\nimport { adminProductKeys } from \"../products\"\n\ntype RelatedDomain =\n  | \"product\"\n  | \"customer\"\n  | \"customer_group\"\n  | \"order\"\n  | \"discount\"\n  | \"gift_card\"\n  | \"price_list\"\n\nexport type RelatedDomains = {\n  [key in RelatedDomain]?: boolean\n}\n\nconst invalidateRelatedDomain = (\n  queryClient: QueryClient,\n  domain: RelatedDomain\n) => {\n  switch (domain) {\n    case \"product\":\n      queryClient.invalidateQueries(adminProductKeys.all)\n      break\n    case \"customer\":\n      queryClient.invalidateQueries(adminCustomerKeys.all)\n      break\n    case \"customer_group\":\n      queryClient.invalidateQueries(adminCustomerGroupKeys.all)\n      break\n    case \"order\":\n      queryClient.invalidateQueries(adminOrderKeys.all)\n      break\n    case \"discount\":\n      queryClient.invalidateQueries(adminDiscountKeys.all)\n      break\n    case \"gift_card\":\n      queryClient.invalidateQueries(adminGiftCardKeys.all)\n      break\n    case \"price_list\":\n      queryClient.invalidateQueries(adminPriceListKeys.all)\n      break\n  }\n}\n\nexport const buildCustomOptions = <\n  TData,\n  TError,\n  TVariables,\n  TContext,\n  TKey extends QueryKey\n>(\n  queryClient: QueryClient,\n  queryKey?: TKey,\n  options?: UseMutationOptions<TData, TError, TVariables, TContext>,\n  relatedDomains?: RelatedDomains\n): UseMutationOptions<TData, TError, TVariables, TContext> => {\n  return {\n    ...options,\n    onSuccess: (...args) => {\n      if (queryKey !== undefined) {\n        queryKey.forEach((key) => {\n          queryClient.invalidateQueries({ queryKey: key as QueryKey })\n        })\n      }\n\n      if (relatedDomains) {\n        Object.keys(relatedDomains).forEach((key) => {\n          if (relatedDomains[key as RelatedDomain]) {\n            invalidateRelatedDomain(queryClient, key as RelatedDomain)\n          }\n        })\n      }\n\n      return options?.onSuccess?.(...args)\n    },\n  }\n}\n\n/**\n * This hook sends a `POST` request to a custom API Route.\n * \n * @typeParam TPayload - The type of accepted body parameters which defaults to `Record<string, any>`.\n * @typeParam TResponse - The type of response, which defaults to `any`.\n * @typeParamDefinition TResponse - The response based on the specified type for `TResponse`.\n * @typeParamDefinition TPayload - The payload based on the specified type for `TPayload`.\n * \n * @example\n * import React from \"react\"\n * import { useAdminCustomPost } from \"medusa-react\"\n * import Post from \"./models/Post\"\n * \n * type PostRequest = {\n *   title: string\n * }\n * type PostResponse = {\n *   post: Post\n * }\n * \n * const Custom = () => {\n *   const customPost = useAdminCustomPost\n *   <PostRequest, PostResponse>(\n *     \"/blog/posts\",\n *     [\"posts\"]\n *   )\n * \n *   // ...\n * \n *   const handleAction = (title: string) => {\n *     customPost.mutate({\n *       title\n *     }, {\n *       onSuccess: ({ post }) => {\n *         console.log(post)\n *       }\n *     })\n *   }\n * \n *   // ...\n * }\n * \n * export default Custom\n * \n * @customNamespace Hooks.Admin.Custom\n * @category Mutations\n */\nexport const useAdminCustomPost = <\n  TPayload extends Record<string, any>,\n  TResponse\n>(\n  /**\n   * The path to the custom endpoint.\n   */\n  path: string,\n  /**\n   * A list of query keys, used to invalidate data.\n   */\n  queryKey: QueryKey,\n  /**\n   * A list of related domains that should be invalidated and refetch when the mutation\n   * function is invoked.\n   */\n  relatedDomains?: RelatedDomains,\n  options?: UseMutationOptions<Response<TResponse>, Error, TPayload>\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n\n  return useMutation(\n    (payload: TPayload) =>\n      client.admin.custom.post<TPayload, TResponse>(path, payload),\n    buildCustomOptions(queryClient, queryKey, options, relatedDomains)\n  )\n}\n\n/**\n * This hook sends a `DELETE` request to a custom API Route.\n * \n * @typeParam TResponse - The response's type which defaults to `any`.\n * @typeParamDefinition TResponse - The response based on the type provided for `TResponse`.\n * \n * @example\n * import React from \"react\"\n * import { useAdminCustomDelete } from \"medusa-react\"\n * \n * type Props = {\n *   customId: string\n * }\n * \n * const Custom = ({ customId }: Props) => {\n *   const customDelete = useAdminCustomDelete(\n *     `/blog/posts/${customId}`,\n *     [\"posts\"]\n *   )\n * \n *   // ...\n * \n *   const handleAction = (title: string) => {\n *     customDelete.mutate(void 0, {\n *       onSuccess: () => {\n *         // Delete action successful\n *       }\n *     })\n *   }\n * \n *   // ...\n * }\n * \n * export default Custom\n * \n * @customNamespace Hooks.Admin.Custom\n * @category Mutations\n */\nexport const useAdminCustomDelete = <TResponse>(\n  /**\n   * The path to the custom endpoint.\n   */\n  path: string,\n  /**\n   * A list of query keys, used to invalidate data.\n   */\n  queryKey: QueryKey,\n  /**\n   * A list of related domains that should be invalidated and refetch when the mutation\n   * function is invoked.\n   */\n  relatedDomains?: RelatedDomains,\n  options?: UseMutationOptions<Response<TResponse>, Error, void>\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n\n  return useMutation(\n    () => client.admin.custom.delete<TResponse>(path),\n    buildCustomOptions(queryClient, queryKey, options, relatedDomains)\n  )\n}\n","import {\n  AdminCustomerGroupsListRes,\n  AdminCustomerGroupsRes,\n  AdminCustomersListRes,\n  AdminGetCustomerGroupsGroupParams,\n  AdminGetCustomerGroupsParams,\n  AdminGetCustomersParams,\n} from \"@medusajs/medusa\"\nimport { Response } from \"@medusajs/medusa-js\"\nimport { useQuery } from \"@tanstack/react-query\"\n\nimport { useMedusa } from \"../../../contexts\"\nimport { UseQueryOptionsWrapper } from \"../../../types\"\nimport { queryKeysFactory } from \"../../utils\"\n\nconst ADMIN_CUSTOMER_GROUPS_QUERY_KEY = `admin_customer_groups` as const\n\n/**\n * @ignore\n */\nexport const adminCustomerGroupKeys = {\n  ...queryKeysFactory(ADMIN_CUSTOMER_GROUPS_QUERY_KEY),\n  detailCustomer(id: string, query?: AdminGetCustomersParams) {\n    return [...this.detail(id), \"customers\", { ...(query || {}) }]\n  },\n}\n\ntype CustomerGroupQueryKeys = typeof adminCustomerGroupKeys\n\n/**\n * This hook retrieves a customer group by its ID. You can expand the customer group's relations or \n * select the fields that should be returned.\n * \n * @example\n * import React from \"react\"\n * import { useAdminCustomerGroup } from \"medusa-react\"\n * \n * type Props = {\n *   customerGroupId: string\n * }\n * \n * const CustomerGroup = ({ customerGroupId }: Props) => {\n *   const { customer_group, isLoading } = useAdminCustomerGroup(\n *     customerGroupId\n *   )\n * \n *   return (\n *     <div>\n *       {isLoading && <span>Loading...</span>}\n *       {customer_group && <span>{customer_group.name}</span>}\n *     </div>\n *   )\n * }\n * \n * export default CustomerGroup\n * \n * @customNamespace Hooks.Admin.Customer Groups\n * @category Queries\n */\nexport const useAdminCustomerGroup = (\n  /**\n   * The customer group's ID.\n   */\n  id: string,\n  /**\n   * Configurations to apply on the retrieved customer group.\n   */\n  query?: AdminGetCustomerGroupsGroupParams,\n  options?: UseQueryOptionsWrapper<\n    Response<AdminCustomerGroupsRes>,\n    Error,\n    ReturnType<CustomerGroupQueryKeys[\"detail\"]>\n  >\n) => {\n  const { client } = useMedusa()\n  const { data, ...rest } = useQuery(\n    adminCustomerGroupKeys.detail(id),\n    () => client.admin.customerGroups.retrieve(id, query),\n    options\n  )\n  return { ...data, ...rest } as const\n}\n\n/**\n * This hook retrieves a list of customer groups. The customer groups can be filtered by fields such as `name` or `id`. \n * The customer groups can also be sorted or paginated.\n * \n * @example\n * To list customer groups:\n * \n * ```tsx\n * import React from \"react\"\n * import { useAdminCustomerGroups } from \"medusa-react\"\n * \n * const CustomerGroups = () => {\n *   const { \n *     customer_groups,\n *     isLoading,\n *   } = useAdminCustomerGroups()\n * \n *   return (\n *     <div>\n *       {isLoading && <span>Loading...</span>}\n *       {customer_groups && !customer_groups.length && (\n *         <span>No Customer Groups</span>\n *       )}\n *       {customer_groups && customer_groups.length > 0 && (\n *         <ul>\n *           {customer_groups.map(\n *             (customerGroup) => (\n *               <li key={customerGroup.id}>\n *                 {customerGroup.name}\n *               </li>\n *             )\n *           )}\n *         </ul>\n *       )}\n *     </div>\n *   )\n * }\n * \n * export default CustomerGroups\n * ```\n * \n * To specify relations that should be retrieved within the customer groups:\n * \n * ```tsx\n * import React from \"react\"\n * import { useAdminCustomerGroups } from \"medusa-react\"\n * \n * const CustomerGroups = () => {\n *   const { \n *     customer_groups,\n *     isLoading,\n *   } = useAdminCustomerGroups({\n *     expand: \"customers\"\n *   })\n * \n *   return (\n *     <div>\n *       {isLoading && <span>Loading...</span>}\n *       {customer_groups && !customer_groups.length && (\n *         <span>No Customer Groups</span>\n *       )}\n *       {customer_groups && customer_groups.length > 0 && (\n *         <ul>\n *           {customer_groups.map(\n *             (customerGroup) => (\n *               <li key={customerGroup.id}>\n *                 {customerGroup.name}\n *               </li>\n *             )\n *           )}\n *         </ul>\n *       )}\n *     </div>\n *   )\n * }\n * \n * export default CustomerGroups\n * ```\n * \n * By default, only the first `10` records are retrieved. You can control pagination by specifying the `limit` and `offset` properties:\n * \n * ```tsx\n * import React from \"react\"\n * import { useAdminCustomerGroups } from \"medusa-react\"\n * \n * const CustomerGroups = () => {\n *   const { \n *     customer_groups,\n *     limit,\n *     offset,\n *     isLoading,\n *   } = useAdminCustomerGroups({\n *     expand: \"customers\",\n *     limit: 15,\n *     offset: 0\n *   })\n * \n *   return (\n *     <div>\n *       {isLoading && <span>Loading...</span>}\n *       {customer_groups && !customer_groups.length && (\n *         <span>No Customer Groups</span>\n *       )}\n *       {customer_groups && customer_groups.length > 0 && (\n *         <ul>\n *           {customer_groups.map(\n *             (customerGroup) => (\n *               <li key={customerGroup.id}>\n *                 {customerGroup.name}\n *               </li>\n *             )\n *           )}\n *         </ul>\n *       )}\n *     </div>\n *   )\n * }\n * \n * export default CustomerGroups\n * ```\n * \n * @customNamespace Hooks.Admin.Customer Groups\n * @category Queries\n */\nexport const useAdminCustomerGroups = (\n  /**\n   * Filters and pagination configurations to apply on the retrieved customer groups.\n   */\n  query?: AdminGetCustomerGroupsParams,\n  options?: UseQueryOptionsWrapper<\n    Response<AdminCustomerGroupsListRes>,\n    Error,\n    ReturnType<CustomerGroupQueryKeys[\"list\"]>\n  >\n) => {\n  const { client } = useMedusa()\n  const { data, ...rest } = useQuery(\n    adminCustomerGroupKeys.list(query),\n    () => client.admin.customerGroups.list(query),\n    options\n  )\n  return { ...data, ...rest } as const\n}\n\n/**\n * This hook retrieves a list of customers in a customer group. The customers can be filtered \n * by the `query` field. The customers can also be paginated.\n * \n * @example\n * import React from \"react\"\n * import { useAdminCustomerGroupCustomers } from \"medusa-react\"\n * \n * type Props = {\n *   customerGroupId: string\n * }\n * \n * const CustomerGroup = ({ customerGroupId }: Props) => {\n *   const { \n *     customers, \n *     isLoading,\n *   } = useAdminCustomerGroupCustomers(\n *     customerGroupId\n *   )\n * \n *   return (\n *     <div>\n *       {isLoading && <span>Loading...</span>}\n *       {customers && !customers.length && (\n *         <span>No customers</span>\n *       )}\n *       {customers && customers.length > 0 && (\n *         <ul>\n *           {customers.map((customer) => (\n *             <li key={customer.id}>{customer.first_name}</li>\n *           ))}\n *         </ul>\n *       )}\n *     </div>\n *   )\n * }\n * \n * export default CustomerGroup\n * \n * @customNamespace Hooks.Admin.Customer Groups\n * @category Queries\n */\nexport const useAdminCustomerGroupCustomers = (\n  /**\n   * The customer group's ID.\n   */\n  id: string,\n  /**\n   * Filters and pagination configurations to apply on the retrieved customers.\n   */\n  query?: AdminGetCustomersParams,\n  options?: UseQueryOptionsWrapper<\n    Response<AdminCustomersListRes>,\n    Error,\n    ReturnType<CustomerGroupQueryKeys[\"detailCustomer\"]>\n  >\n) => {\n  const { client } = useMedusa()\n  const { data, ...rest } = useQuery(\n    adminCustomerGroupKeys.detailCustomer(id, query),\n    () => client.admin.customerGroups.listCustomers(id, query),\n    options\n  )\n  return { ...data, ...rest } as const\n}\n","import {\n  AdminCustomerGroupsDeleteRes,\n  AdminCustomerGroupsRes,\n  AdminDeleteCustomerGroupsGroupCustomerBatchReq,\n  AdminPostCustomerGroupsGroupCustomersBatchReq,\n  AdminPostCustomerGroupsGroupReq,\n  AdminPostCustomerGroupsReq,\n} from \"@medusajs/medusa\"\nimport { Response } from \"@medusajs/medusa-js\"\nimport {\n  useMutation,\n  UseMutationOptions,\n  useQueryClient,\n} from \"@tanstack/react-query\"\n\nimport { useMedusa } from \"../../../contexts\"\nimport { buildOptions } from \"../../utils/buildOptions\"\nimport { adminCustomerGroupKeys } from \"./queries\"\n\n/**\n * This hook creates a customer group.\n * \n * @example\n * import React from \"react\"\n * import { useAdminCreateCustomerGroup } from \"medusa-react\"\n * \n * const CreateCustomerGroup = () => {\n *   const createCustomerGroup = useAdminCreateCustomerGroup()\n *   // ...\n * \n *   const handleCreate = (name: string) => {\n *     createCustomerGroup.mutate({\n *       name,\n *     })\n *   }\n * \n *   // ...\n * }\n * \n * export default CreateCustomerGroup\n * \n * @customNamespace Hooks.Admin.Customer Groups\n * @category Mutations\n */\nexport const useAdminCreateCustomerGroup = (\n  options?: UseMutationOptions<\n    Response<AdminCustomerGroupsRes>,\n    Error,\n    AdminPostCustomerGroupsReq\n  >\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n\n  return useMutation(\n    (payload: AdminPostCustomerGroupsReq) =>\n      client.admin.customerGroups.create(payload),\n    buildOptions(queryClient, adminCustomerGroupKeys.lists(), options)\n  )\n}\n\n/**\n * This hook updates a customer group's details.\n * \n * @example\n * import React from \"react\"\n * import { useAdminUpdateCustomerGroup } from \"medusa-react\"\n * \n * type Props = {\n *   customerGroupId: string\n * }\n * \n * const CustomerGroup = ({ customerGroupId }: Props) => {\n *   const updateCustomerGroup = useAdminUpdateCustomerGroup(\n *     customerGroupId\n *   )\n *   // ..\n * \n *   const handleUpdate = (name: string) => {\n *     updateCustomerGroup.mutate({\n *       name,\n *     })\n *   }\n * \n *   // ...\n * }\n * \n * export default CustomerGroup\n * \n * @customNamespace Hooks.Admin.Customer Groups\n * @category Mutations\n */\nexport const useAdminUpdateCustomerGroup = (\n  /**\n   * The customer group's ID.\n   */\n  id: string,\n  options?: UseMutationOptions<\n    Response<AdminCustomerGroupsRes>,\n    Error,\n    AdminPostCustomerGroupsGroupReq\n  >\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n\n  return useMutation(\n    (payload: AdminPostCustomerGroupsGroupReq) =>\n      client.admin.customerGroups.update(id, payload),\n    buildOptions(\n      queryClient,\n      [adminCustomerGroupKeys.lists(), adminCustomerGroupKeys.detail(id)],\n      options\n    )\n  )\n}\n\n/**\n * This hook deletes a customer group. This doesn't delete the customers associated with the customer group.\n *\n * @example\n * import React from \"react\"\n * import { useAdminDeleteCustomerGroup } from \"medusa-react\"\n * \n * type Props = {\n *   customerGroupId: string\n * }\n * \n * const CustomerGroup = ({ customerGroupId }: Props) => {\n *   const deleteCustomerGroup = useAdminDeleteCustomerGroup(\n *     customerGroupId\n *   )\n *   // ...\n * \n *   const handleDeleteCustomerGroup = () => {\n *     deleteCustomerGroup.mutate()\n *   }\n * \n *   // ...\n * }\n * \n * export default CustomerGroup\n * \n * @customNamespace Hooks.Admin.Customer Groups\n * @category Mutations\n */\nexport const useAdminDeleteCustomerGroup = (\n  /**\n   * The customer group's ID.\n   */\n  id: string,\n  options?: UseMutationOptions<\n    Response<AdminCustomerGroupsDeleteRes>,\n    Error,\n    void\n  >\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n\n  return useMutation(\n    () => client.admin.customerGroups.delete(id),\n    buildOptions(\n      queryClient,\n      [adminCustomerGroupKeys.lists(), adminCustomerGroupKeys.detail(id)],\n      options\n    )\n  )\n}\n\n/**\n * The hook adds a list of customers to a customer group.\n *\n * @example\n * import React from \"react\"\n * import { \n *   useAdminAddCustomersToCustomerGroup,\n * } from \"medusa-react\"\n * \n * type Props = {\n *   customerGroupId: string\n * }\n * \n * const CustomerGroup = ({ customerGroupId }: Props) => {\n *   const addCustomers = useAdminAddCustomersToCustomerGroup(\n *     customerGroupId\n *   )\n *   // ...\n * \n *   const handleAddCustomers= (customerId: string) => {\n *     addCustomers.mutate({\n *       customer_ids: [\n *         {\n *           id: customerId,\n *         },\n *       ],\n *     })\n *   }\n * \n *   // ...\n * }\n * \n * export default CustomerGroup\n * \n * @customNamespace Hooks.Admin.Customer Groups\n * @category Mutations\n */\nexport const useAdminAddCustomersToCustomerGroup = (\n  /**\n   * The customer group's ID.\n   */\n  id: string,\n  options?: UseMutationOptions<\n    Response<AdminCustomerGroupsRes>,\n    Error,\n    AdminPostCustomerGroupsGroupCustomersBatchReq\n  >\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n\n  return useMutation(\n    (payload: AdminPostCustomerGroupsGroupCustomersBatchReq) =>\n      client.admin.customerGroups.addCustomers(id, payload),\n    buildOptions(\n      queryClient,\n      [\n        adminCustomerGroupKeys.lists(),\n        adminCustomerGroupKeys.detailCustomer(id),\n      ],\n      options\n    )\n  )\n}\n\n/**\n * This hook removes a list of customers from a customer group. This doesn't delete the customer, \n * only the association between the customer and the customer group.\n * \n * @example\n * import React from \"react\"\n * import { \n *   useAdminRemoveCustomersFromCustomerGroup,\n * } from \"medusa-react\"\n * \n * type Props = {\n *   customerGroupId: string\n * }\n * \n * const CustomerGroup = ({ customerGroupId }: Props) => {\n *   const removeCustomers = \n *     useAdminRemoveCustomersFromCustomerGroup(\n *       customerGroupId\n *     )\n *   // ...\n * \n *   const handleRemoveCustomer = (customerId: string) => {\n *     removeCustomers.mutate({\n *       customer_ids: [\n *         {\n *           id: customerId,\n *         },\n *       ],\n *     })\n *   }\n * \n *   // ...\n * }\n * \n * export default CustomerGroup\n * \n * @customNamespace Hooks.Admin.Customer Groups\n * @category Mutations\n */\nexport const useAdminRemoveCustomersFromCustomerGroup = (\n  /**\n   * The customer group's ID.\n   */\n  id: string,\n  options?: UseMutationOptions<\n    Response<AdminCustomerGroupsRes>,\n    Error,\n    AdminDeleteCustomerGroupsGroupCustomerBatchReq\n  >\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n\n  return useMutation(\n    (payload: AdminDeleteCustomerGroupsGroupCustomerBatchReq) =>\n      client.admin.customerGroups.removeCustomers(id, payload),\n    buildOptions(\n      queryClient,\n      [\n        adminCustomerGroupKeys.lists(),\n        adminCustomerGroupKeys.detailCustomer(id),\n      ],\n      options\n    )\n  )\n}\n","import {\n  AdminCustomersListRes,\n  AdminCustomersRes,\n  AdminGetCustomersParams,\n} from \"@medusajs/medusa\"\nimport { Response } from \"@medusajs/medusa-js\"\nimport { useQuery } from \"@tanstack/react-query\"\nimport { useMedusa } from \"../../../contexts\"\nimport { UseQueryOptionsWrapper } from \"../../../types\"\nimport { queryKeysFactory } from \"../../utils\"\n\nconst ADMIN_CUSTOMERS_QUERY_KEY = `admin_customers` as const\n\nexport const adminCustomerKeys = queryKeysFactory(ADMIN_CUSTOMERS_QUERY_KEY)\n\ntype CustomerQueryKeys = typeof adminCustomerKeys\n\n/**\n * This hook retrieves a list of Customers. The customers can be filtered by fields such as \n * `q` or `groups`. The customers can also be paginated.\n * \n * @example\n * To list customers:\n * \n * ```tsx\n * import React from \"react\"\n * import { useAdminCustomers } from \"medusa-react\"\n * \n * const Customers = () => {\n *   const { customers, isLoading } = useAdminCustomers()\n * \n *   return (\n *     <div>\n *       {isLoading && <span>Loading...</span>}\n *       {customers && !customers.length && (\n *         <span>No customers</span>\n *       )}\n *       {customers && customers.length > 0 && (\n *         <ul>\n *           {customers.map((customer) => (\n *             <li key={customer.id}>{customer.first_name}</li>\n *           ))}\n *         </ul>\n *       )}\n *     </div>\n *   )\n * }\n * \n * export default Customers\n * ```\n * \n * You can specify relations to be retrieved within each customer. In addition, by default, only the first `50` records are retrieved. \n * You can control pagination by specifying the `limit` and `offset` properties:\n * \n * ```tsx\n * import React from \"react\"\n * import { useAdminCustomers } from \"medusa-react\"\n * \n * const Customers = () => {\n *   const { \n *     customers, \n *     limit,\n *     offset,\n *     isLoading\n *   } = useAdminCustomers({\n *     expand: \"billing_address\",\n *     limit: 20,\n *     offset: 0\n *   })\n * \n *   return (\n *     <div>\n *       {isLoading && <span>Loading...</span>}\n *       {customers && !customers.length && (\n *         <span>No customers</span>\n *       )}\n *       {customers && customers.length > 0 && (\n *         <ul>\n *           {customers.map((customer) => (\n *             <li key={customer.id}>{customer.first_name}</li>\n *           ))}\n *         </ul>\n *       )}\n *     </div>\n *   )\n * }\n * \n * export default Customers\n * ```\n * \n * @customNamespace Hooks.Admin.Customers\n * @category Queries\n */\nexport const useAdminCustomers = (\n  /**\n   * Filters and pagination configurations to apply on the retrieved customers.\n   */\n  query?: AdminGetCustomersParams,\n  options?: UseQueryOptionsWrapper<\n    Response<AdminCustomersListRes>,\n    Error,\n    ReturnType<CustomerQueryKeys[\"list\"]>\n  >\n) => {\n  const { client } = useMedusa()\n  const { data, ...rest } = useQuery(\n    adminCustomerKeys.list(query),\n    () => client.admin.customers.list(query),\n    options\n  )\n  return { ...data, ...rest } as const\n}\n\n/**\n * This hook retrieves the details of a customer.\n * \n * @example\n * import React from \"react\"\n * import { useAdminCustomer } from \"medusa-react\"\n * \n * type Props = {\n *   customerId: string\n * }\n * \n * const Customer = ({ customerId }: Props) => {\n *   const { customer, isLoading } = useAdminCustomer(\n *     customerId\n *   )\n * \n *   return (\n *     <div>\n *       {isLoading && <span>Loading...</span>}\n *       {customer && <span>{customer.first_name}</span>}\n *     </div>\n *   )\n * }\n * \n * export default Customer\n * \n * @customNamespace Hooks.Admin.Customers\n * @category Queries\n */\nexport const useAdminCustomer = (\n  /**\n   * The customer's ID.\n   */\n  id: string,\n  options?: UseQueryOptionsWrapper<\n    Response<AdminCustomersRes>,\n    Error,\n    ReturnType<CustomerQueryKeys[\"detail\"]>\n  >\n) => {\n  const { client } = useMedusa()\n  const { data, ...rest } = useQuery(\n    adminCustomerKeys.detail(id),\n    () => client.admin.customers.retrieve(id),\n    options\n  )\n  return { ...data, ...rest } as const\n}\n","import {\n  useMutation,\n  UseMutationOptions,\n  useQueryClient,\n} from \"@tanstack/react-query\"\n\nimport {\n  AdminCustomersRes,\n  AdminPostCustomersCustomerReq,\n  AdminPostCustomersReq,\n} from \"@medusajs/medusa\"\nimport { Response } from \"@medusajs/medusa-js\"\n\nimport { useMedusa } from \"../../../contexts\"\nimport { buildOptions } from \"../../utils/buildOptions\"\nimport { adminCustomerKeys } from \"./queries\"\n\n/**\n * This hook creates a customer as an admin.\n * \n * @example\n * import React from \"react\"\n * import { useAdminCreateCustomer } from \"medusa-react\"\n * \n * type CustomerData = {\n *   first_name: string\n *   last_name: string\n *   email: string\n *   password: string\n * }\n * \n * const CreateCustomer = () => {\n *   const createCustomer = useAdminCreateCustomer()\n *   // ...\n * \n *   const handleCreate = (customerData: CustomerData) => {\n *     createCustomer.mutate(customerData, {\n *       onSuccess: ({ customer }) => {\n *         console.log(customer.id)\n *       }\n *     })\n *   }\n * \n *   // ...\n * }\n * \n * export default CreateCustomer\n * \n * @customNamespace Hooks.Admin.Customers\n * @category Mutations\n */\nexport const useAdminCreateCustomer = (\n  options?: UseMutationOptions<\n    Response<AdminCustomersRes>,\n    Error,\n    AdminPostCustomersReq\n  >\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n\n  return useMutation(\n    (payload: AdminPostCustomersReq) => client.admin.customers.create(payload),\n    buildOptions(queryClient, adminCustomerKeys.lists(), options)\n  )\n}\n\n/**\n * This hook updates a customer's details.\n * \n * @example\n * import React from \"react\"\n * import { useAdminUpdateCustomer } from \"medusa-react\"\n * \n * type CustomerData = {\n *   first_name: string\n *   last_name: string\n *   email: string\n *   password: string\n * }\n * \n * type Props = {\n *   customerId: string\n * }\n * \n * const Customer = ({ customerId }: Props) => {\n *   const updateCustomer = useAdminUpdateCustomer(customerId)\n *   // ...\n * \n *   const handleUpdate = (customerData: CustomerData) => {\n *     updateCustomer.mutate(customerData)\n *   }\n * \n *   // ...\n * }\n * \n * export default Customer\n * \n * @customNamespace Hooks.Admin.Customers\n * @category Mutations\n */\nexport const useAdminUpdateCustomer = (\n  /**\n   * The customer's ID.\n   */\n  id: string,\n  options?: UseMutationOptions<\n    Response<AdminCustomersRes>,\n    Error,\n    AdminPostCustomersCustomerReq\n  >\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n  return useMutation(\n    (payload: AdminPostCustomersCustomerReq) =>\n      client.admin.customers.update(id, payload),\n    buildOptions(\n      queryClient,\n      [adminCustomerKeys.lists(), adminCustomerKeys.detail(id)],\n      options\n    )\n  )\n}\n","import {\n  AdminDiscountConditionsRes,\n  AdminDiscountsListRes,\n  AdminDiscountsRes,\n  AdminGetDiscountParams,\n  AdminGetDiscountsDiscountConditionsConditionParams,\n  AdminGetDiscountsParams,\n} from \"@medusajs/medusa\"\nimport { Response } from \"@medusajs/medusa-js\"\nimport { useQuery } from \"@tanstack/react-query\"\nimport { useMedusa } from \"../../../contexts\"\nimport { UseQueryOptionsWrapper } from \"../../../types\"\nimport { queryKeysFactory } from \"../../utils\"\n\nconst ADMIN_DISCOUNTS_QUERY_KEY = `admin_discounts` as const\n\nexport const adminDiscountKeys = {\n  ...queryKeysFactory(ADMIN_DISCOUNTS_QUERY_KEY),\n  detailCondition(id: string, query?: any) {\n    return [\n      ...this.detail(id),\n      \"condition\" as const,\n      { ...(query || {}) },\n    ] as const\n  },\n}\n\ntype DiscountQueryKeys = typeof adminDiscountKeys\n\n/**\n * This hook retrieves a list of Discounts. The discounts can be filtered by fields such as `rule` or `is_dynamic`.\n * The discounts can also be paginated.\n *\n * @example\n * To list discounts:\n *\n * ```tsx\n * import React from \"react\"\n * import { useAdminDiscounts } from \"medusa-react\"\n *\n * const Discounts = () => {\n *   const { discounts, isLoading } = useAdminDiscounts()\n *\n *   return (\n *     <div>\n *       {isLoading && <span>Loading...</span>}\n *       {discounts && !discounts.length && (\n *         <span>No customers</span>\n *       )}\n *       {discounts && discounts.length > 0 && (\n *         <ul>\n *           {discounts.map((discount) => (\n *             <li key={discount.id}>{discount.code}</li>\n *           ))}\n *         </ul>\n *       )}\n *     </div>\n *   )\n * }\n *\n * export default Discounts\n * ```\n *\n * To specify relations that should be retrieved within the discounts:\n *\n * ```tsx\n * import React from \"react\"\n * import { useAdminDiscounts } from \"medusa-react\"\n *\n * const Discounts = () => {\n *   const { discounts, isLoading } = useAdminDiscounts({\n *     expand: \"rule\"\n *   })\n *\n *   return (\n *     <div>\n *       {isLoading && <span>Loading...</span>}\n *       {discounts && !discounts.length && (\n *         <span>No customers</span>\n *       )}\n *       {discounts && discounts.length > 0 && (\n *         <ul>\n *           {discounts.map((discount) => (\n *             <li key={discount.id}>{discount.code}</li>\n *           ))}\n *         </ul>\n *       )}\n *     </div>\n *   )\n * }\n *\n * export default Discounts\n * ```\n *\n * By default, only the first `20` records are retrieved. You can control pagination by specifying the `limit` and `offset` properties:\n *\n * ```tsx\n * import React from \"react\"\n * import { useAdminDiscounts } from \"medusa-react\"\n *\n * const Discounts = () => {\n *   const {\n *     discounts,\n *     limit,\n *     offset,\n *     isLoading\n *   } = useAdminDiscounts({\n *     expand: \"rule\",\n *     limit: 10,\n *     offset: 0\n *   })\n *\n *   return (\n *     <div>\n *       {isLoading && <span>Loading...</span>}\n *       {discounts && !discounts.length && (\n *         <span>No customers</span>\n *       )}\n *       {discounts && discounts.length > 0 && (\n *         <ul>\n *           {discounts.map((discount) => (\n *             <li key={discount.id}>{discount.code}</li>\n *           ))}\n *         </ul>\n *       )}\n *     </div>\n *   )\n * }\n *\n * export default Discounts\n * ```\n *\n * @customNamespace Hooks.Admin.Discounts\n * @category Queries\n */\nexport const useAdminDiscounts = (\n  /**\n   * Filters and pagination configurations to apply on the retrieved discounts.\n   */\n  query?: AdminGetDiscountsParams,\n  options?: UseQueryOptionsWrapper<\n    Response<AdminDiscountsListRes>,\n    Error,\n    ReturnType<DiscountQueryKeys[\"list\"]>\n  >\n) => {\n  const { client } = useMedusa()\n  const { data, ...rest } = useQuery(\n    adminDiscountKeys.list(query),\n    () => client.admin.discounts.list(query),\n    options\n  )\n  return { ...data, ...rest } as const\n}\n\n/**\n * This hook retrieves a discount.\n *\n * @example\n * import React from \"react\"\n * import { useAdminDiscount } from \"medusa-react\"\n *\n * type Props = {\n *   discountId: string\n * }\n *\n * const Discount = ({ discountId }: Props) => {\n *   const { discount, isLoading } = useAdminDiscount(\n *     discountId\n *   )\n *\n *   return (\n *     <div>\n *       {isLoading && <span>Loading...</span>}\n *       {discount && <span>{discount.code}</span>}\n *     </div>\n *   )\n * }\n *\n * export default Discount\n *\n * @customNamespace Hooks.Admin.Discounts\n * @category Queries\n */\nexport const useAdminDiscount = (\n  /**\n   * The discount's ID.\n   */\n  id: string,\n  /**\n   * Configurations to apply on the retrieved discount.\n   */\n  query?: AdminGetDiscountParams,\n  options?: UseQueryOptionsWrapper<\n    Response<AdminDiscountsRes>,\n    Error,\n    ReturnType<DiscountQueryKeys[\"detail\"]>\n  >\n) => {\n  const { client } = useMedusa()\n  const { data, ...rest } = useQuery(\n    adminDiscountKeys.detail(id),\n    () => client.admin.discounts.retrieve(id, query),\n    options\n  )\n  return { ...data, ...rest } as const\n}\n\n/**\n * This hook adds a batch of resources to a discount condition. The type of resource depends on the type of discount condition. For example, if the discount condition's type is `products`,\n * the resources being added should be products.\n *\n * @example\n * import React from \"react\"\n * import { useAdminGetDiscountByCode } from \"medusa-react\"\n *\n * type Props = {\n *   discountCode: string\n * }\n *\n * const Discount = ({ discountCode }: Props) => {\n *   const { discount, isLoading } = useAdminGetDiscountByCode(\n *     discountCode\n *   )\n *\n *   return (\n *     <div>\n *       {isLoading && <span>Loading...</span>}\n *       {discount && <span>{discount.code}</span>}\n *     </div>\n *   )\n * }\n *\n * export default Discount\n *\n * @customNamespace Hooks.Admin.Discounts\n * @category Queries\n */\nexport const useAdminGetDiscountByCode = (\n  /**\n   * The code of the discount.\n   */\n  code: string,\n  options?: UseQueryOptionsWrapper<\n    Response<AdminDiscountsRes>,\n    Error,\n    ReturnType<DiscountQueryKeys[\"detail\"]>\n  >\n) => {\n  const { client } = useMedusa()\n  const { data, ...rest } = useQuery(\n    adminDiscountKeys.detail(code),\n    () => client.admin.discounts.retrieveByCode(code),\n    options\n  )\n  return { ...data, ...rest } as const\n}\n\n/**\n * This hook retries a Discount Condition's details.\n *\n * @example\n * import React from \"react\"\n * import { useAdminGetDiscountCondition } from \"medusa-react\"\n *\n * type Props = {\n *   discountId: string\n *   discountConditionId: string\n * }\n *\n * const DiscountCondition = ({\n *   discountId,\n *   discountConditionId\n * }: Props) => {\n *   const {\n *     discount_condition,\n *     isLoading\n *   } = useAdminGetDiscountCondition(\n *     discountId,\n *     discountConditionId\n *   )\n *\n *   return (\n *     <div>\n *       {isLoading && <span>Loading...</span>}\n *       {discount_condition && (\n *         <span>{discount_condition.type}</span>\n *       )}\n *     </div>\n *   )\n * }\n *\n * export default DiscountCondition\n *\n * @customNamespace Hooks.Admin.Discounts\n * @category Queries\n */\nexport const useAdminGetDiscountCondition = (\n  /**\n   * The ID of the discount the condition belongs to.\n   */\n  id: string,\n  /**\n   * The discount condition's ID.\n   */\n  conditionId: string,\n  /**\n   * Configurations to apply on the retrieved discount condition.\n   */\n  query?: AdminGetDiscountsDiscountConditionsConditionParams,\n  options?: UseQueryOptionsWrapper<\n    Response<AdminDiscountConditionsRes>,\n    Error,\n    ReturnType<DiscountQueryKeys[\"detailCondition\"]>\n  >\n) => {\n  const { client } = useMedusa()\n  const { data, ...rest } = useQuery(\n    adminDiscountKeys.detailCondition(conditionId),\n    () => client.admin.discounts.getCondition(id, conditionId, query),\n    options\n  )\n  return { ...data, ...rest } as const\n}\n","import {\n  AdminDeleteDiscountsDiscountConditionsConditionBatchReq,\n  AdminDiscountsDeleteRes,\n  AdminDiscountsRes,\n  AdminPostDiscountsDiscountConditions,\n  AdminPostDiscountsDiscountConditionsCondition,\n  AdminPostDiscountsDiscountConditionsConditionBatchParams,\n  AdminPostDiscountsDiscountConditionsConditionBatchReq,\n  AdminPostDiscountsDiscountDynamicCodesReq,\n  AdminPostDiscountsDiscountReq,\n  AdminPostDiscountsReq,\n} from \"@medusajs/medusa\"\nimport { Response } from \"@medusajs/medusa-js\"\nimport {\n  useMutation,\n  UseMutationOptions,\n  useQueryClient,\n} from \"@tanstack/react-query\"\nimport { useMedusa } from \"../../../contexts\"\nimport { buildOptions } from \"../../utils/buildOptions\"\nimport { adminDiscountKeys } from \"./queries\"\n\n/**\n * This hook adds a batch of resources to a discount condition. The type of resource depends on the type of discount condition. \n * For example, if the discount condition's type is `products`, the resources being added should be products.\n * \n * @example\n * To add resources to a discount condition:\n * \n * ```tsx\n * import React from \"react\"\n * import { \n *   useAdminAddDiscountConditionResourceBatch\n * } from \"medusa-react\"\n * \n * type Props = {\n *   discountId: string\n *   conditionId: string\n * }\n * \n * const DiscountCondition = ({\n *   discountId,\n *   conditionId\n * }: Props) => {\n *   const addConditionResources = useAdminAddDiscountConditionResourceBatch(\n *     discountId,\n *     conditionId\n *   )\n *   // ...\n * \n *   const handleAdd = (itemId: string) => {\n *     addConditionResources.mutate({\n *       resources: [\n *         {\n *           id: itemId\n *         }\n *       ]\n *     }, {\n *       onSuccess: ({ discount }) => {\n *         console.log(discount.id)\n *       }\n *     })\n *   }\n * \n *   // ...\n * }\n * \n * export default DiscountCondition\n * ```\n * \n * To specify relations to include in the returned discount:\n * \n * ```tsx\n * import React from \"react\"\n * import { \n *   useAdminAddDiscountConditionResourceBatch\n * } from \"medusa-react\"\n * \n * type Props = {\n *   discountId: string\n *   conditionId: string\n * }\n * \n * const DiscountCondition = ({\n *   discountId,\n *   conditionId\n * }: Props) => {\n *   const addConditionResources = useAdminAddDiscountConditionResourceBatch(\n *     discountId,\n *     conditionId,\n *     {\n *       expand: \"rule\"\n *     }\n *   )\n *   // ...\n * \n *   const handleAdd = (itemId: string) => {\n *     addConditionResources.mutate({\n *       resources: [\n *         {\n *           id: itemId\n *         }\n *       ]\n *     }, {\n *       onSuccess: ({ discount }) => {\n *         console.log(discount.id)\n *       }\n *     })\n *   }\n * \n *   // ...\n * }\n * \n * export default DiscountCondition\n * ```\n * \n * @customNamespace Hooks.Admin.Discounts\n * @category Mutations\n */\nexport const useAdminAddDiscountConditionResourceBatch = (\n  /**\n   * The ID of the discount the condition belongs to.\n   */\n  discountId: string,\n  /**\n   * The discount condition's ID.\n   */\n  conditionId: string,\n  /**\n   * Configurations to apply on the retrieved discount.\n   */\n  query?: AdminPostDiscountsDiscountConditionsConditionBatchParams,\n  options?: UseMutationOptions<\n    Response<AdminDiscountsRes>,\n    Error,\n    AdminPostDiscountsDiscountConditionsConditionBatchReq\n  >\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n  return useMutation(\n    (payload: AdminPostDiscountsDiscountConditionsConditionBatchReq) =>\n      client.admin.discounts.addConditionResourceBatch(\n        discountId,\n        conditionId,\n        payload,\n        query\n      ),\n    buildOptions(queryClient, adminDiscountKeys.detail(discountId), options)\n  )\n}\n\n/**\n * This hook remove a batch of resources from a discount condition. This will only remove the association between the resource and \n * the discount condition, not the resource itself.\n * \n * @example\n * import React from \"react\"\n * import { \n *   useAdminDeleteDiscountConditionResourceBatch\n * } from \"medusa-react\"\n * \n * type Props = {\n *   discountId: string\n *   conditionId: string\n * }\n * \n * const DiscountCondition = ({\n *   discountId,\n *   conditionId\n * }: Props) => {\n *   const deleteConditionResource = useAdminDeleteDiscountConditionResourceBatch(\n *     discountId,\n *     conditionId,\n *   )\n *   // ...\n * \n *   const handleDelete = (itemId: string) => {\n *     deleteConditionResource.mutate({\n *       resources: [\n *         {\n *           id: itemId\n *         }\n *       ]\n *     }, {\n *       onSuccess: ({ discount }) => {\n *         console.log(discount.id)\n *       }\n *     })\n *   }\n * \n *   // ...\n * }\n * \n * export default DiscountCondition\n * \n * @customNamespace Hooks.Admin.Discounts\n * @category Mutations\n */\nexport const useAdminDeleteDiscountConditionResourceBatch = (\n  /**\n   * The ID of the discount the condition belongs to.\n   */\n  discountId: string,\n  /**\n   * The discount condition's ID.\n   */\n  conditionId: string,\n  options?: UseMutationOptions<\n    Response<AdminDiscountsRes>,\n    Error,\n    AdminDeleteDiscountsDiscountConditionsConditionBatchReq\n  >\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n\n  return useMutation(\n    (payload: AdminDeleteDiscountsDiscountConditionsConditionBatchReq) =>\n      client.admin.discounts.deleteConditionResourceBatch(\n        discountId,\n        conditionId,\n        payload\n      ),\n    buildOptions(queryClient, [adminDiscountKeys.detail(discountId)], options)\n  )\n}\n\n/**\n * This hook creates a discount with a given set of rules that defines how the discount is applied.\n * \n * @example\n * import React from \"react\"\n * import { \n *   useAdminCreateDiscount,\n * } from \"medusa-react\"\n * import { \n *   AllocationType, \n *   DiscountRuleType,\n * } from \"@medusajs/medusa\"\n * \n * const CreateDiscount = () => {\n *   const createDiscount = useAdminCreateDiscount()\n *   // ...\n * \n *   const handleCreate = (\n *     currencyCode: string,\n *     regionId: string\n *   ) => {\n *     // ...\n *     createDiscount.mutate({\n *       code: currencyCode,\n *       rule: {\n *         type: DiscountRuleType.FIXED,\n *         value: 10,\n *         allocation: AllocationType.ITEM,\n *       },\n *       regions: [\n *           regionId,\n *       ],\n *       is_dynamic: false,\n *       is_disabled: false,\n *     })\n *   }\n * \n *   // ...\n * }\n * \n * export default CreateDiscount\n * \n * @customNamespace Hooks.Admin.Discounts\n * @category Mutations\n */\nexport const useAdminCreateDiscount = (\n  options?: UseMutationOptions<\n    Response<AdminDiscountsRes>,\n    Error,\n    AdminPostDiscountsReq\n  >\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n  return useMutation(\n    (payload: AdminPostDiscountsReq) => client.admin.discounts.create(payload),\n    buildOptions(queryClient, adminDiscountKeys.lists(), options)\n  )\n}\n\n/**\n * This hook updates a discount with a given set of rules that define how the discount is applied.\n * \n * @example\n * import React from \"react\"\n * import { useAdminUpdateDiscount } from \"medusa-react\"\n * \n * type Props = {\n *   discountId: string\n * }\n * \n * const Discount = ({ discountId }: Props) => {\n *   const updateDiscount = useAdminUpdateDiscount(discountId)\n *   // ...\n * \n *   const handleUpdate = (isDisabled: boolean) => {\n *     updateDiscount.mutate({\n *       is_disabled: isDisabled,\n *     })\n *   }\n * \n *   // ...\n * }\n * \n * export default Discount\n * \n * @customNamespace Hooks.Admin.Discounts\n * @category Mutations\n */\nexport const useAdminUpdateDiscount = (\n  /**\n   * The discount's ID.\n   */\n  id: string,\n  options?: UseMutationOptions<\n    Response<AdminDiscountsRes>,\n    Error,\n    AdminPostDiscountsDiscountReq\n  >\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n  return useMutation(\n    (payload: AdminPostDiscountsDiscountReq) =>\n      client.admin.discounts.update(id, payload),\n    buildOptions(queryClient, adminDiscountKeys.detail(id), options)\n  )\n}\n\n/**\n * This hook deletes a discount. Deleting the discount will make it unavailable for customers to use.\n * \n * @example\n * import React from \"react\"\n * import { useAdminDeleteDiscount } from \"medusa-react\"\n * \n * const Discount = () => {\n *   const deleteDiscount = useAdminDeleteDiscount(discount_id)\n *   // ...\n * \n *   const handleDelete = () => {\n *     deleteDiscount.mutate()\n *   }\n * \n *   // ...\n * }\n * \n * export default Discount\n * \n * @customNamespace Hooks.Admin.Discounts\n * @category Mutations\n */\nexport const useAdminDeleteDiscount = (\n  /**\n   * The discount's ID.\n   */\n  id: string,\n  options?: UseMutationOptions<Response<AdminDiscountsDeleteRes>, Error, void>\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n  return useMutation(\n    () => client.admin.discounts.delete(id),\n    buildOptions(queryClient, adminDiscountKeys.lists(), options)\n  )\n}\n\n/**\n * This hook adds a Region to the list of Regions a Discount can be used in.\n * \n * @typeParamDefinition string - The ID of the region to add.\n * \n * @example\n * import React from \"react\"\n * import { useAdminDiscountAddRegion } from \"medusa-react\"\n * \n * type Props = {\n *   discountId: string\n * }\n * \n * const Discount = ({ discountId }: Props) => {\n *   const addRegion = useAdminDiscountAddRegion(discountId)\n *   // ...\n * \n *   const handleAdd = (regionId: string) => {\n *     addRegion.mutate(regionId, {\n *       onSuccess: ({ discount }) => {\n *         console.log(discount.regions)\n *       }\n *     })\n *   }\n * \n *   // ...\n * }\n * \n * export default Discount\n * \n * @customNamespace Hooks.Admin.Discounts\n * @category Mutations\n */\nexport const useAdminDiscountAddRegion = (\n  /**\n   * The discount's ID.\n   */\n  id: string,\n  options?: UseMutationOptions<Response<AdminDiscountsRes>, Error, string>\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n  return useMutation(\n    (regionId: string) => client.admin.discounts.addRegion(id, regionId),\n    buildOptions(queryClient, adminDiscountKeys.detail(id), options)\n  )\n}\n\n/**\n * This hook removes a Region from the list of Regions that a Discount can be used in. \n * This does not delete a region, only the association between it and the discount.\n * \n * @typeParamDefinition string - The ID of the region to remove.\n * \n * @example\n * import React from \"react\"\n * import { useAdminDiscountRemoveRegion } from \"medusa-react\"\n * \n * type Props = {\n *   discountId: string\n * }\n * \n * const Discount = ({ discountId }: Props) => {\n *   const deleteRegion = useAdminDiscountRemoveRegion(discountId)\n *   // ...\n * \n *   const handleDelete = (regionId: string) => {\n *     deleteRegion.mutate(regionId, {\n *       onSuccess: ({ discount }) => {\n *         console.log(discount.regions)\n *       }\n *     })\n *   }\n * \n *   // ...\n * }\n * \n * export default Discount\n * \n * @customNamespace Hooks.Admin.Discounts\n * @category Mutations\n */\nexport const useAdminDiscountRemoveRegion = (\n  /**\n   * The discount's ID.\n   */\n  id: string,\n  options?: UseMutationOptions<Response<AdminDiscountsRes>, Error, string>\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n  return useMutation(\n    (regionId: string) => client.admin.discounts.removeRegion(id, regionId),\n    buildOptions(queryClient, adminDiscountKeys.detail(id), options)\n  )\n}\n\n/**\n * This hook creates a dynamic unique code that can map to a parent discount. This is useful if you want to \n * automatically generate codes with the same rules and conditions.\n * \n * @example\n * import React from \"react\"\n * import { useAdminCreateDynamicDiscountCode } from \"medusa-react\"\n * \n * type Props = {\n *   discountId: string\n * }\n * \n * const Discount = ({ discountId }: Props) => {\n *   const createDynamicDiscount = useAdminCreateDynamicDiscountCode(discountId)\n *   // ...\n * \n *   const handleCreate = (\n *     code: string,\n *     usageLimit: number\n *   ) => {\n *     createDynamicDiscount.mutate({\n *       code,\n *       usage_limit: usageLimit\n *     }, {\n *       onSuccess: ({ discount }) => {\n *         console.log(discount.is_dynamic)\n *       }\n *     })\n *   }\n * \n *   // ...\n * }\n * \n * export default Discount\n * \n * @customNamespace Hooks.Admin.Discounts\n * @category Mutations\n */\nexport const useAdminCreateDynamicDiscountCode = (\n  /**\n   * The discount's ID.\n   */\n  id: string,\n  options?: UseMutationOptions<\n    Response<AdminDiscountsRes>,\n    Error,\n    AdminPostDiscountsDiscountDynamicCodesReq\n  >\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n  return useMutation(\n    (payload: AdminPostDiscountsDiscountDynamicCodesReq) =>\n      client.admin.discounts.createDynamicCode(id, payload),\n    buildOptions(\n      queryClient,\n      [adminDiscountKeys.lists(), adminDiscountKeys.detail(id)],\n      options\n    )\n  )\n}\n\n/**\n * This hook deletes a dynamic code from a discount.\n * \n * @typeParamDefinition string - The code of the dynamic discount to delete.\n * \n * @example\n * import React from \"react\"\n * import { useAdminDeleteDynamicDiscountCode } from \"medusa-react\"\n * \n * type Props = {\n *   discountId: string\n * }\n * \n * const Discount = ({ discountId }: Props) => {\n *   const deleteDynamicDiscount = useAdminDeleteDynamicDiscountCode(discountId)\n *   // ...\n * \n *   const handleDelete = (code: string) => {\n *     deleteDynamicDiscount.mutate(code, {\n *       onSuccess: ({ discount }) => {\n *         console.log(discount.is_dynamic)\n *       }\n *     })\n *   }\n * \n *   // ...\n * }\n * \n * export default Discount\n * \n * @customNamespace Hooks.Admin.Discounts\n * @category Mutations\n */\nexport const useAdminDeleteDynamicDiscountCode = (\n  /**\n   * The discount's ID.\n   */\n  id: string,\n  options?: UseMutationOptions<Response<AdminDiscountsRes>, Error, string>\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n  return useMutation(\n    (code: string) => client.admin.discounts.deleteDynamicCode(id, code),\n    buildOptions(\n      queryClient,\n      [adminDiscountKeys.lists(), adminDiscountKeys.detail(id)],\n      options\n    )\n  )\n}\n\n/**\n * This hook creates a discount condition. Only one of `products`, `product_types`, `product_collections`, `product_tags`, and `customer_groups` \n * should be provided in the `payload` parameter, based on the type of discount condition. For example, if the discount condition's type is `products`, \n * the `products` field should be provided in the `payload` parameter.\n * \n * @example\n * import React from \"react\"\n * import { DiscountConditionOperator } from \"@medusajs/medusa\"\n * import { useAdminDiscountCreateCondition } from \"medusa-react\"\n * \n * type Props = {\n *   discountId: string\n * }\n * \n * const Discount = ({ discountId }: Props) => {\n *   const createCondition = useAdminDiscountCreateCondition(discountId)\n *   // ...\n * \n *   const handleCreateCondition = (\n *     operator: DiscountConditionOperator,\n *     products: string[]\n *   ) => {\n *     createCondition.mutate({\n *       operator,\n *       products\n *     }, {\n *       onSuccess: ({ discount }) => {\n *         console.log(discount.id)\n *       }\n *     })\n *   }\n * \n *   // ...\n * }\n * \n * export default Discount\n * \n * @customNamespace Hooks.Admin.Discounts\n * @category Mutations\n */\nexport const useAdminDiscountCreateCondition = (\n  /**\n   * The discount's ID.\n   */\n  discountId: string,\n  options?: UseMutationOptions<\n    Response<AdminDiscountsRes>,\n    Error,\n    AdminPostDiscountsDiscountConditions\n  >\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n  return useMutation(\n    (payload: AdminPostDiscountsDiscountConditions) =>\n      client.admin.discounts.createCondition(discountId, payload),\n    buildOptions(queryClient, adminDiscountKeys.detail(discountId), options)\n  )\n}\n\n/**\n * Update a discount condition. Only one of `products`, `product_types`, `product_collections`, `product_tags`, and `customer_groups` \n * should be provided in the `payload` parameter, based on the type of discount condition. For example, if the discount condition's \n * type is `products`, the `products` field should be provided in the `payload` parameter.\n * \n * @example\n * import React from \"react\"\n * import { useAdminDiscountUpdateCondition } from \"medusa-react\"\n * \n * type Props = {\n *   discountId: string\n *   conditionId: string\n * }\n * \n * const DiscountCondition = ({\n *   discountId,\n *   conditionId\n * }: Props) => {\n *   const update = useAdminDiscountUpdateCondition(\n *     discountId,\n *     conditionId\n *   )\n *   // ...\n * \n *   const handleUpdate = (\n *     products: string[]\n *   ) => {\n *     update.mutate({\n *       products\n *     }, {\n *       onSuccess: ({ discount }) => {\n *         console.log(discount.id)\n *       }\n *     })\n *   }\n * \n *   // ...\n * }\n * \n * export default DiscountCondition\n * \n * @customNamespace Hooks.Admin.Discounts\n * @category Mutations\n */\nexport const useAdminDiscountUpdateCondition = (\n  /**\n   * The discount's ID.\n   */\n  discountId: string,\n  /**\n   * The discount condition's ID.\n   */\n  conditionId: string,\n  options?: UseMutationOptions<\n    Response<AdminDiscountsRes>,\n    Error,\n    AdminPostDiscountsDiscountConditionsCondition\n  >\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n  return useMutation(\n    (payload: AdminPostDiscountsDiscountConditionsCondition) =>\n      client.admin.discounts.updateCondition(discountId, conditionId, payload),\n    buildOptions(queryClient, adminDiscountKeys.detail(discountId), options)\n  )\n}\n\n/**\n * This hook deletes a discount condition. This doesn't delete resources associated to the discount condition.\n * \n * @typeParamDefinition string - The ID of the condition to delete.\n * \n * @example\n * import React from \"react\"\n * import { useAdminDiscountRemoveCondition } from \"medusa-react\"\n * \n * type Props = {\n *   discountId: string\n * }\n * \n * const Discount = ({ discountId }: Props) => {\n *   const deleteCondition = useAdminDiscountRemoveCondition(\n *     discountId\n *   )\n *   // ...\n * \n *   const handleDelete = (\n *     conditionId: string\n *   ) => {\n *     deleteCondition.mutate(conditionId, {\n *       onSuccess: ({ id, object, deleted }) => {\n *         console.log(deleted)\n *       }\n *     })\n *   }\n * \n *   // ...\n * }\n * \n * export default Discount\n * \n * @customNamespace Hooks.Admin.Discounts\n * @category Mutations\n */\nexport const useAdminDiscountRemoveCondition = (\n  /**\n   * The discount's ID.\n   */\n  discountId: string,\n  options?: UseMutationOptions<Response<AdminDiscountsDeleteRes>, Error, string>\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n  return useMutation(\n    (conditionId: string) =>\n      client.admin.discounts.deleteCondition(discountId, conditionId),\n    buildOptions(queryClient, adminDiscountKeys.detail(discountId), options)\n  )\n}\n","import {\n  AdminGetGiftCardsParams,\n  AdminGiftCardsListRes,\n  AdminGiftCardsRes,\n} from \"@medusajs/medusa\"\nimport { Response } from \"@medusajs/medusa-js\"\nimport { useQuery } from \"@tanstack/react-query\"\nimport { useMedusa } from \"../../../contexts\"\nimport { UseQueryOptionsWrapper } from \"../../../types\"\nimport { queryKeysFactory } from \"../../utils/index\"\n\nconst ADMIN_GIFT_CARDS_QUERY_KEY = `admin_gift_cards` as const\n\nexport const adminGiftCardKeys = queryKeysFactory(ADMIN_GIFT_CARDS_QUERY_KEY)\n\ntype GiftCardQueryKeys = typeof adminGiftCardKeys\n\n/**\n * This hook retrieves a list of gift cards. The gift cards can be filtered by fields such as `q` passed in the `query` \n * parameter. The gift cards can also paginated.\n * \n * @example\n * To list gift cards:\n * \n * ```tsx\n * import React from \"react\"\n * import { useAdminGiftCards } from \"medusa-react\"\n * \n * const CustomGiftCards = () => {\n *   const { gift_cards, isLoading } = useAdminGiftCards()\n *   \n *   return (\n *     <div>\n *       {isLoading && <span>Loading...</span>}\n *       {gift_cards && !gift_cards.length && (\n *         <span>No custom gift cards...</span>\n *       )}\n *       {gift_cards && gift_cards.length > 0 && (\n *         <ul>\n *           {gift_cards.map((giftCard) => (\n *             <li key={giftCard.id}>{giftCard.code}</li>\n *           ))}\n *         </ul>\n *       )}\n *     </div>\n *   )\n * }\n * \n * export default CustomGiftCards\n * ```\n * \n * By default, only the first `50` records are retrieved. You can control pagination by specifying the `limit` and `offset` properties:\n * \n * ```tsx\n * import React from \"react\"\n * import { useAdminGiftCards } from \"medusa-react\"\n * \n * const CustomGiftCards = () => {\n *   const { \n *     gift_cards, \n *     limit,\n *     offset,\n *     isLoading\n *   } = useAdminGiftCards({\n *     limit: 20,\n *     offset: 0\n *   })\n *   \n *   return (\n *     <div>\n *       {isLoading && <span>Loading...</span>}\n *       {gift_cards && !gift_cards.length && (\n *         <span>No custom gift cards...</span>\n *       )}\n *       {gift_cards && gift_cards.length > 0 && (\n *         <ul>\n *           {gift_cards.map((giftCard) => (\n *             <li key={giftCard.id}>{giftCard.code}</li>\n *           ))}\n *         </ul>\n *       )}\n *     </div>\n *   )\n * }\n * \n * export default CustomGiftCards\n * ```\n * \n * @customNamespace Hooks.Admin.Gift Cards\n * @category Queries\n */\nexport const useAdminGiftCards = (\n  /**\n   * Filters and pagination configurations to apply on the retrieved gift cards.\n   */\n  query?: AdminGetGiftCardsParams,\n  options?: UseQueryOptionsWrapper<\n    Response<AdminGiftCardsListRes>,\n    Error,\n    ReturnType<GiftCardQueryKeys[\"list\"]>\n  >\n) => {\n  const { client } = useMedusa()\n  const { data, ...rest } = useQuery(\n    adminGiftCardKeys.list(query),\n    () => client.admin.giftCards.list(query),\n    options\n  )\n  return { ...data, ...rest } as const\n}\n\n/**\n * This hook retrieves a gift card's details.\n * \n * @example\n * import React from \"react\"\n * import { useAdminGiftCard } from \"medusa-react\"\n * \n * type Props = {\n *   giftCardId: string\n * }\n * \n * const CustomGiftCard = ({ giftCardId }: Props) => {\n *   const { gift_card, isLoading } = useAdminGiftCard(giftCardId)\n *   \n *   return (\n *     <div>\n *       {isLoading && <span>Loading...</span>}\n *       {gift_card && <span>{gift_card.code}</span>}\n *     </div>\n *   )\n * }\n * \n * export default CustomGiftCard\n * \n * @customNamespace Hooks.Admin.Gift Cards\n * @category Queries\n */\nexport const useAdminGiftCard = (\n  /**\n   * The gift card's ID.\n   */\n  id: string,\n  options?: UseQueryOptionsWrapper<\n    Response<AdminGiftCardsRes>,\n    Error,\n    ReturnType<GiftCardQueryKeys[\"detail\"]>\n  >\n) => {\n  const { client } = useMedusa()\n  const { data, ...rest } = useQuery(\n    adminGiftCardKeys.detail(id),\n    () => client.admin.giftCards.retrieve(id),\n    options\n  )\n  return { ...data, ...rest } as const\n}\n","import {\n  AdminGiftCardsDeleteRes,\n  AdminGiftCardsRes,\n  AdminPostGiftCardsGiftCardReq,\n  AdminPostGiftCardsReq,\n} from \"@medusajs/medusa\"\nimport { Response } from \"@medusajs/medusa-js\"\nimport {\n  useMutation,\n  UseMutationOptions,\n  useQueryClient,\n} from \"@tanstack/react-query\"\nimport { useMedusa } from \"../../../contexts/medusa\"\nimport { buildOptions } from \"../../utils/buildOptions\"\nimport { adminGiftCardKeys } from \"./queries\"\n\n/**\n * This hook creates a gift card that can redeemed by its unique code. The Gift Card is only valid within one region.\n * \n * @example\n * import React from \"react\"\n * import { useAdminCreateGiftCard } from \"medusa-react\"\n * \n * const CreateCustomGiftCards = () => {\n *   const createGiftCard = useAdminCreateGiftCard()\n *   // ...\n *   \n *   const handleCreate = (\n *     regionId: string, \n *     value: number\n *   ) => {\n *     createGiftCard.mutate({\n *       region_id: regionId,\n *       value,\n *     }, {\n *       onSuccess: ({ gift_card }) => {\n *         console.log(gift_card.id)\n *       }\n *     })\n *   }\n * \n *   // ...\n * }\n * \n * export default CreateCustomGiftCards\n * \n * @customNamespace Hooks.Admin.Gift Cards\n * @category Mutations\n */\nexport const useAdminCreateGiftCard = (\n  options?: UseMutationOptions<\n    Response<AdminGiftCardsRes>,\n    Error,\n    AdminPostGiftCardsReq\n  >\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n  return useMutation(\n    (payload: AdminPostGiftCardsReq) => client.admin.giftCards.create(payload),\n    buildOptions(queryClient, adminGiftCardKeys.lists(), options)\n  )\n}\n\n/**\n * This hook updates a gift card's details.\n * \n * @example\n * import React from \"react\"\n * import { useAdminUpdateGiftCard } from \"medusa-react\"\n * \n * type Props = {\n *   customGiftCardId: string\n * }\n * \n * const CustomGiftCard = ({ customGiftCardId }: Props) => {\n *   const updateGiftCard = useAdminUpdateGiftCard(\n *     customGiftCardId\n *   )\n *   // ...\n *   \n *   const handleUpdate = (regionId: string) => {\n *     updateGiftCard.mutate({\n *       region_id: regionId,\n *     }, {\n *       onSuccess: ({ gift_card }) => {\n *         console.log(gift_card.id)\n *       }\n *     })\n *   }\n * \n *   // ...\n * }\n * \n * export default CustomGiftCard\n * \n * @customNamespace Hooks.Admin.Gift Cards\n * @category Mutations\n */\nexport const useAdminUpdateGiftCard = (\n  /**\n   * The gift card's ID.\n   */\n  id: string,\n  options?: UseMutationOptions<\n    Response<AdminGiftCardsRes>,\n    Error,\n    AdminPostGiftCardsGiftCardReq\n  >\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n\n  return useMutation(\n    (payload: AdminPostGiftCardsGiftCardReq) =>\n      client.admin.giftCards.update(id, payload),\n    buildOptions(\n      queryClient,\n      [adminGiftCardKeys.lists(), adminGiftCardKeys.detail(id)],\n      options\n    )\n  )\n}\n\n/**\n * This hook deletes a gift card. Once deleted, it can't be used by customers.\n * \n * @example\n * import React from \"react\"\n * import { useAdminDeleteGiftCard } from \"medusa-react\"\n * \n * type Props = {\n *   customGiftCardId: string\n * }\n * \n * const CustomGiftCard = ({ customGiftCardId }: Props) => {\n *   const deleteGiftCard = useAdminDeleteGiftCard(\n *     customGiftCardId\n *   )\n *   // ...\n *   \n *   const handleDelete = () => {\n *     deleteGiftCard.mutate(void 0, {\n *       onSuccess: ({ id, object, deleted}) => {\n *         console.log(id)\n *       }\n *     })\n *   }\n * \n *   // ...\n * }\n * \n * export default CustomGiftCard\n * \n * @customNamespace Hooks.Admin.Gift Cards\n * @category Mutations\n */\nexport const useAdminDeleteGiftCard = (\n  /**\n   * The gift card's ID.\n   */\n  id: string,\n  options?: UseMutationOptions<Response<AdminGiftCardsDeleteRes>, Error, void>\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n  return useMutation(\n    () => client.admin.giftCards.delete(id),\n    buildOptions(\n      queryClient,\n      [adminGiftCardKeys.lists(), adminGiftCardKeys.detail(id)],\n      options\n    )\n  )\n}\n","import {\n  AdminOrdersRes,\n  AdminPostOrdersOrderFulfillmentsReq,\n  AdminPostOrdersOrderRefundsReq,\n  AdminPostOrdersOrderReq,\n  AdminPostOrdersOrderReturnsReq,\n  AdminPostOrdersOrderShipmentReq,\n  AdminPostOrdersOrderShippingMethodsReq,\n} from \"@medusajs/medusa\"\nimport { Response } from \"@medusajs/medusa-js\"\nimport {\n  useMutation,\n  UseMutationOptions,\n  useQueryClient,\n} from \"@tanstack/react-query\"\nimport { useMedusa } from \"../../../contexts/medusa\"\nimport { buildOptions } from \"../../utils/buildOptions\"\nimport { adminProductKeys } from \"../products\"\nimport { adminVariantKeys } from \"../variants\"\nimport { adminOrderKeys } from \"./queries\"\n\n/**\n * This hook updates an order's details.\n * \n * @example\n * import React from \"react\"\n * import { useAdminUpdateOrder } from \"medusa-react\"\n * \n * type Props = {\n *   orderId: string\n * }\n * \n * const Order = ({ orderId }: Props) => {\n *   const updateOrder = useAdminUpdateOrder(\n *     orderId\n *   )\n * \n *   const handleUpdate = (\n *     email: string\n *   ) => {\n *     updateOrder.mutate({\n *       email,\n *     }, {\n *       onSuccess: ({ order }) => {\n *         console.log(order.email)\n *       }\n *     })\n *   }\n * \n *   // ...\n * }\n * \n * export default Order\n * \n * @customNamespace Hooks.Admin.Orders\n * @category Mutations\n */\nexport const useAdminUpdateOrder = (\n  /**\n   * The order's ID.\n   */\n  id: string,\n  options?: UseMutationOptions<\n    Response<AdminOrdersRes>,\n    Error,\n    AdminPostOrdersOrderReq\n  >\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n\n  return useMutation(\n    (payload: AdminPostOrdersOrderReq) =>\n      client.admin.orders.update(id, payload),\n    buildOptions(\n      queryClient,\n      [adminOrderKeys.lists(), adminOrderKeys.detail(id)],\n      options\n    )\n  )\n}\n\n/**\n * This hook cancels an order and change its status. This will also cancel any associated fulfillments and payments, \n * and it may fail if the payment or fulfillment Provider is unable to cancel the payment/fulfillment.\n * \n * @example\n * import React from \"react\"\n * import { useAdminCancelOrder } from \"medusa-react\"\n * \n * type Props = {\n *   orderId: string\n * }\n * \n * const Order = ({ orderId }: Props) => {\n *   const cancelOrder = useAdminCancelOrder(\n *     orderId\n *   )\n *   // ...\n * \n *   const handleCancel = () => {\n *     cancelOrder.mutate(void 0, {\n *       onSuccess: ({ order }) => {\n *         console.log(order.status)\n *       }\n *     })\n *   }\n * \n *   // ...\n * }\n * \n * export default Order\n * \n * @customNamespace Hooks.Admin.Orders\n * @category Mutations\n */\nexport const useAdminCancelOrder = (\n  /**\n   * The order's ID.\n   */\n  id: string,\n  options?: UseMutationOptions<Response<AdminOrdersRes>, Error, void>\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n\n  return useMutation(\n    () => client.admin.orders.cancel(id),\n    buildOptions(\n      queryClient,\n      [adminOrderKeys.lists(), adminOrderKeys.detail(id)],\n      options\n    )\n  )\n}\n\n/**\n * This hook completes an order and change its status. A canceled order can't be completed.\n * \n * @example\n * import React from \"react\"\n * import { useAdminCompleteOrder } from \"medusa-react\"\n * \n * type Props = {\n *   orderId: string\n * }\n * \n * const Order = ({ orderId }: Props) => {\n *   const completeOrder = useAdminCompleteOrder(\n *     orderId\n *   )\n *   // ...\n * \n *   const handleComplete = () => {\n *     completeOrder.mutate(void 0, {\n *       onSuccess: ({ order }) => {\n *         console.log(order.status)\n *       }\n *     })\n *   }\n * \n *   // ...\n * }\n * \n * export default Order\n * \n * @customNamespace Hooks.Admin.Orders\n * @category Mutations\n */\nexport const useAdminCompleteOrder = (\n  /**\n   * The order's ID.\n   */\n  id: string,\n  options?: UseMutationOptions<Response<AdminOrdersRes>, Error, void>\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n\n  return useMutation(\n    () => client.admin.orders.complete(id),\n    buildOptions(\n      queryClient,\n      [adminOrderKeys.lists(), adminOrderKeys.detail(id)],\n      options\n    )\n  )\n}\n\n/**\n * This hook captures all the payments associated with an order. The payment of canceled orders can't be captured.\n * \n * @example\n * import React from \"react\"\n * import { useAdminCapturePayment } from \"medusa-react\"\n * \n * type Props = {\n *   orderId: string\n * }\n * \n * const Order = ({ orderId }: Props) => {\n *   const capturePayment = useAdminCapturePayment(\n *     orderId\n *   )\n *   // ...\n * \n *   const handleCapture = () => {\n *     capturePayment.mutate(void 0, {\n *       onSuccess: ({ order }) => {\n *         console.log(order.status)\n *       }\n *     })\n *   }\n * \n *   // ...\n * }\n * \n * export default Order\n * \n * @customNamespace Hooks.Admin.Orders\n * @category Mutations\n */\nexport const useAdminCapturePayment = (\n  /**\n   * The order's ID.\n   */\n  id: string,\n  options?: UseMutationOptions<Response<AdminOrdersRes>, Error, void>\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n\n  return useMutation(\n    () => client.admin.orders.capturePayment(id),\n    buildOptions(\n      queryClient,\n      [adminOrderKeys.lists(), adminOrderKeys.detail(id)],\n      options\n    )\n  )\n}\n\n/**\n * This hook refunds an amount for an order. The amount must be less than or equal the `refundable_amount` of the order.\n * \n * @example\n * import React from \"react\"\n * import { useAdminRefundPayment } from \"medusa-react\"\n * \n * type Props = {\n *   orderId: string\n * }\n * \n * const Order = ({ orderId }: Props) => {\n *   const refundPayment = useAdminRefundPayment(\n *     orderId\n *   )\n *   // ...\n * \n *   const handleRefund = (\n *     amount: number,\n *     reason: string\n *   ) => {\n *     refundPayment.mutate({\n *       amount,\n *       reason,\n *     }, {\n *       onSuccess: ({ order }) => {\n *         console.log(order.refunds)\n *       }\n *     })\n *   }\n * \n *   // ...\n * }\n * \n * export default Order\n * \n * @customNamespace Hooks.Admin.Orders\n * @category Mutations\n */\nexport const useAdminRefundPayment = (\n  /**\n   * The order's ID.\n   */\n  id: string,\n  options?: UseMutationOptions<\n    Response<AdminOrdersRes>,\n    Error,\n    AdminPostOrdersOrderRefundsReq\n  >\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n\n  return useMutation(\n    (payload: AdminPostOrdersOrderRefundsReq) =>\n      client.admin.orders.refundPayment(id, payload),\n    buildOptions(\n      queryClient,\n      [adminOrderKeys.lists(), adminOrderKeys.detail(id)],\n      options\n    )\n  )\n}\n\n/**\n * This hook creates a Fulfillment of an Order using the fulfillment provider, and change the order's \n * fulfillment status to either `partially_fulfilled` or `fulfilled`, depending on\n * whether all the items were fulfilled.\n * \n * @example\n * import React from \"react\"\n * import { useAdminCreateFulfillment } from \"medusa-react\"\n * \n * type Props = {\n *   orderId: string\n * }\n * \n * const Order = ({ orderId }: Props) => {\n *   const createFulfillment = useAdminCreateFulfillment(\n *     orderId\n *   )\n *   // ...\n * \n *   const handleCreateFulfillment = (\n *     itemId: string,\n *     quantity: number\n *   ) => {\n *     createFulfillment.mutate({\n *       items: [\n *         {\n *           item_id: itemId,\n *           quantity,\n *         },\n *       ],\n *     }, {\n *       onSuccess: ({ order }) => {\n *         console.log(order.fulfillments)\n *       }\n *     })\n *   }\n * \n *   // ...\n * }\n * \n * export default Order\n * \n * @customNamespace Hooks.Admin.Orders\n * @category Mutations\n */\nexport const useAdminCreateFulfillment = (\n  /**\n   * The order's ID.\n   */\n  orderId: string,\n  options?: UseMutationOptions<\n    Response<AdminOrdersRes>,\n    Error,\n    AdminPostOrdersOrderFulfillmentsReq\n  >\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n\n  return useMutation(\n    (payload: AdminPostOrdersOrderFulfillmentsReq) =>\n      client.admin.orders.createFulfillment(orderId, payload),\n    buildOptions(\n      queryClient,\n      [\n        adminOrderKeys.lists(),\n        adminOrderKeys.detail(orderId),\n        adminVariantKeys.all,\n        adminProductKeys.lists(),\n      ],\n      options\n    )\n  )\n}\n\n/**\n * This hook cancels an order's fulfillment and change its fulfillment status to `canceled`.\n * \n * @typeParamDefinition string - The fulfillment's ID.\n * \n * @example\n * import React from \"react\"\n * import { useAdminCancelFulfillment } from \"medusa-react\"\n * \n * type Props = {\n *   orderId: string\n * }\n * \n * const Order = ({ orderId }: Props) => {\n *   const cancelFulfillment = useAdminCancelFulfillment(\n *     orderId\n *   )\n *   // ...\n * \n *   const handleCancel = (\n *     fulfillmentId: string\n *   ) => {\n *     cancelFulfillment.mutate(fulfillmentId, {\n *       onSuccess: ({ order }) => {\n *         console.log(order.fulfillments)\n *       }\n *     })\n *   }\n * \n *   // ...\n * }\n * \n * export default Order\n * \n * @customNamespace Hooks.Admin.Orders\n * @category Mutations\n */\nexport const useAdminCancelFulfillment = (\n  /**\n   * The order's ID.\n   */\n  orderId: string,\n  options?: UseMutationOptions<Response<AdminOrdersRes>, Error, string>\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n\n  return useMutation(\n    (fulfillmentId: string) =>\n      client.admin.orders.cancelFulfillment(orderId, fulfillmentId),\n    buildOptions(\n      queryClient,\n      [adminOrderKeys.lists(), adminOrderKeys.detail(orderId)],\n      options\n    )\n  )\n}\n\n/**\n * This hook creates a shipment and mark a fulfillment as shipped. This changes the order's fulfillment status to either \n * `partially_shipped` or `shipped`, depending on whether all the items were shipped.\n * \n * @example\n * import React from \"react\"\n * import { useAdminCreateShipment } from \"medusa-react\"\n * \n * type Props = {\n *   orderId: string\n * }\n * \n * const Order = ({ orderId }: Props) => {\n *   const createShipment = useAdminCreateShipment(\n *     orderId\n *   )\n *   // ...\n * \n *   const handleCreate = (\n *     fulfillmentId: string\n *   ) => {\n *     createShipment.mutate({\n *       fulfillment_id: fulfillmentId,\n *     }, {\n *       onSuccess: ({ order }) => {\n *         console.log(order.fulfillment_status)\n *       }\n *     })\n *   }\n * \n *   // ...\n * }\n * \n * export default Order\n * \n * @customNamespace Hooks.Admin.Orders\n * @category Mutations\n */\nexport const useAdminCreateShipment = (\n  /**\n   * The order's ID.\n   */\n  orderId: string,\n  options?: UseMutationOptions<\n    Response<AdminOrdersRes>,\n    Error,\n    AdminPostOrdersOrderShipmentReq\n  >\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n\n  return useMutation(\n    (payload: AdminPostOrdersOrderShipmentReq) =>\n      client.admin.orders.createShipment(orderId, payload),\n    buildOptions(queryClient, adminOrderKeys.detail(orderId), options)\n  )\n}\n\n/**\n * This hook requests and create a return for items in an order. If the return shipping method is specified, it will be automatically fulfilled.\n * \n * @example\n * import React from \"react\"\n * import { useAdminRequestReturn } from \"medusa-react\"\n * \n * type Props = {\n *   orderId: string\n * }\n * \n * const Order = ({ orderId }: Props) => {\n *   const requestReturn = useAdminRequestReturn(\n *     orderId\n *   )\n *   // ...\n * \n *   const handleRequestingReturn = (\n *     itemId: string,\n *     quantity: number\n *   ) => {\n *     requestReturn.mutate({\n *       items: [\n *         {\n *           item_id: itemId,\n *           quantity\n *         }\n *       ]\n *     }, {\n *       onSuccess: ({ order }) => {\n *         console.log(order.returns)\n *       }\n *     })\n *   }\n * \n *   // ...\n * }\n * \n * export default Order\n * \n * @customNamespace Hooks.Admin.Orders\n * @category Mutations\n */\nexport const useAdminRequestReturn = (\n  /**\n   * The order's ID.\n   */\n  orderId: string,\n  options?: UseMutationOptions<\n    Response<AdminOrdersRes>,\n    Error,\n    AdminPostOrdersOrderReturnsReq\n  >\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n\n  return useMutation(\n    (payload: AdminPostOrdersOrderReturnsReq) =>\n      client.admin.orders.requestReturn(orderId, payload),\n    buildOptions(queryClient, adminOrderKeys.detail(orderId), options)\n  )\n}\n\n/**\n * This hook adds a shipping method to an order. If another shipping method exists with the same shipping profile, the previous shipping method will be replaced.\n * \n * @example\n * import React from \"react\"\n * import { useAdminAddShippingMethod } from \"medusa-react\"\n * \n * type Props = {\n *   orderId: string\n * }\n * \n * const Order = ({ orderId }: Props) => {\n *   const addShippingMethod = useAdminAddShippingMethod(\n *     orderId\n *   )\n *   // ...\n * \n *   const handleAddShippingMethod = (\n *     optionId: string,\n *     price: number\n *   ) => {\n *     addShippingMethod.mutate({\n *       option_id: optionId,\n *       price\n *     }, {\n *       onSuccess: ({ order }) => {\n *         console.log(order.shipping_methods)\n *       }\n *     })\n *   }\n * \n *   // ...\n * }\n * \n * export default Order\n * \n * @customNamespace Hooks.Admin.Orders\n * @category Mutations\n */\nexport const useAdminAddShippingMethod = (\n  /**\n   * The order's ID.\n   */\n  orderId: string,\n  options?: UseMutationOptions<\n    Response<AdminOrdersRes>,\n    Error,\n    AdminPostOrdersOrderShippingMethodsReq\n  >\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n\n  return useMutation(\n    (payload: AdminPostOrdersOrderShippingMethodsReq) =>\n      client.admin.orders.addShippingMethod(orderId, payload),\n    buildOptions(queryClient, adminOrderKeys.detail(orderId), options)\n  )\n}\n\n/**\n * The hook archives an order and change its status.\n * \n * @example\n * import React from \"react\"\n * import { useAdminArchiveOrder } from \"medusa-react\"\n * \n * type Props = {\n *   orderId: string\n * }\n * \n * const Order = ({ orderId }: Props) => {\n *   const archiveOrder = useAdminArchiveOrder(\n *     orderId\n *   )\n *   // ...\n * \n *   const handleArchivingOrder = () => {\n *     archiveOrder.mutate(void 0, {\n *       onSuccess: ({ order }) => {\n *         console.log(order.status)\n *       }\n *     })\n *   }\n * \n *   // ...\n * }\n * \n * export default Order\n * \n * @customNamespace Hooks.Admin.Orders\n * @category Mutations\n */\nexport const useAdminArchiveOrder = (\n  /**\n   * The order's ID.\n   */\n  id: string,\n  options?: UseMutationOptions<Response<AdminOrdersRes>, Error, void>\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n\n  return useMutation(\n    () => client.admin.orders.archive(id),\n    buildOptions(\n      queryClient,\n      [adminOrderKeys.lists(), adminOrderKeys.detail(id)],\n      options\n    )\n  )\n}\n","import {\n  AdminGetPriceListPaginationParams,\n  AdminGetPriceListsPriceListProductsParams,\n  AdminPriceListRes,\n  AdminPriceListsListRes,\n  AdminProductsListRes,\n} from \"@medusajs/medusa\"\nimport { Response } from \"@medusajs/medusa-js\"\nimport { useQuery } from \"@tanstack/react-query\"\nimport { useMedusa } from \"../../../contexts\"\nimport { UseQueryOptionsWrapper } from \"../../../types\"\nimport { queryKeysFactory } from \"../../utils/index\"\n\nconst ADMIN_PRICE_LISTS_QUERY_KEY = `admin_price_lists` as const\n\nexport const adminPriceListKeys = {\n  ...queryKeysFactory(ADMIN_PRICE_LISTS_QUERY_KEY),\n  detailProducts(id: string, query?: any) {\n    return [\n      ...this.detail(id),\n      \"products\" as const,\n      { ...(query || {}) },\n    ] as const\n  },\n}\n\ntype PriceListQueryKeys = typeof adminPriceListKeys\n\n/**\n * This hook retrieves a list of price lists. The price lists can be filtered by fields such as `q` or `status` passed \n * in the `query` parameter. The price lists can also be sorted or paginated.\n * \n * @example\n * To list price lists:\n * \n * ```tsx\n * import React from \"react\"\n * import { useAdminPriceLists } from \"medusa-react\"\n * \n * const PriceLists = () => {\n *   const { price_lists, isLoading } = useAdminPriceLists()\n * \n *   return (\n *     <div>\n *       {isLoading && <span>Loading...</span>}\n *       {price_lists && !price_lists.length && (\n *         <span>No Price Lists</span>\n *       )}\n *       {price_lists && price_lists.length > 0 && (\n *         <ul>\n *           {price_lists.map((price_list) => (\n *             <li key={price_list.id}>{price_list.name}</li>\n *           ))}\n *         </ul>\n *       )}\n *     </div>\n *   )\n * }\n * \n * export default PriceLists\n * ```\n * \n * To specify relations that should be retrieved within the price lists:\n * \n * ```tsx\n * import React from \"react\"\n * import { useAdminPriceLists } from \"medusa-react\"\n * \n * const PriceLists = () => {\n *   const { price_lists, isLoading } = useAdminPriceLists({\n *     expand: \"prices\"\n *   })\n * \n *   return (\n *     <div>\n *       {isLoading && <span>Loading...</span>}\n *       {price_lists && !price_lists.length && (\n *         <span>No Price Lists</span>\n *       )}\n *       {price_lists && price_lists.length > 0 && (\n *         <ul>\n *           {price_lists.map((price_list) => (\n *             <li key={price_list.id}>{price_list.name}</li>\n *           ))}\n *         </ul>\n *       )}\n *     </div>\n *   )\n * }\n * \n * export default PriceLists\n * ```\n * \n * By default, only the first `10` records are retrieved. You can control pagination by specifying the `limit` and `offset` properties:\n * \n * ```tsx\n * import React from \"react\"\n * import { useAdminPriceLists } from \"medusa-react\"\n * \n * const PriceLists = () => {\n *   const { \n *     price_lists, \n *     limit,\n *     offset,\n *     isLoading\n *   } = useAdminPriceLists({\n *     expand: \"prices\",\n *     limit: 20,\n *     offset: 0\n *   })\n * \n *   return (\n *     <div>\n *       {isLoading && <span>Loading...</span>}\n *       {price_lists && !price_lists.length && (\n *         <span>No Price Lists</span>\n *       )}\n *       {price_lists && price_lists.length > 0 && (\n *         <ul>\n *           {price_lists.map((price_list) => (\n *             <li key={price_list.id}>{price_list.name}</li>\n *           ))}\n *         </ul>\n *       )}\n *     </div>\n *   )\n * }\n * \n * export default PriceLists\n * ```\n * \n * @customNamespace Hooks.Admin.Price Lists\n * @category Queries\n */\nexport const useAdminPriceLists = (\n  /**\n   * Filters and pagination configurations to apply on the retrieved price lists.\n   */\n  query?: AdminGetPriceListPaginationParams,\n  options?: UseQueryOptionsWrapper<\n    Response<AdminPriceListsListRes>,\n    Error,\n    ReturnType<PriceListQueryKeys[\"list\"]>\n  >\n) => {\n  const { client } = useMedusa()\n  const { data, ...rest } = useQuery(\n    adminPriceListKeys.list(query),\n    () => client.admin.priceLists.list(query),\n    options\n  )\n  return { ...data, ...rest } as const\n}\n\n/**\n * This hook retrieves a price list's products. The products can be filtered by fields such as `q` or `status` \n * passed in the `query` parameter. The products can also be sorted or paginated.\n * \n * @example\n * To list products in a price list:\n * \n * ```tsx\n * import React from \"react\"\n * import { useAdminPriceListProducts } from \"medusa-react\"\n * \n * type Props = {\n *   priceListId: string\n * }\n * \n * const PriceListProducts = ({\n *   priceListId\n * }: Props) => {\n *   const { products, isLoading } = useAdminPriceListProducts(\n *     priceListId\n *   )\n * \n *   return (\n *     <div>\n *       {isLoading && <span>Loading...</span>}\n *       {products && !products.length && (\n *         <span>No Price Lists</span>\n *       )}\n *       {products && products.length > 0 && (\n *         <ul>\n *           {products.map((product) => (\n *             <li key={product.id}>{product.title}</li>\n *           ))}\n *         </ul>\n *       )}\n *     </div>\n *   )\n * }\n * \n * export default PriceListProducts\n * ```\n * \n * To specify relations that should be retrieved within the products:\n * \n * ```tsx\n * import React from \"react\"\n * import { useAdminPriceListProducts } from \"medusa-react\"\n * \n * type Props = {\n *   priceListId: string\n * }\n * \n * const PriceListProducts = ({\n *   priceListId\n * }: Props) => {\n *   const { products, isLoading } = useAdminPriceListProducts(\n *     priceListId,\n *     {\n *       expand: \"variants\"\n *     }\n *   )\n * \n *   return (\n *     <div>\n *       {isLoading && <span>Loading...</span>}\n *       {products && !products.length && (\n *         <span>No Price Lists</span>\n *       )}\n *       {products && products.length > 0 && (\n *         <ul>\n *           {products.map((product) => (\n *             <li key={product.id}>{product.title}</li>\n *           ))}\n *         </ul>\n *       )}\n *     </div>\n *   )\n * }\n * \n * export default PriceListProducts\n * ```\n * \n * By default, only the first `50` records are retrieved. You can control pagination by specifying the `limit` and `offset` properties:\n * \n * ```tsx\n * import React from \"react\"\n * import { useAdminPriceListProducts } from \"medusa-react\"\n * \n * type Props = {\n *   priceListId: string\n * }\n * \n * const PriceListProducts = ({\n *   priceListId\n * }: Props) => {\n *   const { \n *     products,\n *     limit,\n *     offset,\n *     isLoading\n *   } = useAdminPriceListProducts(\n *     priceListId,\n *     {\n *       expand: \"variants\",\n *       limit: 20,\n *       offset: 0\n *     }\n *   )\n * \n *   return (\n *     <div>\n *       {isLoading && <span>Loading...</span>}\n *       {products && !products.length && (\n *         <span>No Price Lists</span>\n *       )}\n *       {products && products.length > 0 && (\n *         <ul>\n *           {products.map((product) => (\n *             <li key={product.id}>{product.title}</li>\n *           ))}\n *         </ul>\n *       )}\n *     </div>\n *   )\n * }\n * \n * export default PriceListProducts\n * ```\n * \n * @customNamespace Hooks.Admin.Price Lists\n * @category Queries\n */\nexport const useAdminPriceListProducts = (\n  /**\n   * The ID of the associated price list.\n   */\n  id: string,\n  /**\n   * Filters and pagination configurations applied on the retrieved products.\n   */\n  query?: AdminGetPriceListsPriceListProductsParams,\n  options?: UseQueryOptionsWrapper<\n    Response<AdminProductsListRes>,\n    Error,\n    ReturnType<PriceListQueryKeys[\"detailProducts\"]>\n  >\n) => {\n  const { client } = useMedusa()\n  const { data, ...rest } = useQuery(\n    adminPriceListKeys.detailProducts(id, query),\n    () => client.admin.priceLists.listProducts(id, query),\n    options\n  )\n  return { ...data, ...rest } as const\n}\n\n/**\n * This hook retrieves a price list's details.\n * \n * @example\n * import React from \"react\"\n * import { useAdminPriceList } from \"medusa-react\"\n * \n * type Props = {\n *   priceListId: string\n * }\n * \n * const PriceList = ({\n *   priceListId\n * }: Props) => {\n *   const { \n *     price_list, \n *     isLoading, \n *   } = useAdminPriceList(priceListId)\n * \n *   return (\n *     <div>\n *       {isLoading && <span>Loading...</span>}\n *       {price_list && <span>{price_list.name}</span>}\n *     </div>\n *   )\n * }\n * \n * export default PriceList\n * \n * @customNamespace Hooks.Admin.Price Lists\n * @category Queries\n */\nexport const useAdminPriceList = (\n  /**\n   * The price list's ID.\n   */\n  id: string,\n  options?: UseQueryOptionsWrapper<\n    Response<AdminPriceListRes>,\n    Error,\n    ReturnType<PriceListQueryKeys[\"detail\"]>\n  >\n) => {\n  const { client } = useMedusa()\n  const { data, ...rest } = useQuery(\n    adminPriceListKeys.detail(id),\n    () => client.admin.priceLists.retrieve(id),\n    options\n  )\n  return { ...data, ...rest } as const\n}\n","import {\n  AdminDeletePriceListPricesPricesReq,\n  AdminDeletePriceListsPriceListProductsPricesBatchReq,\n  AdminPostPriceListPricesPricesReq,\n  AdminPostPriceListsPriceListPriceListReq,\n  AdminPostPriceListsPriceListReq,\n  AdminPriceListDeleteBatchRes,\n  AdminPriceListDeleteProductPricesRes,\n  AdminPriceListDeleteRes,\n  AdminPriceListDeleteVariantPricesRes,\n  AdminPriceListRes,\n} from \"@medusajs/medusa\"\nimport { Response } from \"@medusajs/medusa-js\"\nimport {\n  UseMutationOptions,\n  useMutation,\n  useQueryClient,\n} from \"@tanstack/react-query\"\nimport { useMedusa } from \"../../../contexts/medusa\"\nimport { buildOptions } from \"../../utils/buildOptions\"\nimport { adminProductKeys } from \"../products\"\nimport { adminVariantKeys } from \"../variants\"\nimport { adminPriceListKeys } from \"./queries\"\n\n/**\n * This hook creates a price list.\n * \n * @example\n * import React from \"react\"\n * import { \n *   PriceListStatus, \n *   PriceListType, \n * } from \"@medusajs/medusa\"\n * import { useAdminCreatePriceList } from \"medusa-react\"\n * \n * type CreateData = {\n *   name: string\n *   description: string\n *   type: PriceListType\n *   status: PriceListStatus\n *   prices: {\n *     amount: number\n *     variant_id: string\n *     currency_code: string\n *     max_quantity: number\n *   }[]\n * }\n * \n * const CreatePriceList = () => {\n *   const createPriceList = useAdminCreatePriceList()\n *   // ...\n * \n *   const handleCreate = (\n *     data: CreateData\n *   ) => {\n *     createPriceList.mutate(data, {\n *       onSuccess: ({ price_list }) => {\n *         console.log(price_list.id)\n *       }\n *     })\n *   }\n * \n *   // ...\n * }\n * \n * export default CreatePriceList\n * \n * @customNamespace Hooks.Admin.Price Lists\n * @category Mutations\n */\nexport const useAdminCreatePriceList = (\n  options?: UseMutationOptions<\n    Response<AdminPriceListRes>,\n    Error,\n    AdminPostPriceListsPriceListReq\n  >\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n  return useMutation(\n    (payload: AdminPostPriceListsPriceListReq) =>\n      client.admin.priceLists.create(payload),\n    buildOptions(queryClient, [adminPriceListKeys.lists()], options)\n  )\n}\n\n/**\n * This hook updates a price list's details.\n * \n * @example\n * import React from \"react\"\n * import { useAdminUpdatePriceList } from \"medusa-react\"\n * \n * type Props = {\n *   priceListId: string\n * }\n * \n * const PriceList = ({\n *   priceListId\n * }: Props) => {\n *   const updatePriceList = useAdminUpdatePriceList(priceListId)\n *   // ...\n * \n *   const handleUpdate = (\n *     endsAt: Date\n *   ) => {\n *     updatePriceList.mutate({\n *       ends_at: endsAt,\n *     }, {\n *       onSuccess: ({ price_list }) => {\n *         console.log(price_list.ends_at)\n *       }\n *     })\n *   }\n * \n *   // ...\n * }\n * \n * export default PriceList\n * \n * @customNamespace Hooks.Admin.Price Lists\n * @category Mutations\n */\nexport const useAdminUpdatePriceList = (\n  /**\n   * The price list's ID.\n   */\n  id: string,\n  options?: UseMutationOptions<\n    Response<AdminPriceListRes>,\n    Error,\n    AdminPostPriceListsPriceListPriceListReq\n  >\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n\n  return useMutation(\n    (payload: AdminPostPriceListsPriceListPriceListReq) =>\n      client.admin.priceLists.update(id, payload),\n    buildOptions(\n      queryClient,\n      [\n        adminPriceListKeys.detail(id),\n        adminPriceListKeys.lists(),\n        adminPriceListKeys.detailProducts(id),\n      ],\n      options\n    )\n  )\n}\n\n/**\n * This hook deletes a price list and its associated prices.\n * \n * @example\n * import React from \"react\"\n * import { useAdminDeletePriceList } from \"medusa-react\"\n * \n * type Props = {\n *   priceListId: string\n * }\n * \n * const PriceList = ({\n *   priceListId\n * }: Props) => {\n *   const deletePriceList = useAdminDeletePriceList(priceListId)\n *   // ...\n * \n *   const handleDelete = () => {\n *     deletePriceList.mutate(void 0, {\n *       onSuccess: ({ id, object, deleted }) => {\n *         console.log(id)\n *       }\n *     })\n *   }\n * \n *   // ...\n * }\n * \n * export default PriceList\n * \n * @customNamespace Hooks.Admin.Price Lists\n * @category Mutations\n */\nexport const useAdminDeletePriceList = (\n  /**\n   * The price list's ID.\n   */\n  id: string,\n  options?: UseMutationOptions<Response<AdminPriceListDeleteRes>, Error, void>\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n\n  return useMutation(\n    () => client.admin.priceLists.delete(id),\n    buildOptions(\n      queryClient,\n      [adminPriceListKeys.detail(id), adminPriceListKeys.lists()],\n      options\n    )\n  )\n}\n\n/**\n * This hook adds or updates a list of prices in a price list.\n * \n * @example\n * import React from \"react\"\n * import { useAdminCreatePriceListPrices } from \"medusa-react\"\n * \n * type PriceData = {\n *   amount: number\n *   variant_id: string\n *   currency_code: string\n * }\n * \n * type Props = {\n *   priceListId: string\n * }\n * \n * const PriceList = ({\n *   priceListId\n * }: Props) => {\n *   const addPrices = useAdminCreatePriceListPrices(priceListId)\n *   // ...\n * \n *   const handleAddPrices = (prices: PriceData[]) => {\n *     addPrices.mutate({\n *       prices\n *     }, {\n *       onSuccess: ({ price_list }) => {\n *         console.log(price_list.prices)\n *       }\n *     })\n *   }\n * \n *   // ...\n * }\n * \n * export default PriceList\n * \n * @customNamespace Hooks.Admin.Price Lists\n * @category Mutations\n */\nexport const useAdminCreatePriceListPrices = (\n  /**\n   * The price list's ID.\n   */\n  id: string,\n  options?: UseMutationOptions<\n    Response<AdminPriceListRes>,\n    Error,\n    AdminPostPriceListPricesPricesReq\n  >\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n  return useMutation(\n    (payload: AdminPostPriceListPricesPricesReq) =>\n      client.admin.priceLists.addPrices(id, payload),\n    buildOptions(\n      queryClient,\n      [\n        adminPriceListKeys.detail(id),\n        adminPriceListKeys.lists(),\n        adminPriceListKeys.detailProducts(id),\n      ],\n      options\n    )\n  )\n}\n\n/**\n * This hook deletes a list of prices in a price list.\n * \n * @example\n * import React from \"react\"\n * import { useAdminDeletePriceListPrices } from \"medusa-react\"\n * \n * type Props = {\n *   priceListId: string\n * }\n * \n * const PriceList = ({\n *   priceListId\n * }: Props) => {\n *   const deletePrices = useAdminDeletePriceListPrices(priceListId)\n *   // ...\n * \n *   const handleDeletePrices = (priceIds: string[]) => {\n *     deletePrices.mutate({\n *       price_ids: priceIds\n *     }, {\n *       onSuccess: ({ ids, deleted, object }) => {\n *         console.log(ids)\n *       }\n *     })\n *   }\n * \n *   // ...\n * }\n * \n * export default PriceList\n * \n * @customNamespace Hooks.Admin.Price Lists\n * @category Mutations\n */\nexport const useAdminDeletePriceListPrices = (\n  /**\n   * The price list's ID.\n   */\n  id: string,\n  options?: UseMutationOptions<\n    Response<AdminPriceListDeleteBatchRes>,\n    Error,\n    AdminDeletePriceListPricesPricesReq\n  >\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n\n  return useMutation(\n    (payload: AdminDeletePriceListPricesPricesReq) =>\n      client.admin.priceLists.deletePrices(id, payload),\n    buildOptions(\n      queryClient,\n      [\n        adminPriceListKeys.detail(id),\n        adminPriceListKeys.lists(),\n        adminPriceListKeys.detailProducts(id),\n      ],\n      options\n    )\n  )\n}\n\n/**\n * This hook deletes all the prices associated with multiple products in a price list.\n * \n * @example\n * import React from \"react\"\n * import { useAdminDeletePriceListProductsPrices } from \"medusa-react\"\n * \n * type Props = {\n *   priceListId: string\n * }\n * \n * const PriceList = ({\n *   priceListId\n * }: Props) => {\n *   const deleteProductsPrices = useAdminDeletePriceListProductsPrices(\n *     priceListId\n *   )\n *   // ...\n * \n *   const handleDeleteProductsPrices = (productIds: string[]) => {\n *     deleteProductsPrices.mutate({\n *       product_ids: productIds\n *     }, {\n *       onSuccess: ({ ids, deleted, object }) => {\n *         console.log(ids)\n *       }\n *     })\n *   }\n * \n *   // ...\n * }\n * \n * export default PriceList\n * \n * @customNamespace Hooks.Admin.Price Lists\n * @category Mutations\n */\nexport const useAdminDeletePriceListProductsPrices = (\n  /**\n   * The price list's ID.\n   */\n  id: string,\n  options?: UseMutationOptions<\n    Response<AdminPriceListDeleteBatchRes>,\n    Error,\n    AdminDeletePriceListsPriceListProductsPricesBatchReq\n  >\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n\n  return useMutation(\n    (payload: AdminDeletePriceListsPriceListProductsPricesBatchReq) =>\n      client.admin.priceLists.deleteProductsPrices(id, payload),\n    buildOptions(\n      queryClient,\n      [adminPriceListKeys.detail(id), adminPriceListKeys.lists()],\n      options\n    )\n  )\n}\n\n/**\n * This hook deletes all the prices related to a specific product in a price list.\n * \n * @example\n * import React from \"react\"\n * import { \n *   useAdminDeletePriceListProductPrices\n * } from \"medusa-react\"\n * \n * type Props = {\n *   priceListId: string\n *   productId: string\n * }\n * \n * const PriceListProduct = ({\n *   priceListId,\n *   productId\n * }: Props) => {\n *   const deleteProductPrices = useAdminDeletePriceListProductPrices(\n *     priceListId,\n *     productId\n *   )\n *   // ...\n * \n *   const handleDeleteProductPrices = () => {\n *     deleteProductPrices.mutate(void 0, {\n *       onSuccess: ({ ids, deleted, object }) => {\n *         console.log(ids)\n *       }\n *     })\n *   }\n * \n *   // ...\n * }\n * \n * export default PriceListProduct\n * \n * @customNamespace Hooks.Admin.Price Lists\n * @category Mutations\n */\nexport const useAdminDeletePriceListProductPrices = (\n  /**\n   * The price list's ID.\n   */\n  id: string,\n  /**\n   * The product's ID.\n   */\n  productId: string,\n  options?: UseMutationOptions<\n    Response<AdminPriceListDeleteProductPricesRes>,\n    Error\n  >\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n\n  return useMutation(\n    () => client.admin.priceLists.deleteProductPrices(id, productId),\n    buildOptions(\n      queryClient,\n      [\n        adminPriceListKeys.detail(id),\n        adminPriceListKeys.lists(),\n        adminProductKeys.detail(productId),\n      ],\n      options\n    )\n  )\n}\n\n/**\n * This hook deletes all the prices related to a specific product variant in a price list.\n * \n * @example\n * import React from \"react\"\n * import { \n *   useAdminDeletePriceListVariantPrices\n * } from \"medusa-react\"\n * \n * type Props = {\n *   priceListId: string\n *   variantId: string\n * }\n * \n * const PriceListVariant = ({\n *   priceListId,\n *   variantId\n * }: Props) => {\n *   const deleteVariantPrices = useAdminDeletePriceListVariantPrices(\n *     priceListId,\n *     variantId\n *   )\n *   // ...\n * \n *   const handleDeleteVariantPrices = () => {\n *     deleteVariantPrices.mutate(void 0, {\n *       onSuccess: ({ ids, deleted, object }) => {\n *         console.log(ids)\n *       }\n *     })\n *   }\n * \n *   // ...\n * }\n * \n * export default PriceListVariant\n * \n * @customNamespace Hooks.Admin.Price Lists\n * @category Mutations\n */\nexport const useAdminDeletePriceListVariantPrices = (\n  /**\n   * The price list's ID.\n   */\n  id: string,\n  /**\n   * The product variant's ID.\n   */\n  variantId: string,\n  options?: UseMutationOptions<\n    Response<AdminPriceListDeleteVariantPricesRes>,\n    Error\n  >\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n\n  return useMutation(\n    () => client.admin.priceLists.deleteVariantPrices(id, variantId),\n    buildOptions(\n      queryClient,\n      [\n        adminPriceListKeys.detail(id),\n        adminPriceListKeys.lists(),\n        adminVariantKeys.detail(variantId),\n      ],\n      options\n    )\n  )\n}\n","import { Response } from \"@medusajs/medusa-js\"\nimport { QueryKey, useQuery } from \"@tanstack/react-query\"\nimport { useMedusa } from \"../../../contexts\"\nimport { UseQueryOptionsWrapper } from \"../../../types\"\n\n/**\n * This hook sends a `GET` request to a custom API Route.\n *\n * @typeParam TQuery - The type of accepted query parameters which defaults to `Record<string, any>`.\n * @typeParam TResponse - The type of response which defaults to `any`.\n * @typeParamDefinition TQuery - The query parameters based on the type specified for `TQuery`.\n * @typeParamDefinition TResponse - The response based on the type specified for `TResponse`.\n *\n * @example\n * import React from \"react\"\n * import { useAdminCustomQuery } from \"medusa-react\"\n * import Post from \"./models/Post\"\n *\n * type RequestQuery = {\n *   title: string\n * }\n *\n * type ResponseData = {\n *   posts: Post\n * }\n *\n * const Custom = () => {\n *   const { data, isLoading } = useAdminCustomQuery\n *     <RequestQuery, ResponseData>(\n *       \"/blog/posts\",\n *       [\"posts\"],\n *       {\n *         title: \"My post\"\n *       }\n *     )\n *\n *   return (\n *     <div>\n *       {isLoading && <span>Loading...</span>}\n *       {data?.posts && !data.posts.length && (\n *         <span>No Post</span>\n *       )}\n *       {data?.posts && data.posts?.length > 0 && (\n *         <ul>\n *           {data.posts.map((post) => (\n *             <li key={post.id}>{post.title}</li>\n *           ))}\n *         </ul>\n *       )}\n *     </div>\n *   )\n * }\n *\n * export default Custom\n *\n * @customNamespace Hooks.Admin.Custom\n * @category Mutations\n */\nexport const useAdminCustomQuery = <\n  TQuery extends Record<string, any>,\n  TResponse = any\n>(\n  /**\n   * The path to the custom endpoint.\n   */\n  path: string,\n  /**\n   * A list of query keys, used to invalidate data.\n   */\n  queryKey: QueryKey,\n  /**\n   * Query parameters to pass to the request.\n   */\n  query?: TQuery,\n  options?: UseQueryOptionsWrapper<\n    Response<TResponse>,\n    Error,\n    (string | TQuery | QueryKey | undefined)[]\n  >\n) => {\n  const { client } = useMedusa()\n\n  const { data, ...rest } = useQuery(\n    [path, query, queryKey],\n    () => client.admin.custom.get<TQuery, TResponse>(path, query),\n    options\n  )\n\n  return { data, ...rest } as const\n}\n","import {\n  AdminDraftOrdersListRes,\n  AdminDraftOrdersRes,\n  AdminGetDraftOrdersParams,\n} from \"@medusajs/medusa\"\nimport { Response } from \"@medusajs/medusa-js\"\nimport { useQuery } from \"@tanstack/react-query\"\nimport { useMedusa } from \"../../../contexts\"\nimport { UseQueryOptionsWrapper } from \"../../../types\"\nimport { queryKeysFactory } from \"../../utils/index\"\n\nconst ADMIN_DRAFT_ORDERS_QUERY_KEY = `admin_draft_orders` as const\n\nexport const adminDraftOrderKeys = queryKeysFactory(\n  ADMIN_DRAFT_ORDERS_QUERY_KEY\n)\n\ntype DraftOrderQueryKeys = typeof adminDraftOrderKeys\n\n/**\n * This hook retrieves an list of Draft Orders. The draft orders can be filtered by parameters such as `query`. The draft orders can also paginated.\n * \n * @example\n * To list draft orders:\n * \n * ```tsx\n * import React from \"react\"\n * import { useAdminDraftOrders } from \"medusa-react\"\n * \n * const DraftOrders = () => {\n *   const { draft_orders, isLoading } = useAdminDraftOrders()\n * \n *   return (\n *     <div>\n *       {isLoading && <span>Loading...</span>}\n *       {draft_orders && !draft_orders.length && (\n *         <span>No Draft Orders</span>\n *       )}\n *       {draft_orders && draft_orders.length > 0 && (\n *         <ul>\n *           {draft_orders.map((order) => (\n *             <li key={order.id}>{order.display_id}</li>\n *           ))}\n *         </ul>\n *       )}\n *     </div>\n *   )\n * }\n * \n * export default DraftOrders\n * ```\n * \n * By default, only the first `50` records are retrieved. You can control pagination by specifying the `limit` and `offset` properties:\n * \n * ```tsx\n * import React from \"react\"\n * import { useAdminDraftOrders } from \"medusa-react\"\n * \n * const DraftOrders = () => {\n *   const { \n *     draft_orders, \n *     limit,\n *     offset,\n *     isLoading\n *   } = useAdminDraftOrders({\n *     limit: 20,\n *     offset: 0\n *   })\n * \n *   return (\n *     <div>\n *       {isLoading && <span>Loading...</span>}\n *       {draft_orders && !draft_orders.length && (\n *         <span>No Draft Orders</span>\n *       )}\n *       {draft_orders && draft_orders.length > 0 && (\n *         <ul>\n *           {draft_orders.map((order) => (\n *             <li key={order.id}>{order.display_id}</li>\n *           ))}\n *         </ul>\n *       )}\n *     </div>\n *   )\n * }\n * \n * export default DraftOrders\n * ```\n * \n * @customNamespace Hooks.Admin.Draft Orders\n * @category Queries\n */\nexport const useAdminDraftOrders = (\n  /**\n   * Filters and pagination configurations to apply on the retrieved draft orders.\n   */\n  query?: AdminGetDraftOrdersParams,\n  options?: UseQueryOptionsWrapper<\n    Response<AdminDraftOrdersListRes>,\n    Error,\n    ReturnType<DraftOrderQueryKeys[\"list\"]>\n  >\n) => {\n  const { client } = useMedusa()\n  const { data, ...rest } = useQuery(\n    adminDraftOrderKeys.list(query),\n    () => client.admin.draftOrders.list(query),\n    options\n  )\n  return { ...data, ...rest } as const\n}\n\n/**\n * This hook retrieves a Draft Order's details.\n * \n * @example\n * import React from \"react\"\n * import { useAdminDraftOrder } from \"medusa-react\"\n * \n * type Props = {\n *   draftOrderId: string\n * }\n * \n * const DraftOrder = ({ draftOrderId }: Props) => {\n *   const { \n *     draft_order, \n *     isLoading, \n *   } = useAdminDraftOrder(draftOrderId)\n * \n *   return (\n *     <div>\n *       {isLoading && <span>Loading...</span>}\n *       {draft_order && <span>{draft_order.display_id}</span>}\n *       \n *     </div>\n *   )\n * }\n * \n * export default DraftOrder\n * \n * @customNamespace Hooks.Admin.Draft Orders\n * @category Queries\n */\nexport const useAdminDraftOrder = (\n  /**\n   * The draft order's ID.\n   */\n  id: string,\n  options?: UseQueryOptionsWrapper<\n    Response<AdminDraftOrdersRes>,\n    Error,\n    ReturnType<DraftOrderQueryKeys[\"detail\"]>\n  >\n) => {\n  const { client } = useMedusa()\n  const { data, ...rest } = useQuery(\n    adminDraftOrderKeys.detail(id),\n    () => client.admin.draftOrders.retrieve(id),\n    options\n  )\n  return { ...data, ...rest } as const\n}\n","import {\n  AdminDraftOrdersDeleteRes,\n  AdminDraftOrdersRes,\n  AdminPostDraftOrdersDraftOrderLineItemsItemReq,\n  AdminPostDraftOrdersDraftOrderLineItemsReq,\n  AdminPostDraftOrdersDraftOrderRegisterPaymentRes,\n  AdminPostDraftOrdersDraftOrderReq,\n  AdminPostDraftOrdersReq,\n} from \"@medusajs/medusa\"\nimport { Response } from \"@medusajs/medusa-js\"\nimport {\n  useMutation,\n  UseMutationOptions,\n  useQueryClient,\n} from \"@tanstack/react-query\"\nimport { useMedusa } from \"../../../contexts/medusa\"\nimport { buildOptions } from \"../../utils/buildOptions\"\nimport { adminDraftOrderKeys } from \"./queries\"\n\n/**\n * This hook creates a Draft Order. A draft order is not transformed into an order until payment is captured.\n * \n * @example\n * import React from \"react\"\n * import { useAdminCreateDraftOrder } from \"medusa-react\"\n * \n * type DraftOrderData = {\n *   email: string\n *   region_id: string\n *   items: {\n *     quantity: number,\n *     variant_id: string\n *   }[]\n *   shipping_methods: {\n *     option_id: string\n *     price: number\n *   }[]\n * }\n * \n * const CreateDraftOrder = () => {\n *   const createDraftOrder = useAdminCreateDraftOrder()\n *   // ...\n * \n *   const handleCreate = (data: DraftOrderData) => {\n *     createDraftOrder.mutate(data, {\n *       onSuccess: ({ draft_order }) => {\n *         console.log(draft_order.id)\n *       }\n *     })\n *   }\n * \n *   // ...\n * }\n * \n * export default CreateDraftOrder\n * \n * @customNamespace Hooks.Admin.Draft Orders\n * @category Mutations\n */\nexport const useAdminCreateDraftOrder = (\n  options?: UseMutationOptions<\n    Response<AdminDraftOrdersRes>,\n    Error,\n    AdminPostDraftOrdersReq\n  >\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n  return useMutation(\n    (payload: AdminPostDraftOrdersReq) =>\n      client.admin.draftOrders.create(payload),\n    buildOptions(queryClient, adminDraftOrderKeys.lists(), options)\n  )\n}\n\n/**\n * This hook updates a Draft Order's details.\n * \n * @example\n * import React from \"react\"\n * import { useAdminUpdateDraftOrder } from \"medusa-react\"\n * \n * type Props = {\n *   draftOrderId: string\n * }\n * \n * const DraftOrder = ({ draftOrderId }: Props) => {\n *   const updateDraftOrder = useAdminUpdateDraftOrder(\n *     draftOrderId\n *   )\n *   // ...\n * \n *   const handleUpdate = (email: string) => {\n *     updateDraftOrder.mutate({\n *       email,\n *     }, {\n *       onSuccess: ({ draft_order }) => {\n *         console.log(draft_order.id)\n *       }\n *     })\n *   }\n * \n *   // ...\n * }\n * \n * export default DraftOrder\n * \n * @customNamespace Hooks.Admin.Draft Orders\n * @category Mutations\n */\nexport const useAdminUpdateDraftOrder = (\n  /**\n   * The draft order's ID.\n   */\n  id: string,\n  options?: UseMutationOptions<\n    Response<AdminDraftOrdersRes>,\n    Error,\n    AdminPostDraftOrdersDraftOrderReq\n  >\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n  return useMutation(\n    (payload: AdminPostDraftOrdersDraftOrderReq) =>\n      client.admin.draftOrders.update(id, payload),\n    buildOptions(\n      queryClient,\n      [adminDraftOrderKeys.detail(id), adminDraftOrderKeys.lists()],\n      options\n    )\n  )\n}\n\n/**\n * This hook deletes a Draft Order.\n * \n * @example\n * import React from \"react\"\n * import { useAdminDeleteDraftOrder } from \"medusa-react\"\n * \n * type Props = {\n *   draftOrderId: string\n * }\n * \n * const DraftOrder = ({ draftOrderId }: Props) => {\n *   const deleteDraftOrder = useAdminDeleteDraftOrder(\n *     draftOrderId\n *   )\n *   // ...\n * \n *   const handleDelete = () => {\n *     deleteDraftOrder.mutate(void 0, {\n *       onSuccess: ({ id, object, deleted }) => {\n *         console.log(id)\n *       }\n *     })\n *   }\n * \n *   // ...\n * }\n * \n * export default DraftOrder\n * \n * @customNamespace Hooks.Admin.Draft Orders\n * @category Mutations\n */\nexport const useAdminDeleteDraftOrder = (\n  /**\n   * The draft order's ID.\n   */\n  id: string,\n  options?: UseMutationOptions<Response<AdminDraftOrdersDeleteRes>, Error, void>\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n  return useMutation(\n    () => client.admin.draftOrders.delete(id),\n    buildOptions(\n      queryClient,\n      [adminDraftOrderKeys.detail(id), adminDraftOrderKeys.lists()],\n      options\n    )\n  )\n}\n\n/**\n * This hook capture the draft order's payment. This will also set the draft order's status to `completed` and create an order from the draft order. The payment is captured through Medusa's system payment,\n * which is manual payment that isn't integrated with any third-party payment provider. It is assumed that the payment capturing is handled manually by the admin.\n * \n * @example\n * import React from \"react\"\n * import { useAdminDraftOrderRegisterPayment } from \"medusa-react\"\n * \n * type Props = {\n *   draftOrderId: string\n * }\n * \n * const DraftOrder = ({ draftOrderId }: Props) => {\n *   const registerPayment = useAdminDraftOrderRegisterPayment(\n *     draftOrderId\n *   )\n *   // ...\n * \n *   const handlePayment = () => {\n *     registerPayment.mutate(void 0, {\n *       onSuccess: ({ order }) => {\n *         console.log(order.id)\n *       }\n *     })\n *   }\n * \n *   // ...\n * }\n * \n * export default DraftOrder\n * \n * @customNamespace Hooks.Admin.Draft Orders\n * @category Mutations\n */\nexport const useAdminDraftOrderRegisterPayment = (\n  /**\n   * The draft order's ID.\n   */\n  id: string,\n  options?: UseMutationOptions<\n    Response<AdminPostDraftOrdersDraftOrderRegisterPaymentRes>,\n    Error,\n    void\n  >\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n  return useMutation(\n    () => client.admin.draftOrders.markPaid(id),\n    buildOptions(queryClient, adminDraftOrderKeys.detail(id), options)\n  )\n}\n\n/**\n * This hook creates a Line Item in the Draft Order.\n * \n * @example\n * import React from \"react\"\n * import { useAdminDraftOrderAddLineItem } from \"medusa-react\"\n * \n * type Props = {\n *   draftOrderId: string\n * }\n * \n * const DraftOrder = ({ draftOrderId }: Props) => {\n *   const addLineItem = useAdminDraftOrderAddLineItem(\n *     draftOrderId\n *   )\n *   // ...\n * \n *   const handleAdd = (quantity: number) => {\n *     addLineItem.mutate({\n *       quantity,\n *     }, {\n *       onSuccess: ({ draft_order }) => {\n *         console.log(draft_order.cart)\n *       }\n *     })\n *   }\n * \n *   // ...\n * }\n * \n * export default DraftOrder\n * \n * @customNamespace Hooks.Admin.Draft Orders\n * @category Mutations\n */\nexport const useAdminDraftOrderAddLineItem = (\n  /**\n   * The draft order's ID.\n   */\n  id: string,\n  options?: UseMutationOptions<\n    Response<AdminDraftOrdersRes>,\n    Error,\n    AdminPostDraftOrdersDraftOrderLineItemsReq\n  >\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n  return useMutation(\n    (payload: AdminPostDraftOrdersDraftOrderLineItemsReq) =>\n      client.admin.draftOrders.addLineItem(id, payload),\n    buildOptions(queryClient, adminDraftOrderKeys.detail(id), options)\n  )\n}\n\n/**\n * This hook deletes a Line Item from a Draft Order.\n * \n * @typeParamDefinition string - The ID of the line item to remove.\n * \n * @example\n * import React from \"react\"\n * import { useAdminDraftOrderRemoveLineItem } from \"medusa-react\"\n * \n * type Props = {\n *   draftOrderId: string\n * }\n * \n * const DraftOrder = ({ draftOrderId }: Props) => {\n *   const deleteLineItem = useAdminDraftOrderRemoveLineItem(\n *     draftOrderId\n *   )\n *   // ...\n * \n *   const handleDelete = (itemId: string) => {\n *     deleteLineItem.mutate(itemId, {\n *       onSuccess: ({ draft_order }) => {\n *         console.log(draft_order.cart)\n *       }\n *     })\n *   }\n * \n *   // ...\n * }\n * \n * export default DraftOrder\n * \n * @customNamespace Hooks.Admin.Draft Orders\n * @category Mutations\n */\nexport const useAdminDraftOrderRemoveLineItem = (\n  /**\n   * The draft order's ID.\n   */\n  id: string,\n  options?: UseMutationOptions<Response<AdminDraftOrdersRes>, Error, string>\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n  return useMutation(\n    (itemId: string) => client.admin.draftOrders.removeLineItem(id, itemId),\n    buildOptions(queryClient, adminDraftOrderKeys.detail(id), options)\n  )\n}\n\n/**\n * The details to update of the line item.\n */\nexport type AdminDraftOrderUpdateLineItemReq = AdminPostDraftOrdersDraftOrderLineItemsItemReq & { \n  /**\n   * The line item's ID to update.\n   */\n  item_id: string\n}\n\n/**\n * This hook updates a Line Item in a Draft Order.\n * \n * @example\n * import React from \"react\"\n * import { useAdminDraftOrderUpdateLineItem } from \"medusa-react\"\n * \n * type Props = {\n *   draftOrderId: string\n * }\n * \n * const DraftOrder = ({ draftOrderId }: Props) => {\n *   const updateLineItem = useAdminDraftOrderUpdateLineItem(\n *     draftOrderId\n *   )\n *   // ...\n * \n *   const handleUpdate = (\n *     itemId: string,\n *     quantity: number\n *   ) => {\n *     updateLineItem.mutate({\n *       item_id: itemId,\n *       quantity,\n *     })\n *   }\n * \n *   // ...\n * }\n * \n * export default DraftOrder\n * \n * @customNamespace Hooks.Admin.Draft Orders\n * @category Mutations\n */\nexport const useAdminDraftOrderUpdateLineItem = (\n  /**\n   * The draft order's ID.\n   */\n  id: string,\n  options?: UseMutationOptions<\n    Response<AdminDraftOrdersRes>,\n    Error,\n    AdminDraftOrderUpdateLineItemReq\n  >\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n  return useMutation(\n    ({\n      item_id,\n      ...payload\n    }: AdminDraftOrderUpdateLineItemReq) =>\n      client.admin.draftOrders.updateLineItem(id, item_id, payload),\n    buildOptions(queryClient, adminDraftOrderKeys.detail(id), options)\n  )\n}\n","import {\n  AdminGetInventoryItemsItemLocationLevelsParams,\n  AdminGetInventoryItemsParams,\n  AdminGetStockLocationsParams,\n  AdminInventoryItemsListWithVariantsAndLocationLevelsRes,\n  AdminInventoryItemsLocationLevelsRes,\n  AdminInventoryItemsRes,\n} from \"@medusajs/medusa\"\n\nimport { Response } from \"@medusajs/medusa-js\"\nimport { UseQueryOptionsWrapper } from \"../../../types\"\nimport { queryKeysFactory } from \"../../utils\"\nimport { useMedusa } from \"../../../contexts\"\nimport { useQuery } from \"@tanstack/react-query\"\n\nconst ADMIN_INVENTORY_ITEMS_QUERY_KEY = `admin_inventory_items` as const\n\nexport const adminInventoryItemsKeys = queryKeysFactory(\n  ADMIN_INVENTORY_ITEMS_QUERY_KEY\n)\n\ntype InventoryItemsQueryKeys = typeof adminInventoryItemsKeys\n\n/**\n * This hook retrieves a list of inventory items. The inventory items can be filtered by fields such as `q` or `location_id` passed in the `query` parameter.\n * The inventory items can also be paginated.\n * \n * @example\n * To list inventory items:\n * \n * ```tsx\n * import React from \"react\"\n * import { useAdminInventoryItems } from \"medusa-react\"\n * \n * function InventoryItems() {\n *   const { \n *     inventory_items,\n *     isLoading \n *   } = useAdminInventoryItems()\n * \n *   return (\n *     <div>\n *       {isLoading && <span>Loading...</span>}\n *       {inventory_items && !inventory_items.length && (\n *         <span>No Items</span>\n *       )}\n *       {inventory_items && inventory_items.length > 0 && (\n *         <ul>\n *           {inventory_items.map(\n *             (item) => (\n *               <li key={item.id}>{item.id}</li>\n *             )\n *           )}\n *         </ul>\n *       )}\n *     </div>\n *   )\n * }\n * \n * export default InventoryItems\n * ```\n * \n * By default, only the first `20` records are retrieved. You can control pagination by specifying the `limit` and `offset` properties:\n * \n * ```tsx\n * import React from \"react\"\n * import { useAdminInventoryItems } from \"medusa-react\"\n * \n * function InventoryItems() {\n *   const { \n *     inventory_items,\n *     limit,\n *     offset,\n *     isLoading\n *   } = useAdminInventoryItems({\n *     limit: 10,\n *     offset: 0\n *   })\n * \n *   return (\n *     <div>\n *       {isLoading && <span>Loading...</span>}\n *       {inventory_items && !inventory_items.length && (\n *         <span>No Items</span>\n *       )}\n *       {inventory_items && inventory_items.length > 0 && (\n *         <ul>\n *           {inventory_items.map(\n *             (item) => (\n *               <li key={item.id}>{item.id}</li>\n *             )\n *           )}\n *         </ul>\n *       )}\n *     </div>\n *   )\n * }\n * \n * export default InventoryItems\n * ```\n * \n * @customNamespace Hooks.Admin.Inventory Items\n * @category Queries\n */\nexport const useAdminInventoryItems = (\n  /**\n   * Filters and pagination configurations applied on the retrieved inventory items.\n   */\n  query?: AdminGetInventoryItemsParams,\n  options?: UseQueryOptionsWrapper<\n    Response<AdminInventoryItemsListWithVariantsAndLocationLevelsRes>,\n    Error,\n    ReturnType<InventoryItemsQueryKeys[\"list\"]>\n  >\n) => {\n  const { client } = useMedusa()\n\n  const { data, ...rest } = useQuery(\n    adminInventoryItemsKeys.list(query),\n    () => client.admin.inventoryItems.list(query),\n    { ...options }\n  )\n\n  return { ...data, ...rest } as const\n}\n\n/**\n * This hook retrieves an Inventory Item's details.\n * \n * @example\n * import React from \"react\"\n * import { useAdminInventoryItem } from \"medusa-react\"\n * \n * type Props = {\n *   inventoryItemId: string\n * }\n * \n * const InventoryItem = ({ inventoryItemId }: Props) => {\n *   const { \n *     inventory_item,\n *     isLoading\n *   } = useAdminInventoryItem(inventoryItemId)\n * \n *   return (\n *     <div>\n *       {isLoading && <span>Loading...</span>}\n *       {inventory_item && (\n *         <span>{inventory_item.sku}</span>\n *       )}\n *     </div>\n *   )\n * }\n * \n * export default InventoryItem\n * \n * @customNamespace Hooks.Admin.Inventory Items\n * @category Queries\n */\nexport const useAdminInventoryItem = (\n  /**\n   * The inventory item's ID.\n   */\n  inventoryItemId: string,\n  /**\n   * Configurations applied on the retrieved inventory item.\n   */\n  query?: AdminGetStockLocationsParams,\n  options?: UseQueryOptionsWrapper<\n    Response<AdminInventoryItemsRes>,\n    Error,\n    ReturnType<InventoryItemsQueryKeys[\"detail\"]>\n  >\n) => {\n  const { client } = useMedusa()\n\n  const { data, ...rest } = useQuery(\n    adminInventoryItemsKeys.detail(inventoryItemId),\n    () => client.admin.inventoryItems.retrieve(inventoryItemId, query),\n    { ...options }\n  )\n\n  return { ...data, ...rest } as const\n}\n\n/**\n * This hook retrieves a list of inventory levels of an inventory item. The inventory levels can be filtered by fields \n * such as `location_id` passed in the `query` parameter.\n * \n * @example\n * import React from \"react\"\n * import { \n *   useAdminInventoryItemLocationLevels,\n * } from \"medusa-react\"\n * \n * type Props = {\n *   inventoryItemId: string\n * }\n * \n * const InventoryItem = ({ inventoryItemId }: Props) => {\n *   const { \n *     inventory_item,\n *     isLoading, \n *   } = useAdminInventoryItemLocationLevels(inventoryItemId)\n * \n *   return (\n *     <div>\n *       {isLoading && <span>Loading...</span>}\n *       {inventory_item && (\n *         <ul>\n *           {inventory_item.location_levels.map((level) => (\n *             <span key={level.id}>{level.stocked_quantity}</span>\n *           ))}\n *         </ul>\n *       )}\n *     </div>\n *   )\n * }\n * \n * export default InventoryItem\n * \n * @customNamespace Hooks.Admin.Inventory Items\n * @category Queries\n */\nexport const useAdminInventoryItemLocationLevels = (\n  /**\n   * The ID of the inventory item that the location levels belong to.\n   */\n  inventoryItemId: string,\n  /**\n   * Filters to apply on the retrieved location levels.\n   */\n  query?: AdminGetInventoryItemsItemLocationLevelsParams,\n  options?: UseQueryOptionsWrapper<\n    Response<AdminInventoryItemsLocationLevelsRes>,\n    Error,\n    ReturnType<InventoryItemsQueryKeys[\"detail\"]>\n  >\n) => {\n  const { client } = useMedusa()\n\n  const { data, ...rest } = useQuery(\n    adminInventoryItemsKeys.detail(inventoryItemId),\n    () =>\n      client.admin.inventoryItems.listLocationLevels(inventoryItemId, query),\n    { ...options }\n  )\n\n  return { ...data, ...rest } as const\n}\n","import {\n  AdminInventoryItemsDeleteRes,\n  AdminInventoryItemsRes,\n  AdminPostInventoryItemsInventoryItemReq,\n  AdminPostInventoryItemsItemLocationLevelsLevelReq,\n  AdminPostInventoryItemsItemLocationLevelsReq,\n  AdminPostInventoryItemsReq,\n  AdminPostInventoryItemsParams\n} from \"@medusajs/medusa\"\nimport { Response } from \"@medusajs/medusa-js\"\nimport {\n  useMutation,\n  UseMutationOptions,\n  useQueryClient,\n} from \"@tanstack/react-query\"\nimport { useMedusa } from \"../../../contexts\"\nimport { buildOptions } from \"../../utils/buildOptions\"\nimport { adminInventoryItemsKeys } from \"./queries\"\n\n/**\n * This hook creates an Inventory Item for a product variant.\n * \n * @example\n * import React from \"react\"\n * import { useAdminCreateInventoryItem } from \"medusa-react\"\n * \n * const CreateInventoryItem = () => {\n *   const createInventoryItem = useAdminCreateInventoryItem()\n *   // ...\n * \n *   const handleCreate = (variantId: string) => {\n *     createInventoryItem.mutate({\n *       variant_id: variantId,\n *     }, {\n *       onSuccess: ({ inventory_item }) => {\n *         console.log(inventory_item.id)\n *       }\n *     })\n *   }\n * \n *   // ...\n * }\n * \n * export default CreateInventoryItem\n * \n * @customNamespace Hooks.Admin.Inventory Items\n * @category Mutations\n */\nexport const useAdminCreateInventoryItem = (\n  options?: UseMutationOptions<\n    Response<AdminInventoryItemsRes>,\n    Error,\n    AdminPostInventoryItemsReq\n  >\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n\n  return useMutation(\n    (payload: AdminPostInventoryItemsReq, query?: AdminPostInventoryItemsParams) =>\n      client.admin.inventoryItems.create(payload, query),\n    buildOptions(\n      queryClient,\n      [adminInventoryItemsKeys.lists()],\n      options\n    )\n  )\n}\n\n\n/**\n * This hook updates an Inventory Item's details.\n * \n * @example\n * import React from \"react\"\n * import { useAdminUpdateInventoryItem } from \"medusa-react\"\n * \n * type Props = {\n *   inventoryItemId: string\n * }\n * \n * const InventoryItem = ({ inventoryItemId }: Props) => {\n *   const updateInventoryItem = useAdminUpdateInventoryItem(\n *     inventoryItemId\n *   )\n *   // ...\n * \n *   const handleUpdate = (origin_country: string) => {\n *     updateInventoryItem.mutate({\n *       origin_country,\n *     }, {\n *       onSuccess: ({ inventory_item }) => {\n *         console.log(inventory_item.origin_country)\n *       }\n *     })\n *   }\n * \n *   // ...\n * }\n * \n * export default InventoryItem\n * \n * @customNamespace Hooks.Admin.Inventory Items\n * @category Mutations\n */\nexport const useAdminUpdateInventoryItem = (\n  /**\n   * The inventory item's ID.\n   */\n  inventoryItemId: string,\n  options?: UseMutationOptions<\n    Response<AdminInventoryItemsRes>,\n    Error,\n    AdminPostInventoryItemsInventoryItemReq\n  >\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n\n  return useMutation(\n    (payload: AdminPostInventoryItemsInventoryItemReq) =>\n      client.admin.inventoryItems.update(inventoryItemId, payload),\n    buildOptions(\n      queryClient,\n      [adminInventoryItemsKeys.lists(), adminInventoryItemsKeys.detail(inventoryItemId)],\n      options\n    )\n  )\n}\n\n/**\n * This hook deletes an Inventory Item. This does not delete the associated product variant.\n * \n * @example\n * import React from \"react\"\n * import { useAdminDeleteInventoryItem } from \"medusa-react\"\n * \n * type Props = {\n *   inventoryItemId: string\n * }\n * \n * const InventoryItem = ({ inventoryItemId }: Props) => {\n *   const deleteInventoryItem = useAdminDeleteInventoryItem(\n *     inventoryItemId\n *   )\n *   // ...\n * \n *   const handleDelete = () => {\n *     deleteInventoryItem.mutate()\n *   }\n * \n *   // ...\n * }\n * \n * export default InventoryItem\n * \n * @customNamespace Hooks.Admin.Inventory Items\n * @category Mutations\n */\nexport const useAdminDeleteInventoryItem = (\n  /**\n   * The inventory item's ID.\n   */\n  inventoryItemId: string,\n  options?: UseMutationOptions<\n    Response<AdminInventoryItemsDeleteRes>,\n    Error,\n    void\n  >\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n\n  return useMutation(\n    () => client.admin.inventoryItems.delete(inventoryItemId),\n    buildOptions(\n      queryClient,\n      [adminInventoryItemsKeys.lists(), adminInventoryItemsKeys.detail(inventoryItemId)],\n      options\n    )\n  )\n}\n\nexport type AdminUpdateLocationLevelReq = AdminPostInventoryItemsItemLocationLevelsLevelReq & {\n  /**\n   * The ID of the location level to update.\n   */\n  stockLocationId: string\n}\n\n/**\n * This hook updates a location level's details for a given inventory item.\n * \n * @example\n * import React from \"react\"\n * import { useAdminUpdateLocationLevel } from \"medusa-react\"\n * \n * type Props = {\n *   inventoryItemId: string\n * }\n * \n * const InventoryItem = ({ inventoryItemId }: Props) => {\n *   const updateLocationLevel = useAdminUpdateLocationLevel(\n *     inventoryItemId\n *   )\n *   // ...\n * \n *   const handleUpdate = (\n *     stockLocationId: string,\n *     stockedQuantity: number\n *   ) => {\n *     updateLocationLevel.mutate({\n *       stockLocationId,\n *       stocked_quantity: stockedQuantity,\n *     }, {\n *       onSuccess: ({ inventory_item }) => {\n *         console.log(inventory_item.id)\n *       }\n *     })\n *   }\n * \n *   // ...\n * }\n * \n * export default InventoryItem\n * \n * @customNamespace Hooks.Admin.Inventory Items\n * @category Mutations\n */\nexport const useAdminUpdateLocationLevel = (\n  /**\n   * The inventory item's ID.\n   */\n  inventoryItemId: string,\n  options?: UseMutationOptions<\n    Response<AdminInventoryItemsRes>,\n    Error,\n    AdminUpdateLocationLevelReq\n  >\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n\n  return useMutation(\n    (\n      payload: AdminUpdateLocationLevelReq\n    ) =>\n      client.admin.inventoryItems.updateLocationLevel(\n        inventoryItemId,\n        payload.stockLocationId,\n        {\n          incoming_quantity: payload.incoming_quantity,\n          stocked_quantity: payload.stocked_quantity,\n        }\n      ),\n    buildOptions(\n      queryClient,\n      [\n        adminInventoryItemsKeys.detail(inventoryItemId),\n        adminInventoryItemsKeys.lists(),\n      ],\n      options\n    )\n  )\n}\n\n/**\n * This hook deletes a location level of an Inventory Item.\n * \n * @typeParamDefinition string - The ID of the location level to delete.\n * \n * @example\n * import React from \"react\"\n * import { useAdminDeleteLocationLevel } from \"medusa-react\"\n * \n * type Props = {\n *   inventoryItemId: string\n * }\n * \n * const InventoryItem = ({ inventoryItemId }: Props) => {\n *   const deleteLocationLevel = useAdminDeleteLocationLevel(\n *     inventoryItemId\n *   )\n *   // ...\n * \n *   const handleDelete = (\n *     locationId: string\n *   ) => {\n *     deleteLocationLevel.mutate(locationId)\n *   }\n * \n *   // ...\n * }\n * \n * export default InventoryItem\n * \n * @customNamespace Hooks.Admin.Inventory Items\n * @category Mutations\n */\nexport const useAdminDeleteLocationLevel = (\n  /**\n   * The inventory item's ID.\n   */\n  inventoryItemId: string,\n  options?: UseMutationOptions<Response<AdminInventoryItemsRes>, Error, string>\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n\n  return useMutation(\n    (stockLocationId: string) =>\n      client.admin.inventoryItems.deleteLocationLevel(\n        inventoryItemId,\n        stockLocationId\n      ),\n    buildOptions(\n      queryClient,\n      [\n        adminInventoryItemsKeys.detail(inventoryItemId),\n        adminInventoryItemsKeys.lists(),\n      ],\n      options\n    )\n  )\n}\n\n/**\n * This hook creates a Location Level for a given Inventory Item.\n * \n * @example\n * import React from \"react\"\n * import { useAdminCreateLocationLevel } from \"medusa-react\"\n * \n * type Props = {\n *   inventoryItemId: string\n * }\n * \n * const InventoryItem = ({ inventoryItemId }: Props) => {\n *   const createLocationLevel = useAdminCreateLocationLevel(\n *     inventoryItemId\n *   )\n *   // ...\n * \n *   const handleCreateLocationLevel = (\n *     locationId: string,\n *     stockedQuantity: number\n *   ) => {\n *     createLocationLevel.mutate({\n *       location_id: locationId,\n *       stocked_quantity: stockedQuantity,\n *     }, {\n *       onSuccess: ({ inventory_item }) => {\n *         console.log(inventory_item.id)\n *       }\n *     })\n *   }\n * \n *   // ...\n * }\n * \n * export default InventoryItem\n * \n * @customNamespace Hooks.Admin.Inventory Items\n * @category Mutations\n */\nexport const useAdminCreateLocationLevel = (\n  /**\n   * The inventory item's ID.\n   */\n  inventoryItemId: string,\n  options?: UseMutationOptions<\n    Response<AdminInventoryItemsRes>,\n    Error,\n    AdminPostInventoryItemsItemLocationLevelsReq\n  >\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n\n  return useMutation(\n    (payload: AdminPostInventoryItemsItemLocationLevelsReq) =>\n      client.admin.inventoryItems.createLocationLevel(inventoryItemId, payload),\n    buildOptions(\n      queryClient,\n      [\n        adminInventoryItemsKeys.detail(inventoryItemId),\n        adminInventoryItemsKeys.lists(),\n      ],\n      options\n    )\n  )\n}\n","import { AdminListInvitesRes } from \"@medusajs/medusa\"\nimport { Response } from \"@medusajs/medusa-js\"\nimport { useQuery } from \"@tanstack/react-query\"\nimport { useMedusa } from \"../../../contexts\"\nimport { UseQueryOptionsWrapper } from \"../../../types\"\nimport { queryKeysFactory } from \"../../utils/index\"\n\nconst ADMIN_INVITES_QUERY_KEY = `admin_invites` as const\n\nexport const adminInviteKeys = queryKeysFactory(ADMIN_INVITES_QUERY_KEY)\n\ntype InviteQueryKeys = typeof adminInviteKeys\n\n/**\n * This hook retrieves a list of invites.\n * \n * @example\n * import React from \"react\"\n * import { useAdminInvites } from \"medusa-react\"\n * \n * const Invites = () => {\n *   const { invites, isLoading } = useAdminInvites()\n * \n *   return (\n *     <div>\n *       {isLoading && <span>Loading...</span>}\n *       {invites && !invites.length && (\n *         <span>No Invites</span>)\n *       }\n *       {invites && invites.length > 0 && (\n *         <ul>\n *           {invites.map((invite) => (\n *             <li key={invite.id}>{invite.user_email}</li>\n *           ))}\n *         </ul>\n *       )}\n *     </div>\n *   )\n * }\n * \n * export default Invites\n * \n * @customNamespace Hooks.Admin.Invites\n * @category Queries\n */\nexport const useAdminInvites = (\n  options?: UseQueryOptionsWrapper<\n    Response<AdminListInvitesRes>,\n    Error,\n    ReturnType<InviteQueryKeys[\"lists\"]>\n  >\n) => {\n  const { client } = useMedusa()\n  const { data, ...rest } = useQuery(\n    adminInviteKeys.lists(),\n    () => client.admin.invites.list(),\n    options\n  )\n  return { ...data, ...rest } as const\n}\n","import {\n  AdminInviteDeleteRes,\n  AdminPostInvitesInviteAcceptReq,\n} from \"@medusajs/medusa\"\nimport { AdminPostInvitesPayload, Response } from \"@medusajs/medusa-js\"\nimport {\n  useMutation,\n  UseMutationOptions,\n  useQueryClient,\n} from \"@tanstack/react-query\"\nimport { useMedusa } from \"../../../contexts/medusa\"\nimport { buildOptions } from \"../../utils/buildOptions\"\nimport { adminInviteKeys } from \"./queries\"\n\n/**\n * This hook accepts an Invite. This will also delete the invite and create a new user that can log in and perform admin functionalities. \n * The user will have the email associated with the invite, and the password provided in the mutation function's parameter.\n * \n * @example\n * import React from \"react\"\n * import { useAdminAcceptInvite } from \"medusa-react\"\n * \n * const AcceptInvite = () => {\n *   const acceptInvite = useAdminAcceptInvite()\n *   // ...\n * \n *   const handleAccept = (\n *     token: string,\n *     firstName: string,\n *     lastName: string,\n *     password: string\n *   ) => {\n *     acceptInvite.mutate({\n *       token,\n *       user: {\n *         first_name: firstName,\n *         last_name: lastName,\n *         password,\n *       },\n *     }, {\n *       onSuccess: () => {\n *         // invite accepted successfully.\n *       }\n *     })\n *   }\n * \n *   // ...\n * }\n * \n * export default AcceptInvite\n * \n * @customNamespace Hooks.Admin.Invites\n * @category Mutations\n */\nexport const useAdminAcceptInvite = (\n  options?: UseMutationOptions<\n    Response<void>,\n    Error,\n    AdminPostInvitesInviteAcceptReq\n  >\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n\n  return useMutation(\n    (payload: AdminPostInvitesInviteAcceptReq) =>\n      client.admin.invites.accept(payload),\n    buildOptions(queryClient, adminInviteKeys.lists(), options)\n  )\n}\n\n/**\n * This hook resends an invite. This renews the expiry date by seven days and generates a new token for the invite. It also triggers the `invite.created` event, \n * so if you have a Notification Provider installed that handles this event, a notification should be sent to the email associated with the \n * invite to allow them to accept the invite.\n * \n * @example\n * import React from \"react\"\n * import { useAdminResendInvite } from \"medusa-react\"\n * \n * type Props = {\n *   inviteId: string\n * }\n * \n * const ResendInvite = ({ inviteId }: Props) => {\n *   const resendInvite = useAdminResendInvite(inviteId)\n *   // ...\n * \n *   const handleResend = () => {\n *     resendInvite.mutate(void 0, {\n *       onSuccess: () => {\n *         // invite resent successfully\n *       }\n *     })\n *   }\n * \n *   // ...\n * }\n * \n * export default ResendInvite\n * \n * @customNamespace Hooks.Admin.Invites\n * @category Mutations\n */\nexport const useAdminResendInvite = (\n  /**\n   * The invite's ID.\n   */\n  id: string,\n  options?: UseMutationOptions\n) => {\n  const { client } = useMedusa()\n  return useMutation(() => client.admin.invites.resend(id), options)\n}\n\nexport const useAdminCreateInvite = (\n  options?: UseMutationOptions<Response<void>, Error, AdminPostInvitesPayload>\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n\n  return useMutation(\n    (payload: AdminPostInvitesPayload) => client.admin.invites.create(payload),\n    buildOptions(queryClient, adminInviteKeys.lists(), options)\n  )\n}\n\n/**\n * This hook deletes an invite. Only invites that weren't accepted can be deleted.\n * \n * @example\n * import React from \"react\"\n * import { useAdminDeleteInvite } from \"medusa-react\"\n * \n * type Props = {\n *   inviteId: string\n * }\n * \n * const DeleteInvite = ({ inviteId }: Props) => {\n *   const deleteInvite = useAdminDeleteInvite(inviteId)\n *   // ...\n * \n *   const handleDelete = () => {\n *     deleteInvite.mutate(void 0, {\n *       onSuccess: ({ id, object, deleted }) => {\n *         console.log(id)\n *       }\n *     })\n *   }\n * \n *   // ...\n * }\n * \n * export default Invite\n * \n * @customNamespace Hooks.Admin.Invites\n * @category Mutations\n */\nexport const useAdminDeleteInvite = (\n  /**\n   * The invite's ID.\n   */\n  id: string,\n  options?: UseMutationOptions<Response<AdminInviteDeleteRes>, Error, void>\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n\n  return useMutation(\n    () => client.admin.invites.delete(id),\n    buildOptions(\n      queryClient,\n      [adminInviteKeys.lists(), adminInviteKeys.detail(id)],\n      options\n    )\n  )\n}\n","import {\n  AdminGetNotesParams,\n  AdminNotesListRes,\n  AdminNotesRes,\n} from \"@medusajs/medusa\"\nimport { Response } from \"@medusajs/medusa-js\"\nimport { useQuery } from \"@tanstack/react-query\"\nimport { useMedusa } from \"../../../contexts\"\nimport { UseQueryOptionsWrapper } from \"../../../types\"\nimport { queryKeysFactory } from \"../../utils/index\"\n\nconst ADMIN_NOTE_QUERY_KEY = `admin_notes` as const\n\nexport const adminNoteKeys = queryKeysFactory(ADMIN_NOTE_QUERY_KEY)\n\ntype NoteQueryKeys = typeof adminNoteKeys\n\n/**\n * This hook retrieves a list of notes. The notes can be filtered by fields such as `resource_id` passed in \n * the `query` parameter. The notes can also be paginated.\n * \n * @example\n * To list notes:\n * \n * ```tsx\n * import React from \"react\"\n * import { useAdminNotes } from \"medusa-react\"\n * \n * const Notes = () => {\n *   const { notes, isLoading } = useAdminNotes()\n * \n *   return (\n *     <div>\n *       {isLoading && <span>Loading...</span>}\n *       {notes && !notes.length && <span>No Notes</span>}\n *       {notes && notes.length > 0 && (\n *         <ul>\n *           {notes.map((note) => (\n *             <li key={note.id}>{note.resource_type}</li>\n *           ))}\n *         </ul>\n *       )}\n *     </div>\n *   )\n * }\n * \n * export default Notes\n * ```\n * \n * By default, only the first `50` records are retrieved. You can control pagination by specifying the `limit` and `offset` properties:\n * \n * ```tsx\n * import React from \"react\"\n * import { useAdminNotes } from \"medusa-react\"\n * \n * const Notes = () => {\n *   const { \n *     notes, \n *     limit,\n *     offset,\n *     isLoading\n *   } = useAdminNotes({\n *     limit: 40,\n *     offset: 0\n *   })\n * \n *   return (\n *     <div>\n *       {isLoading && <span>Loading...</span>}\n *       {notes && !notes.length && <span>No Notes</span>}\n *       {notes && notes.length > 0 && (\n *         <ul>\n *           {notes.map((note) => (\n *             <li key={note.id}>{note.resource_type}</li>\n *           ))}\n *         </ul>\n *       )}\n *     </div>\n *   )\n * }\n * \n * export default Notes\n * ```\n * \n * @customNamespace Hooks.Admin.Notes\n * @category Queries\n */\nexport const useAdminNotes = (\n  /**\n   * Filters and pagination configurations applied on retrieved notes.\n   */\n  query?: AdminGetNotesParams,\n  options?: UseQueryOptionsWrapper<\n    Response<AdminNotesListRes>,\n    Error,\n    ReturnType<NoteQueryKeys[\"list\"]>\n  >\n) => {\n  const { client } = useMedusa()\n  const { data, ...rest } = useQuery(\n    adminNoteKeys.list(query),\n    () => client.admin.notes.list(query),\n    options\n  )\n  return { ...data, ...rest } as const\n}\n\n/**\n * This hook retrieves a note's details.\n * \n * @example\n * import React from \"react\"\n * import { useAdminNote } from \"medusa-react\"\n * \n * type Props = {\n *   noteId: string\n * }\n * \n * const Note = ({ noteId }: Props) => {\n *   const { note, isLoading } = useAdminNote(noteId)\n * \n *   return (\n *     <div>\n *       {isLoading && <span>Loading...</span>}\n *       {note && <span>{note.resource_type}</span>}\n *     </div>\n *   )\n * }\n * \n * export default Note\n * \n * @customNamespace Hooks.Admin.Notes\n * @category Queries\n */\nexport const useAdminNote = (\n  /**\n   * The note's ID.\n   */\n  id: string,\n  options?: UseQueryOptionsWrapper<\n    Response<AdminNotesRes>,\n    Error,\n    ReturnType<NoteQueryKeys[\"detail\"]>\n  >\n) => {\n  const { client } = useMedusa()\n  const { data, ...rest } = useQuery(\n    adminNoteKeys.detail(id),\n    () => client.admin.notes.retrieve(id),\n    options\n  )\n  return { ...data, ...rest } as const\n}\n","import {\n  AdminNotesDeleteRes,\n  AdminNotesRes,\n  AdminPostNotesNoteReq,\n  AdminPostNotesReq,\n} from \"@medusajs/medusa\"\nimport { Response } from \"@medusajs/medusa-js\"\nimport {\n  useMutation,\n  UseMutationOptions,\n  useQueryClient,\n} from \"@tanstack/react-query\"\nimport { useMedusa } from \"../../../contexts/medusa\"\nimport { buildOptions } from \"../../utils/buildOptions\"\nimport { adminNoteKeys } from \"./queries\"\n\n/**\n * This hook creates a Note which can be associated with any resource.\n * \n * @example\n * import React from \"react\"\n * import { useAdminCreateNote } from \"medusa-react\"\n * \n * const CreateNote = () => {\n *   const createNote = useAdminCreateNote()\n *   // ...\n * \n *   const handleCreate = () => {\n *     createNote.mutate({\n *       resource_id: \"order_123\",\n *       resource_type: \"order\",\n *       value: \"We delivered this order\"\n *     }, {\n *       onSuccess: ({ note }) => {\n *         console.log(note.id)\n *       }\n *     })\n *   }\n * \n *   // ...\n * }\n * \n * export default CreateNote\n * \n * @customNamespace Hooks.Admin.Notes\n * @category Mutations\n */\nexport const useAdminCreateNote = (\n  options?: UseMutationOptions<\n    Response<AdminNotesRes>,\n    Error,\n    AdminPostNotesReq\n  >\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n  return useMutation(\n    (payload: AdminPostNotesReq) => client.admin.notes.create(payload),\n    buildOptions(queryClient, adminNoteKeys.lists(), options)\n  )\n}\n\n/**\n * This hook updates a Note's details.\n * \n * @example\n * import React from \"react\"\n * import { useAdminUpdateNote } from \"medusa-react\"\n * \n * type Props = {\n *   noteId: string\n * }\n * \n * const Note = ({ noteId }: Props) => {\n *   const updateNote = useAdminUpdateNote(noteId)\n *   // ...\n * \n *   const handleUpdate = (\n *     value: string\n *   ) => {\n *     updateNote.mutate({\n *       value\n *     }, {\n *       onSuccess: ({ note }) => {\n *         console.log(note.value)\n *       }\n *     })\n *   }\n * \n *   // ...\n * }\n * \n * export default Note\n * \n * @customNamespace Hooks.Admin.Notes\n * @category Mutations\n */\nexport const useAdminUpdateNote = (\n  /**\n   * The note's ID.\n   */\n  id: string,\n  options?: UseMutationOptions<\n    Response<AdminNotesRes>,\n    Error,\n    AdminPostNotesNoteReq\n  >\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n\n  return useMutation(\n    (payload: AdminPostNotesNoteReq) => client.admin.notes.update(id, payload),\n    buildOptions(\n      queryClient,\n      [adminNoteKeys.detail(id), adminNoteKeys.lists()],\n      options\n    )\n  )\n}\n\n/**\n * This hook deletes a Note.\n * \n * @example\n * import React from \"react\"\n * import { useAdminDeleteNote } from \"medusa-react\"\n * \n * type Props = {\n *   noteId: string\n * }\n * \n * const Note = ({ noteId }: Props) => {\n *   const deleteNote = useAdminDeleteNote(noteId)\n *   // ...\n * \n *   const handleDelete = () => {\n *     deleteNote.mutate()\n *   }\n * \n *   // ...\n * }\n * \n * export default Note\n * \n * @customNamespace Hooks.Admin.Notes\n * @category Mutations\n */\nexport const useAdminDeleteNote = (\n  /**\n   * The note's ID.\n   */\n  id: string,\n  options?: UseMutationOptions<Response<AdminNotesDeleteRes>, Error, void>\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n\n  return useMutation(\n    () => client.admin.notes.delete(id),\n    buildOptions(\n      queryClient,\n      [adminNoteKeys.detail(id), adminNoteKeys.lists()],\n      options\n    )\n  )\n}\n","import {\n  AdminGetNotificationsParams,\n  AdminNotificationsListRes,\n} from \"@medusajs/medusa\"\nimport { Response } from \"@medusajs/medusa-js\"\nimport { useQuery } from \"@tanstack/react-query\"\nimport { useMedusa } from \"../../../contexts\"\nimport { UseQueryOptionsWrapper } from \"../../../types\"\nimport { queryKeysFactory } from \"../../utils/index\"\n\nconst ADMIN_NOTIFICATIONS_QUERY_KEY = `admin_notifications` as const\n\nexport const adminNotificationKeys = queryKeysFactory(\n  ADMIN_NOTIFICATIONS_QUERY_KEY\n)\n\ntype NotificationQueryKeys = typeof adminNotificationKeys\n\n/**\n * This hook retrieves a list of notifications. The notifications can be filtered by fields such as `event_name` or `resource_type` passed in the `query` parameter.\n * The notifications can also be paginated.\n * \n * @example\n * To list notifications:\n * \n * ```tsx\n * import React from \"react\"\n * import { useAdminNotifications } from \"medusa-react\"\n * \n * const Notifications = () => {\n *   const { notifications, isLoading } = useAdminNotifications()\n * \n *   return (\n *     <div>\n *       {isLoading && <span>Loading...</span>}\n *       {notifications && !notifications.length && (\n *         <span>No Notifications</span>\n *       )}\n *       {notifications && notifications.length > 0 && (\n *         <ul>\n *           {notifications.map((notification) => (\n *             <li key={notification.id}>{notification.to}</li>\n *           ))}\n *         </ul>\n *       )}\n *     </div>\n *   )\n * }\n * \n * export default Notifications\n * ```\n * \n * To specify relations that should be retrieved within the notifications:\n * \n * ```tsx\n * import React from \"react\"\n * import { useAdminNotifications } from \"medusa-react\"\n * \n * const Notifications = () => {\n *   const { notifications, isLoading } = useAdminNotifications({\n *     expand: \"provider\"\n *   })\n * \n *   return (\n *     <div>\n *       {isLoading && <span>Loading...</span>}\n *       {notifications && !notifications.length && (\n *         <span>No Notifications</span>\n *       )}\n *       {notifications && notifications.length > 0 && (\n *         <ul>\n *           {notifications.map((notification) => (\n *             <li key={notification.id}>{notification.to}</li>\n *           ))}\n *         </ul>\n *       )}\n *     </div>\n *   )\n * }\n * \n * export default Notifications\n * ```\n * \n * By default, only the first `50` records are retrieved. You can control pagination by specifying the `limit` and `offset` properties:\n * \n * ```tsx\n * import React from \"react\"\n * import { useAdminNotifications } from \"medusa-react\"\n * \n * const Notifications = () => {\n *   const { \n *     notifications, \n *     limit,\n *     offset,\n *     isLoading\n *   } = useAdminNotifications({\n *     expand: \"provider\",\n *     limit: 20,\n *     offset: 0\n *   })\n * \n *   return (\n *     <div>\n *       {isLoading && <span>Loading...</span>}\n *       {notifications && !notifications.length && (\n *         <span>No Notifications</span>\n *       )}\n *       {notifications && notifications.length > 0 && (\n *         <ul>\n *           {notifications.map((notification) => (\n *             <li key={notification.id}>{notification.to}</li>\n *           ))}\n *         </ul>\n *       )}\n *     </div>\n *   )\n * }\n * \n * export default Notifications\n * ```\n * \n * @customNamespace Hooks.Admin.Notifications\n * @category Queries\n */\nexport const useAdminNotifications = (\n  /**\n   * Filters and pagination configurations applied to the retrieved notifications.\n   */\n  query?: AdminGetNotificationsParams,\n  options?: UseQueryOptionsWrapper<\n    Response<AdminNotificationsListRes>,\n    Error,\n    ReturnType<NotificationQueryKeys[\"list\"]>\n  >\n) => {\n  const { client } = useMedusa()\n  const { data, ...rest } = useQuery(\n    adminNotificationKeys.list(query),\n    () => client.admin.notifications.list(query),\n    options\n  )\n  return { ...data, ...rest } as const\n}\n","import {\n  AdminNotificationsRes,\n  AdminPostNotificationsNotificationResendReq,\n} from \"@medusajs/medusa\"\nimport { Response } from \"@medusajs/medusa-js\"\nimport {\n  useMutation,\n  UseMutationOptions,\n  useQueryClient,\n} from \"@tanstack/react-query\"\nimport { useMedusa } from \"../../../contexts/medusa\"\nimport { buildOptions } from \"../../utils/buildOptions\"\nimport { adminNotificationKeys } from \"./queries\"\n\n/**\n * This hook resends a previously sent notifications, with the same data but optionally to a different address.\n * \n * @example\n * import React from \"react\"\n * import { useAdminResendNotification } from \"medusa-react\"\n * \n * type Props = {\n *   notificationId: string\n * }\n * \n * const Notification = ({ notificationId }: Props) => {\n *   const resendNotification = useAdminResendNotification(\n *     notificationId\n *   )\n *   // ...\n * \n *   const handleResend = () => {\n *     resendNotification.mutate({}, {\n *       onSuccess: ({ notification }) => {\n *         console.log(notification.id)\n *       }\n *     })\n *   }\n * \n *   // ...\n * }\n * \n * export default Notification\n * \n * @customNamespace Hooks.Admin.Notifications\n * @category Mutations\n */\nexport const useAdminResendNotification = (\n  /**\n   * The ID of the notification.\n   */\n  id: string,\n  options?: UseMutationOptions<\n    Response<AdminNotificationsRes>,\n    Error,\n    AdminPostNotificationsNotificationResendReq\n  >\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n\n  return useMutation(\n    (payload: AdminPostNotificationsNotificationResendReq) =>\n      client.admin.notifications.resend(id, payload),\n    buildOptions(\n      queryClient,\n      [adminNotificationKeys.lists(), adminNotificationKeys.detail(id)],\n      options\n    )\n  )\n}\n","import {\n  AdminOrderEditsListRes,\n  AdminOrderEditsRes,\n  GetOrderEditsOrderEditParams,\n  GetOrderEditsParams,\n} from \"@medusajs/medusa\"\nimport { Response } from \"@medusajs/medusa-js\"\nimport { useQuery } from \"@tanstack/react-query\"\nimport { useMedusa } from \"../../../contexts\"\nimport { UseQueryOptionsWrapper } from \"../../../types\"\nimport { queryKeysFactory } from \"../../utils\"\n\nconst ADMIN_ORDER_EDITS_QUERY_KEY = `admin_order_edits` as const\n\nexport const adminOrderEditsKeys = queryKeysFactory(ADMIN_ORDER_EDITS_QUERY_KEY)\ntype OrderEditQueryKeys = typeof adminOrderEditsKeys\n\n/**\n * This hook retrieves an order edit's details.\n * \n * @example\n * A simple example that retrieves an order edit by its ID:\n * \n * ```tsx\n * import React from \"react\"\n * import { useAdminOrderEdit } from \"medusa-react\"\n * \n * type Props = {\n *   orderEditId: string\n * }\n * \n * const OrderEdit = ({ orderEditId }: Props) => {\n *   const { \n *     order_edit, \n *     isLoading, \n *   } = useAdminOrderEdit(orderEditId)\n * \n *   return (\n *     <div>\n *       {isLoading && <span>Loading...</span>}\n *       {order_edit && <span>{order_edit.status}</span>}\n *     </div>\n *   )\n * }\n * \n * export default OrderEdit\n * ```\n * \n * To specify relations that should be retrieved:\n * \n * ```tsx\n * import React from \"react\"\n * import { useAdminOrderEdit } from \"medusa-react\"\n * \n * type Props = {\n *   orderEditId: string\n * }\n * \n * const OrderEdit = ({ orderEditId }: Props) => {\n *   const { \n *     order_edit, \n *     isLoading, \n *   } = useAdminOrderEdit(\n *     orderEditId,\n *     {\n *       expand: \"order\"\n *     }\n *   )\n * \n *   return (\n *     <div>\n *       {isLoading && <span>Loading...</span>}\n *       {order_edit && <span>{order_edit.status}</span>}\n *     </div>\n *   )\n * }\n * \n * export default OrderEdit\n * ```\n * \n * @customNamespace Hooks.Admin.Order Edits\n * @category Queries\n */\nexport const useAdminOrderEdit = (\n  /**\n   * The order edit's ID.\n   */\n  id: string,\n  /**\n   * Configurations to apply on the retrieved order edit.\n   */\n  query?: GetOrderEditsOrderEditParams,\n  options?: UseQueryOptionsWrapper<\n    Response<AdminOrderEditsRes>,\n    Error,\n    ReturnType<OrderEditQueryKeys[\"detail\"]>\n  >\n) => {\n  const { client } = useMedusa()\n  const { data, ...rest } = useQuery(\n    adminOrderEditsKeys.detail(id),\n    () => client.admin.orderEdits.retrieve(id, query),\n    options\n  )\n  return { ...data, ...rest } as const\n}\n\n/**\n * This hook retrieves a list of order edits. The order edits can be filtered by fields such as `q` or `order_id` passed to the `query` parameter. \n * The order edits can also be paginated.\n * \n * @example\n * To list order edits:\n * \n * ```tsx\n * import React from \"react\"\n * import { useAdminOrderEdits } from \"medusa-react\"\n * \n * const OrderEdits = () => {\n *   const { order_edits, isLoading } = useAdminOrderEdits()\n * \n *   return (\n *     <div>\n *       {isLoading && <span>Loading...</span>}\n *       {order_edits && !order_edits.length && (\n *         <span>No Order Edits</span>\n *       )}\n *       {order_edits && order_edits.length > 0 && (\n *         <ul>\n *           {order_edits.map((orderEdit) => (\n *             <li key={orderEdit.id}>\n *               {orderEdit.status}\n *             </li>\n *           ))}\n *         </ul>\n *       )}\n *     </div>\n *   )\n * }\n * \n * export default OrderEdits\n * ```\n * \n * To specify relations that should be retrieved within the order edits:\n * \n * ```tsx\n * import React from \"react\"\n * import { useAdminOrderEdits } from \"medusa-react\"\n * \n * const OrderEdits = () => {\n *   const { order_edits, isLoading } = useAdminOrderEdits({\n *     expand: \"order\"\n *   })\n * \n *   return (\n *     <div>\n *       {isLoading && <span>Loading...</span>}\n *       {order_edits && !order_edits.length && (\n *         <span>No Order Edits</span>\n *       )}\n *       {order_edits && order_edits.length > 0 && (\n *         <ul>\n *           {order_edits.map((orderEdit) => (\n *             <li key={orderEdit.id}>\n *               {orderEdit.status}\n *             </li>\n *           ))}\n *         </ul>\n *       )}\n *     </div>\n *   )\n * }\n * \n * export default OrderEdits\n * ```\n * \n * By default, only the first `50` records are retrieved. You can control pagination by specifying the `limit` and `offset` properties:\n * \n * ```tsx\n * import React from \"react\"\n * import { useAdminOrderEdits } from \"medusa-react\"\n * \n * const OrderEdits = () => {\n *   const { \n *     order_edits,\n *     limit,\n *     offset,\n *     isLoading\n *   } = useAdminOrderEdits({\n *     expand: \"order\",\n *     limit: 20,\n *     offset: 0\n *   })\n * \n *   return (\n *     <div>\n *       {isLoading && <span>Loading...</span>}\n *       {order_edits && !order_edits.length && (\n *         <span>No Order Edits</span>\n *       )}\n *       {order_edits && order_edits.length > 0 && (\n *         <ul>\n *           {order_edits.map((orderEdit) => (\n *             <li key={orderEdit.id}>\n *               {orderEdit.status}\n *             </li>\n *           ))}\n *         </ul>\n *       )}\n *     </div>\n *   )\n * }\n * \n * export default OrderEdits\n * ```\n * \n * @customNamespace Hooks.Admin.Order Edits\n * @category Queries\n */\nexport const useAdminOrderEdits = (\n  /**\n   * Filters and pagination configurations applied to retrieved order edits.\n   */\n  query?: GetOrderEditsParams,\n  options?: UseQueryOptionsWrapper<\n    Response<AdminOrderEditsListRes>,\n    Error,\n    ReturnType<OrderEditQueryKeys[\"list\"]>\n  >\n) => {\n  const { client } = useMedusa()\n  const { data, ...rest } = useQuery(\n    adminOrderEditsKeys.list(query),\n    () => client.admin.orderEdits.list(query),\n    options\n  )\n  return { ...data, ...rest } as const\n}\n","import { Response } from \"@medusajs/medusa-js\"\nimport {\n  useMutation,\n  UseMutationOptions,\n  useQueryClient,\n} from \"@tanstack/react-query\"\n\nimport {\n  AdminOrderEditDeleteRes,\n  AdminOrderEditItemChangeDeleteRes,\n  AdminOrderEditsRes,\n  AdminPostOrderEditsEditLineItemsLineItemReq,\n  AdminPostOrderEditsEditLineItemsReq,\n  AdminPostOrderEditsOrderEditReq,\n  AdminPostOrderEditsReq,\n} from \"@medusajs/medusa\"\n\nimport { useMedusa } from \"../../../contexts\"\nimport { buildOptions } from \"../../utils/buildOptions\"\nimport { adminOrderKeys } from \"../orders\"\nimport { adminOrderEditsKeys } from \"./queries\"\n\n/**\n * This hook creates an order edit.\n * \n * @example\n * import React from \"react\"\n * import { useAdminCreateOrderEdit } from \"medusa-react\"\n * \n * const CreateOrderEdit = () => {\n *   const createOrderEdit = useAdminCreateOrderEdit()\n * \n *   const handleCreateOrderEdit = (orderId: string) => {\n *     createOrderEdit.mutate({\n *       order_id: orderId,\n *     }, {\n *       onSuccess: ({ order_edit }) => {\n *         console.log(order_edit.id)\n *       }\n *     })\n *   }\n *   \n *   // ...\n * }\n * \n * export default CreateOrderEdit\n * \n * @customNamespace Hooks.Admin.Order Edits\n * @category Mutations\n */\nexport const useAdminCreateOrderEdit = (\n  options?: UseMutationOptions<\n    Response<AdminOrderEditsRes>,\n    Error,\n    AdminPostOrderEditsReq\n  >\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n  return useMutation(\n    (payload: AdminPostOrderEditsReq) =>\n      client.admin.orderEdits.create(payload),\n    buildOptions(\n      queryClient,\n      [adminOrderEditsKeys.lists(), adminOrderKeys.details()],\n      options\n    )\n  )\n}\n\n/**\n * This hook deletes an order edit. Only order edits that have the status `created` can be deleted.\n * \n * @example\n * import React from \"react\"\n * import { useAdminDeleteOrderEdit } from \"medusa-react\"\n * \n * type Props = {\n *   orderEditId: string\n * }\n * \n * const OrderEdit = ({ orderEditId }: Props) => {\n *   const deleteOrderEdit = useAdminDeleteOrderEdit(\n *     orderEditId\n *   )\n *   \n *   const handleDelete = () => {\n *     deleteOrderEdit.mutate(void 0, {\n *       onSuccess: ({ id, object, deleted }) => {\n *         console.log(id)\n *       }\n *     })\n *   }\n * \n *   // ...\n * }\n * \n * export default OrderEdit\n * \n * @customNamespace Hooks.Admin.Order Edits\n * @category Mutations\n */\nexport const useAdminDeleteOrderEdit = (\n  /**\n   * Order Edit's ID\n   */\n  id: string,\n  options?: UseMutationOptions<Response<AdminOrderEditDeleteRes>, Error, void>\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n\n  return useMutation(\n    () => client.admin.orderEdits.delete(id),\n    buildOptions(\n      queryClient,\n      [\n        adminOrderEditsKeys.detail(id),\n        adminOrderEditsKeys.lists(),\n        adminOrderKeys.details(),\n      ],\n      options\n    )\n  )\n}\n\n/**\n * This hook deletes a line item change that indicates the addition, deletion, or update of a line item in the original order.\n * \n * @example\n * import React from \"react\"\n * import { useAdminDeleteOrderEditItemChange } from \"medusa-react\"\n * \n * type Props = {\n *   orderEditId: string\n *   itemChangeId: string\n * }\n * \n * const OrderEditItemChange = ({\n *   orderEditId,\n *   itemChangeId\n * }: Props) => {\n *   const deleteItemChange = useAdminDeleteOrderEditItemChange(\n *     orderEditId, \n *     itemChangeId\n *   )\n *   \n *   const handleDeleteItemChange = () => {\n *     deleteItemChange.mutate(void 0, {\n *       onSuccess: ({ id, object, deleted }) => {\n *         console.log(id)\n *       }\n *     })\n *   }\n * \n *   // ...\n * }\n * \n * export default OrderEditItemChange\n * \n * @customNamespace Hooks.Admin.Order Edits\n * @category Mutations\n */\nexport const useAdminDeleteOrderEditItemChange = (\n  /**\n   * The order edit's ID.\n   */\n  orderEditId: string,\n  /**\n   * The line item change's ID.\n   */\n  itemChangeId: string,\n  options?: UseMutationOptions<\n    Response<AdminOrderEditItemChangeDeleteRes>,\n    Error,\n    void\n  >\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n\n  return useMutation(\n    () => client.admin.orderEdits.deleteItemChange(orderEditId, itemChangeId),\n    buildOptions(\n      queryClient,\n      [adminOrderEditsKeys.detail(orderEditId), adminOrderEditsKeys.lists()],\n      options\n    )\n  )\n}\n\n/**\n * This hook creates or updates a line item change in the order edit that indicates addition, deletion, or update of a line item \n * into an original order. Line item changes are only reflected on the original order after the order edit is confirmed.\n * \n * @example\n * import React from \"react\"\n * import { useAdminOrderEditUpdateLineItem } from \"medusa-react\"\n * \n * type Props = {\n *   orderEditId: string\n *   itemId: string\n * }\n * \n * const OrderEditItemChange = ({\n *   orderEditId,\n *   itemId\n * }: Props) => {\n *   const updateLineItem = useAdminOrderEditUpdateLineItem(\n *     orderEditId, \n *     itemId\n *   )\n *   \n *   const handleUpdateLineItem = (quantity: number) => {\n *     updateLineItem.mutate({\n *       quantity,\n *     }, {\n *       onSuccess: ({ order_edit }) => {\n *         console.log(order_edit.items)\n *       }\n *     })\n *   }\n * \n *   // ...\n * }\n * \n * export default OrderEditItemChange\n * \n * @customNamespace Hooks.Admin.Order Edits\n * @category Mutations\n */\nexport const useAdminOrderEditUpdateLineItem = (\n  /**\n   * The order edit's ID.\n   */\n  orderEditId: string,\n  /**\n   * The line item's ID.\n   */\n  itemId: string,\n  options?: UseMutationOptions<\n    Response<AdminOrderEditsRes>,\n    Error,\n    AdminPostOrderEditsEditLineItemsLineItemReq\n  >\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n\n  return useMutation(\n    (payload: AdminPostOrderEditsEditLineItemsLineItemReq) =>\n      client.admin.orderEdits.updateLineItem(orderEditId, itemId, payload),\n    buildOptions(\n      queryClient,\n      [adminOrderEditsKeys.detail(orderEditId), adminOrderEditsKeys.lists()],\n      options\n    )\n  )\n}\n\n/**\n * This hook creates a line item change in the order edit that indicates deleting an item in the original order. \n * The item in the original order will not be deleted until the order edit is confirmed.\n * \n * @example\n * import React from \"react\"\n * import { useAdminOrderEditDeleteLineItem } from \"medusa-react\"\n * \n * type Props = {\n *   orderEditId: string\n *   itemId: string\n * }\n * \n * const OrderEditLineItem = ({\n *   orderEditId,\n *   itemId\n * }: Props) => {\n *   const removeLineItem = useAdminOrderEditDeleteLineItem(\n *     orderEditId, \n *     itemId\n *   )\n *   \n *   const handleRemoveLineItem = () => {\n *     removeLineItem.mutate(void 0, {\n *       onSuccess: ({ order_edit }) => {\n *         console.log(order_edit.changes)\n *       }\n *     })\n *   }\n * \n *   // ...\n * }\n * \n * export default OrderEditLineItem\n * \n * @customNamespace Hooks.Admin.Order Edits\n * @category Mutations\n */\nexport const useAdminOrderEditDeleteLineItem = (\n  /**\n   * The order edit's ID.\n   */\n  orderEditId: string,\n  /**\n   * The line item's ID.\n   */\n  itemId: string,\n  options?: UseMutationOptions<Response<AdminOrderEditsRes>, Error>\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n\n  return useMutation(\n    () => client.admin.orderEdits.removeLineItem(orderEditId, itemId),\n    buildOptions(\n      queryClient,\n      [adminOrderEditsKeys.detail(orderEditId), adminOrderEditsKeys.lists()],\n      options\n    )\n  )\n}\n\n/**\n * This hook updates an Order Edit's details.\n * \n * @example\n * import React from \"react\"\n * import { useAdminUpdateOrderEdit } from \"medusa-react\"\n * \n * type Props = {\n *   orderEditId: string\n * }\n * \n * const OrderEdit = ({ orderEditId }: Props) => {\n *   const updateOrderEdit = useAdminUpdateOrderEdit(\n *     orderEditId, \n *   )\n *   \n *   const handleUpdate = (\n *     internalNote: string\n *   ) => {\n *     updateOrderEdit.mutate({\n *       internal_note: internalNote\n *     }, {\n *       onSuccess: ({ order_edit }) => {\n *         console.log(order_edit.internal_note)\n *       }\n *     })\n *   }\n * \n *   // ...\n * }\n * \n * export default OrderEdit\n * \n * @customNamespace Hooks.Admin.Order Edits\n * @category Mutations\n */\nexport const useAdminUpdateOrderEdit = (\n  /**\n   * The order edit's ID.\n   */\n  id: string,\n  options?: UseMutationOptions<\n    Response<AdminOrderEditsRes>,\n    Error,\n    AdminPostOrderEditsOrderEditReq\n  >\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n\n  return useMutation(\n    (payload: AdminPostOrderEditsOrderEditReq) =>\n      client.admin.orderEdits.update(id, payload),\n    buildOptions(\n      queryClient,\n      [\n        adminOrderEditsKeys.lists(),\n        adminOrderEditsKeys.detail(id),\n        adminOrderKeys.details(),\n      ],\n      options\n    )\n  )\n}\n\n/**\n * This hook creates a line item change in the order edit that indicates adding an item in the original order. \n * The item will not be added to the original order until the order edit is confirmed.\n * \n * @example\n * import React from \"react\"\n * import { useAdminOrderEditAddLineItem } from \"medusa-react\"\n * \n * type Props = {\n *   orderEditId: string\n * }\n * \n * const OrderEdit = ({ orderEditId }: Props) => {\n *   const addLineItem = useAdminOrderEditAddLineItem(\n *     orderEditId\n *   )\n * \n *   const handleAddLineItem = \n *     (quantity: number, variantId: string) => {\n *       addLineItem.mutate({\n *         quantity,\n *         variant_id: variantId,\n *       }, {\n *         onSuccess: ({ order_edit }) => {\n *           console.log(order_edit.changes)\n *         }\n *       })\n *     }\n *   \n *   // ...\n * }\n * \n * export default OrderEdit\n * \n * @customNamespace Hooks.Admin.Order Edits\n * @category Mutations\n */\nexport const useAdminOrderEditAddLineItem = (\n  /**\n   * The order edit's ID.\n   */\n  id: string,\n  options?: UseMutationOptions<\n    Response<AdminOrderEditsRes>,\n    Error,\n    AdminPostOrderEditsEditLineItemsReq\n  >\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n  return useMutation(\n    (payload: AdminPostOrderEditsEditLineItemsReq) =>\n      client.admin.orderEdits.addLineItem(id, payload),\n    buildOptions(\n      queryClient,\n      [adminOrderEditsKeys.lists(), adminOrderEditsKeys.detail(id)],\n      options\n    )\n  )\n}\n\n/**\n * This hook requests customer confirmation of an order edit. This would emit the event `order-edit.requested` which Notification Providers listen to and send\n * a notification to the customer about the order edit.\n * \n * @example\n * import React from \"react\"\n * import { \n *   useAdminRequestOrderEditConfirmation,\n * } from \"medusa-react\"\n * \n * type Props = {\n *   orderEditId: string\n * }\n * \n * const OrderEdit = ({ orderEditId }: Props) => {\n *   const requestOrderConfirmation = \n *     useAdminRequestOrderEditConfirmation(\n *       orderEditId\n *     )\n *   \n *   const handleRequestConfirmation = () => {\n *     requestOrderConfirmation.mutate(void 0, {\n *       onSuccess: ({ order_edit }) => {\n *         console.log(\n *           order_edit.requested_at, \n *           order_edit.requested_by\n *         )\n *       }\n *     })\n *   }\n * \n *   // ...\n * }\n * \n * export default OrderEdit\n * \n * @customNamespace Hooks.Admin.Order Edits\n * @category Mutations\n */\nexport const useAdminRequestOrderEditConfirmation = (\n  /**\n   * The order edit's ID.\n   */\n  id: string,\n  options?: UseMutationOptions<Response<AdminOrderEditsRes>, Error>\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n\n  return useMutation(\n    () => client.admin.orderEdits.requestConfirmation(id),\n    buildOptions(\n      queryClient,\n      [\n        adminOrderEditsKeys.lists(),\n        adminOrderEditsKeys.detail(id),\n        adminOrderKeys.details(),\n      ],\n      options\n    )\n  )\n}\n\n/**\n * This hook cancels an order edit.\n * \n * @example\n * import React from \"react\"\n * import { \n *   useAdminCancelOrderEdit,\n * } from \"medusa-react\"\n * \n * type Props = {\n *   orderEditId: string\n * }\n * \n * const OrderEdit = ({ orderEditId }: Props) => {\n *   const cancelOrderEdit = \n *     useAdminCancelOrderEdit(\n *       orderEditId\n *     )\n *   \n *   const handleCancel = () => {\n *     cancelOrderEdit.mutate(void 0, {\n *       onSuccess: ({ order_edit }) => {\n *         console.log(\n *           order_edit.id\n *         )\n *       }\n *     })\n *   }\n * \n *   // ...\n * }\n * \n * export default OrderEdit\n * \n * @customNamespace Hooks.Admin.Order Edits\n * @category Mutations\n */\nexport const useAdminCancelOrderEdit = (\n  /**\n   * The order edit's ID.\n   */\n  id: string,\n  options?: UseMutationOptions<Response<AdminOrderEditsRes>, Error>\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n\n  return useMutation(\n    () => client.admin.orderEdits.cancel(id),\n    buildOptions(\n      queryClient,\n      [\n        adminOrderEditsKeys.lists(),\n        adminOrderEditsKeys.detail(id),\n        adminOrderKeys.details(),\n      ],\n      options\n    )\n  )\n}\n\n/**\n * This hook confirms an order edit. This will reflect the changes in the order edit on the associated order.\n * \n * @example\n * import React from \"react\"\n * import { useAdminConfirmOrderEdit } from \"medusa-react\"\n * \n * type Props = {\n *   orderEditId: string\n * }\n * \n * const OrderEdit = ({ orderEditId }: Props) => {\n *   const confirmOrderEdit = useAdminConfirmOrderEdit(\n *     orderEditId\n *   )\n *   \n *   const handleConfirmOrderEdit = () => {\n *     confirmOrderEdit.mutate(void 0, {\n *       onSuccess: ({ order_edit }) => {\n *         console.log(\n *           order_edit.confirmed_at,\n *           order_edit.confirmed_by\n *         )\n *       }\n *     })\n *   }\n * \n *   // ...\n * }\n * \n * export default OrderEdit\n * \n * @customNamespace Hooks.Admin.Order Edits\n * @category Mutations\n */\nexport const useAdminConfirmOrderEdit = (\n  /**\n   * The order edit's ID.\n   */\n  id: string,\n  options?: UseMutationOptions<Response<AdminOrderEditsRes>, Error>\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n\n  return useMutation(\n    () => client.admin.orderEdits.confirm(id),\n    buildOptions(\n      queryClient,\n      [\n        adminOrderEditsKeys.lists(),\n        adminOrderEditsKeys.detail(id),\n        adminOrderKeys.details(),\n      ],\n      options\n    )\n  )\n}\n","import { AdminPaymentCollectionsRes } from \"@medusajs/medusa\"\nimport { Response } from \"@medusajs/medusa-js\"\nimport { useQuery } from \"@tanstack/react-query\"\nimport { useMedusa } from \"../../../contexts\"\nimport { UseQueryOptionsWrapper } from \"../../../types\"\nimport { queryKeysFactory } from \"../../utils\"\n\nconst PAYMENT_COLLECTION_QUERY_KEY = `paymentCollection` as const\n\nexport const adminPaymentCollectionQueryKeys = queryKeysFactory<\n  typeof PAYMENT_COLLECTION_QUERY_KEY\n>(PAYMENT_COLLECTION_QUERY_KEY)\n\ntype AdminPaymentCollectionKey = typeof adminPaymentCollectionQueryKeys\n\n/**\n * This hook retrieves a Payment Collection's details.\n * \n * @example\n * import React from \"react\"\n * import { useAdminPaymentCollection } from \"medusa-react\"\n * \n * type Props = {\n *   paymentCollectionId: string\n * }\n * \n * const PaymentCollection = ({ paymentCollectionId }: Props) => {\n *   const { \n *     payment_collection, \n *     isLoading, \n *   } = useAdminPaymentCollection(paymentCollectionId)\n * \n *   return (\n *     <div>\n *       {isLoading && <span>Loading...</span>}\n *       {payment_collection && (\n *         <span>{payment_collection.status}</span>\n *       )}\n *       \n *     </div>\n *   )\n * }\n * \n * export default PaymentCollection\n * \n * @customNamespace Hooks.Admin.Payment Collections\n * @category Queries\n */\nexport const useAdminPaymentCollection = (\n  /**\n   * The payment collection's ID.\n   */\n  id: string,\n  options?: UseQueryOptionsWrapper<\n    Response<AdminPaymentCollectionsRes>,\n    Error,\n    ReturnType<AdminPaymentCollectionKey[\"detail\"]>\n  >\n) => {\n  const { client } = useMedusa()\n  const { data, ...rest } = useQuery(\n    adminPaymentCollectionQueryKeys.detail(id),\n    () => client.admin.paymentCollections.retrieve(id),\n    options\n  )\n\n  return { ...data, ...rest } as const\n}\n","import { Response } from \"@medusajs/medusa-js\"\nimport {\n  useMutation,\n  UseMutationOptions,\n  useQueryClient,\n} from \"@tanstack/react-query\"\n\nimport {\n  AdminPaymentCollectionDeleteRes,\n  AdminPaymentCollectionsRes,\n  AdminUpdatePaymentCollectionsReq,\n} from \"@medusajs/medusa\"\n\nimport { useMedusa } from \"../../../contexts\"\nimport { buildOptions } from \"../../utils/buildOptions\"\nimport { adminPaymentCollectionQueryKeys } from \"./queries\"\n\n/**\n * This hook deletes a payment collection. Only payment collections with the statuses `canceled` or `not_paid` can be deleted.\n * \n * @example\n * import React from \"react\"\n * import { useAdminDeletePaymentCollection } from \"medusa-react\"\n * \n * type Props = {\n *   paymentCollectionId: string\n * }\n * \n * const PaymentCollection = ({ paymentCollectionId }: Props) => {\n *   const deleteCollection = useAdminDeletePaymentCollection(\n *     paymentCollectionId\n *   )\n *   // ...\n * \n *   const handleDelete = () => {\n *     deleteCollection.mutate(void 0, {\n *       onSuccess: ({ id, object, deleted }) => {\n *         console.log(id)\n *       }\n *     })\n *   }\n * \n *   // ...\n * }\n * \n * export default PaymentCollection\n * \n * @customNamespace Hooks.Admin.Payment Collections\n * @category Mutations\n */\nexport const useAdminDeletePaymentCollection = (\n  /**\n   * The payment collection's ID.\n   */\n  id: string,\n  options?: UseMutationOptions<\n    Response<AdminPaymentCollectionDeleteRes>,\n    Error,\n    void\n  >\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n\n  return useMutation(\n    () => client.admin.paymentCollections.delete(id),\n    buildOptions(\n      queryClient,\n      [\n        adminPaymentCollectionQueryKeys.detail(id),\n        adminPaymentCollectionQueryKeys.lists(),\n      ],\n      options\n    )\n  )\n}\n\n/**\n * This hook updates a payment collection's details.\n * \n * @example\n * import React from \"react\"\n * import { useAdminUpdatePaymentCollection } from \"medusa-react\"\n * \n * type Props = {\n *   paymentCollectionId: string\n * }\n * \n * const PaymentCollection = ({ paymentCollectionId }: Props) => {\n *   const updateCollection = useAdminUpdatePaymentCollection(\n *     paymentCollectionId\n *   )\n *   // ...\n * \n *   const handleUpdate = (\n *     description: string\n *   ) => {\n *     updateCollection.mutate({\n *       description\n *     }, {\n *       onSuccess: ({ payment_collection }) => {\n *         console.log(payment_collection.description)\n *       }\n *     })\n *   }\n * \n *   // ...\n * }\n * \n * export default PaymentCollection\n * \n * @customNamespace Hooks.Admin.Payment Collections\n * @category Mutations\n */\nexport const useAdminUpdatePaymentCollection = (\n  /**\n   * The payment collection's ID.\n   */\n  id: string,\n  options?: UseMutationOptions<\n    Response<AdminPaymentCollectionsRes>,\n    Error,\n    AdminUpdatePaymentCollectionsReq\n  >\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n\n  return useMutation(\n    (payload: AdminUpdatePaymentCollectionsReq) =>\n      client.admin.paymentCollections.update(id, payload),\n    buildOptions(\n      queryClient,\n      [\n        adminPaymentCollectionQueryKeys.detail(id),\n        adminPaymentCollectionQueryKeys.lists(),\n      ],\n      options\n    )\n  )\n}\n\n/**\n * This hook sets the status of a payment collection as `authorized`. This will also change the `authorized_amount` of the payment collection.\n * \n * @example\n * import React from \"react\"\n * import { useAdminMarkPaymentCollectionAsAuthorized } from \"medusa-react\"\n * \n * type Props = {\n *   paymentCollectionId: string\n * }\n * \n * const PaymentCollection = ({ paymentCollectionId }: Props) => {\n *   const markAsAuthorized = useAdminMarkPaymentCollectionAsAuthorized(\n *     paymentCollectionId\n *   )\n *   // ...\n * \n *   const handleAuthorization = () => {\n *     markAsAuthorized.mutate(void 0, {\n *       onSuccess: ({ payment_collection }) => {\n *         console.log(payment_collection.status)\n *       }\n *     })\n *   }\n * \n *   // ...\n * }\n * \n * export default PaymentCollection\n * \n * @customNamespace Hooks.Admin.Payment Collections\n * @category Mutations\n */\nexport const useAdminMarkPaymentCollectionAsAuthorized = (\n  /**\n   * The payment collection's ID.\n   */\n  id: string,\n  options?: UseMutationOptions<\n    Response<AdminPaymentCollectionsRes>,\n    Error,\n    void\n  >\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n\n  return useMutation(\n    () => client.admin.paymentCollections.markAsAuthorized(id),\n    buildOptions(\n      queryClient,\n      [\n        adminPaymentCollectionQueryKeys.detail(id),\n        adminPaymentCollectionQueryKeys.lists(),\n      ],\n      options\n    )\n  )\n}\n","import { AdminPaymentRes } from \"@medusajs/medusa\"\nimport { Response } from \"@medusajs/medusa-js\"\nimport { useQuery } from \"@tanstack/react-query\"\nimport { useMedusa } from \"../../../contexts\"\nimport { UseQueryOptionsWrapper } from \"../../../types\"\nimport { queryKeysFactory } from \"../../utils\"\n\nconst PAYMENT_QUERY_KEY = `payment` as const\n\nexport const adminPaymentQueryKeys =\n  queryKeysFactory<typeof PAYMENT_QUERY_KEY>(PAYMENT_QUERY_KEY)\n\ntype AdminPaymentKey = typeof adminPaymentQueryKeys\n\n/**\n * This hook retrieves a payment's details.\n * \n * @example\n * import React from \"react\"\n * import { useAdminPayment } from \"medusa-react\"\n * \n * type Props = {\n *   paymentId: string\n * }\n * \n * const Payment = ({ paymentId }: Props) => {\n *   const { \n *     payment, \n *     isLoading, \n *   } = useAdminPayment(paymentId)\n * \n *   return (\n *     <div>\n *       {isLoading && <span>Loading...</span>}\n *       {payment && <span>{payment.amount}</span>}\n *       \n *     </div>\n *   )\n * }\n * \n * export default Payment\n * \n * @customNamespace Hooks.Admin.Payments\n * @category Queries\n */\nexport const useAdminPayment = (\n  /**\n   * The payment's ID.\n   */\n  id: string,\n  options?: UseQueryOptionsWrapper<\n    Response<AdminPaymentRes>,\n    Error,\n    ReturnType<AdminPaymentKey[\"detail\"]>\n  >\n) => {\n  const { client } = useMedusa()\n  const { data, ...rest } = useQuery(\n    adminPaymentQueryKeys.detail(id),\n    () => client.admin.payments.retrieve(id),\n    options\n  )\n\n  return { ...data, ...rest } as const\n}\n","import { Response } from \"@medusajs/medusa-js\"\nimport {\n  useMutation,\n  UseMutationOptions,\n  useQueryClient,\n} from \"@tanstack/react-query\"\n\nimport {\n  AdminPaymentRes,\n  AdminPostPaymentRefundsReq,\n  AdminRefundRes,\n} from \"@medusajs/medusa\"\n\nimport { useMedusa } from \"../../../contexts\"\nimport { buildOptions } from \"../../utils/buildOptions\"\nimport { adminPaymentQueryKeys } from \"./queries\"\n\n/**\n * This hook captures a payment.\n * \n * @example\n * import React from \"react\"\n * import { useAdminPaymentsCapturePayment } from \"medusa-react\"\n * \n * type Props = {\n *   paymentId: string\n * }\n * \n * const Payment = ({ paymentId }: Props) => {\n *   const capture = useAdminPaymentsCapturePayment(\n *     paymentId\n *   )\n *   // ...\n * \n *   const handleCapture = () => {\n *     capture.mutate(void 0, {\n *       onSuccess: ({ payment }) => {\n *         console.log(payment.amount)\n *       }\n *     })\n *   }\n * \n *   // ...\n * }\n * \n * export default Payment\n * \n * @customNamespace Hooks.Admin.Payments\n * @category Mutations\n */\nexport const useAdminPaymentsCapturePayment = (\n  /**\n   * The payment's ID.\n   */\n  id: string,\n  options?: UseMutationOptions<Response<AdminPaymentRes>, Error, void>\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n\n  return useMutation(\n    () => client.admin.payments.capturePayment(id),\n    buildOptions(\n      queryClient,\n      [adminPaymentQueryKeys.detail(id), adminPaymentQueryKeys.lists()],\n      options\n    )\n  )\n}\n\n/**\n * This hook refunds a payment. The payment must be captured first.\n * \n * @example\n * import React from \"react\"\n * import { RefundReason } from \"@medusajs/medusa\"\n * import { useAdminPaymentsRefundPayment } from \"medusa-react\"\n * \n * type Props = {\n *   paymentId: string\n * }\n * \n * const Payment = ({ paymentId }: Props) => {\n *   const refund = useAdminPaymentsRefundPayment(\n *     paymentId\n *   )\n *   // ...\n * \n *   const handleRefund = (\n *     amount: number,\n *     reason: RefundReason,\n *     note: string\n *   ) => {\n *     refund.mutate({\n *       amount,\n *       reason,\n *       note\n *     }, {\n *       onSuccess: ({ refund }) => {\n *         console.log(refund.amount)\n *       }\n *     })\n *   }\n * \n *   // ...\n * }\n * \n * export default Payment\n * \n * @customNamespace Hooks.Admin.Payments\n * @category Mutations\n */\nexport const useAdminPaymentsRefundPayment = (\n  /**\n   * The payment's ID.\n   */\n  id: string,\n  options?: UseMutationOptions<\n    Response<AdminRefundRes>,\n    Error,\n    AdminPostPaymentRefundsReq\n  >\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n\n  return useMutation(\n    (payload: AdminPostPaymentRefundsReq) =>\n      client.admin.payments.refundPayment(id, payload),\n    buildOptions(\n      queryClient,\n      [adminPaymentQueryKeys.detail(id), adminPaymentQueryKeys.lists()],\n      options\n    )\n  )\n}\n","import {\n  AdminGetProductCategoriesParams,\n  AdminProductCategoriesListRes,\n  AdminGetProductCategoryParams,\n  AdminProductCategoriesCategoryRes,\n} from \"@medusajs/medusa\"\nimport { Response } from \"@medusajs/medusa-js\"\nimport { useQuery } from \"@tanstack/react-query\"\n\nimport { useMedusa } from \"../../../contexts\"\nimport { UseQueryOptionsWrapper } from \"../../../types\"\nimport { queryKeysFactory } from \"../../utils\"\n\nconst ADMIN_PRODUCT_CATEGORIES_QUERY_KEY = `product_categories` as const\nexport const adminProductCategoryKeys = queryKeysFactory(\n  ADMIN_PRODUCT_CATEGORIES_QUERY_KEY\n)\ntype ProductCategoryQueryKeys = typeof adminProductCategoryKeys\n\n/**\n * This hook \n * \n * @example\n * To list product categories:\n * \n * ```tsx\n * import React from \"react\"\n * import { useAdminProductCategories } from \"medusa-react\"\n * \n * function Categories() {\n *   const { \n *     product_categories,\n *     isLoading \n *   } = useAdminProductCategories()\n * \n *   return (\n *     <div>\n *       {isLoading && <span>Loading...</span>}\n *       {product_categories && !product_categories.length && (\n *         <span>No Categories</span>\n *       )}\n *       {product_categories && product_categories.length > 0 && (\n *         <ul>\n *           {product_categories.map(\n *             (category) => (\n *               <li key={category.id}>{category.name}</li>\n *             )\n *           )}\n *         </ul>\n *       )}\n *     </div>\n *   )\n * }\n * \n * export default Categories\n * ```\n * \n * To specify relations that should be retrieved within the product category:\n * \n * ```tsx\n * import React from \"react\"\n * import { useAdminProductCategories } from \"medusa-react\"\n * \n * function Categories() {\n *   const { \n *     product_categories,\n *     isLoading \n *   } = useAdminProductCategories({\n *     expand: \"category_children\"\n *   })\n * \n *   return (\n *     <div>\n *       {isLoading && <span>Loading...</span>}\n *       {product_categories && !product_categories.length && (\n *         <span>No Categories</span>\n *       )}\n *       {product_categories && product_categories.length > 0 && (\n *         <ul>\n *           {product_categories.map(\n *             (category) => (\n *               <li key={category.id}>{category.name}</li>\n *             )\n *           )}\n *         </ul>\n *       )}\n *     </div>\n *   )\n * }\n * \n * export default Categories\n * ```\n * \n * By default, only the first `100` records are retrieved. You can control pagination by specifying the `limit` and `offset` properties:\n * \n * ```tsx\n * import React from \"react\"\n * import { useAdminProductCategories } from \"medusa-react\"\n * \n * function Categories() {\n *   const { \n *     product_categories,\n *     limit,\n *     offset,\n *     isLoading \n *   } = useAdminProductCategories({\n *     expand: \"category_children\",\n *     limit: 20,\n *     offset: 0\n *   })\n * \n *   return (\n *     <div>\n *       {isLoading && <span>Loading...</span>}\n *       {product_categories && !product_categories.length && (\n *         <span>No Categories</span>\n *       )}\n *       {product_categories && product_categories.length > 0 && (\n *         <ul>\n *           {product_categories.map(\n *             (category) => (\n *               <li key={category.id}>{category.name}</li>\n *             )\n *           )}\n *         </ul>\n *       )}\n *     </div>\n *   )\n * }\n * \n * export default Categories\n * ```\n * \n * @customNamespace Hooks.Admin.Product Categories\n * @category Queries\n */\nexport const useAdminProductCategories = (\n  /**\n   * Filters and pagination configurations to apply on the retrieved product categories.\n   */\n  query?: AdminGetProductCategoriesParams,\n  options?: UseQueryOptionsWrapper<\n    Response<AdminProductCategoriesListRes>,\n    Error,\n    ReturnType<ProductCategoryQueryKeys[\"list\"]>\n  >\n) => {\n  const { client } = useMedusa()\n  const { data, ...rest } = useQuery(\n    adminProductCategoryKeys.list(query),\n    () => client.admin.productCategories.list(query),\n    options\n  )\n  return { ...data, ...rest } as const\n}\n\n/**\n * This hook retrieves a product category's details.\n * \n * @example\n * A simple example that retrieves an order by its ID:\n * \n * ```tsx\n * import React from \"react\"\n * import { useAdminProductCategory } from \"medusa-react\"\n * \n * type Props = {\n *   productCategoryId: string\n * }\n * \n * const Category = ({\n *   productCategoryId\n * }: Props) => {\n *   const { \n *     product_category, \n *     isLoading, \n *   } = useAdminProductCategory(productCategoryId)\n * \n *   return (\n *     <div>\n *       {isLoading && <span>Loading...</span>}\n *       {product_category && (\n *         <span>{product_category.name}</span>\n *       )}\n *       \n *     </div>\n *   )\n * }\n * \n * export default Category\n * ```\n * \n * To specify relations that should be retrieved:\n * \n * ```tsx\n * import React from \"react\"\n * import { useAdminProductCategory } from \"medusa-react\"\n * \n * type Props = {\n *   productCategoryId: string\n * }\n * \n * const Category = ({\n *   productCategoryId\n * }: Props) => {\n *   const { \n *     product_category, \n *     isLoading, \n *   } = useAdminProductCategory(productCategoryId, {\n *     expand: \"category_children\"\n *   })\n * \n *   return (\n *     <div>\n *       {isLoading && <span>Loading...</span>}\n *       {product_category && (\n *         <span>{product_category.name}</span>\n *       )}\n *       \n *     </div>\n *   )\n * }\n * \n * export default Category\n * ```\n * \n * @customNamespace Hooks.Admin.Product Categories\n * @category Queries\n */\nexport const useAdminProductCategory = (\n  /**\n   * The product category's ID.\n   */\n  id: string,\n  /**\n   * Configurations to apply on the retrieved product category.\n   */\n  query?: AdminGetProductCategoryParams,\n  options?: UseQueryOptionsWrapper<\n    Response<AdminProductCategoriesCategoryRes>,\n    Error,\n    ReturnType<ProductCategoryQueryKeys[\"detail\"]>\n  >\n) => {\n  const { client } = useMedusa()\n  const { data, ...rest } = useQuery(\n    adminProductCategoryKeys.detail(id),\n    () => client.admin.productCategories.retrieve(id, query),\n    options\n  )\n\n  return { ...data, ...rest } as const\n}\n","import {\n  useMutation,\n  UseMutationOptions,\n  useQueryClient,\n} from \"@tanstack/react-query\"\nimport { Response } from \"@medusajs/medusa-js\"\nimport {\n  AdminDeleteProductCategoriesCategoryProductsBatchReq,\n  AdminPostProductCategoriesCategoryProductsBatchReq,\n  AdminPostProductCategoriesCategoryReq,\n  AdminPostProductCategoriesReq,\n  AdminProductCategoriesCategoryDeleteRes,\n  AdminProductCategoriesCategoryRes,\n} from \"@medusajs/medusa\"\n\nimport { useMedusa } from \"../../../contexts\"\nimport { buildOptions } from \"../../utils/buildOptions\"\nimport { adminProductCategoryKeys } from \"./queries\"\nimport { adminProductKeys } from \"../products\"\n\n/**\n * This hook creates a product category.\n * \n * @example\n * import React from \"react\"\n * import { useAdminCreateProductCategory } from \"medusa-react\"\n * \n * const CreateCategory = () => {\n *   const createCategory = useAdminCreateProductCategory()\n *   // ...\n * \n *   const handleCreate = (\n *     name: string\n *   ) => {\n *     createCategory.mutate({\n *       name,\n *     }, {\n *       onSuccess: ({ product_category }) => {\n *         console.log(product_category.id)\n *       }\n *     })\n *   }\n * \n *   // ...\n * }\n * \n * export default CreateCategory\n * \n * @customNamespace Hooks.Admin.Product Categories\n * @category Mutations\n */\nexport const useAdminCreateProductCategory = (\n  options?: UseMutationOptions<\n    Response<AdminProductCategoriesCategoryRes>,\n    Error,\n    AdminPostProductCategoriesReq\n  >\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n\n  return useMutation(\n    (payload: AdminPostProductCategoriesReq) =>\n      client.admin.productCategories.create(payload),\n    buildOptions(\n      queryClient,\n      [adminProductCategoryKeys.list(), adminProductKeys.details()],\n      options\n    )\n  )\n}\n\n/**\n * This hook updates a product category.\n * \n * @example\n * import React from \"react\"\n * import { useAdminUpdateProductCategory } from \"medusa-react\"\n * \n * type Props = {\n *   productCategoryId: string\n * }\n * \n * const Category = ({\n *   productCategoryId\n * }: Props) => {\n *   const updateCategory = useAdminUpdateProductCategory(\n *     productCategoryId\n *   )\n *   // ...\n * \n *   const handleUpdate = (\n *     name: string\n *   ) => {\n *     updateCategory.mutate({\n *       name,\n *     }, {\n *       onSuccess: ({ product_category }) => {\n *         console.log(product_category.id)\n *       }\n *     })\n *   }\n * \n *   // ...\n * }\n * \n * export default Category\n * \n * @customNamespace Hooks.Admin.Product Categories\n * @category Mutations\n */\nexport const useAdminUpdateProductCategory = (\n  /**\n   * The product category's ID.\n   */\n  id: string,\n  options?: UseMutationOptions<\n    Response<AdminProductCategoriesCategoryRes>,\n    Error,\n    AdminPostProductCategoriesCategoryReq\n  >\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n  return useMutation(\n    (payload: AdminPostProductCategoriesCategoryReq) =>\n      client.admin.productCategories.update(id, payload),\n      buildOptions(\n        queryClient,\n        [\n          adminProductCategoryKeys.lists(),\n          adminProductCategoryKeys.detail(id),\n          adminProductKeys.details(),\n        ],\n        options\n      )\n    )\n}\n\n/**\n * This hook deletes a product category. This does not delete associated products.\n * \n * @example\n * import React from \"react\"\n * import { useAdminDeleteProductCategory } from \"medusa-react\"\n * \n * type Props = {\n *   productCategoryId: string\n * }\n * \n * const Category = ({\n *   productCategoryId\n * }: Props) => {\n *   const deleteCategory = useAdminDeleteProductCategory(\n *     productCategoryId\n *   )\n *   // ...\n * \n *   const handleDelete = () => {\n *     deleteCategory.mutate(void 0, {\n *       onSuccess: ({ id, object, deleted }) => {\n *         console.log(id)\n *       }\n *     })\n *   }\n * \n *   // ...\n * }\n * \n * export default Category\n * \n * @customNamespace Hooks.Admin.Product Categories\n * @category Mutations\n */\nexport const useAdminDeleteProductCategory = (\n  /**\n   * The product category's ID.\n   */\n  id: string,\n  options?: UseMutationOptions<\n    Response<AdminProductCategoriesCategoryDeleteRes>,\n    Error,\n    void\n  >\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n\n  return useMutation(\n    () => client.admin.productCategories.delete(id),\n    buildOptions(\n      queryClient,\n      [\n        adminProductCategoryKeys.lists(),\n        adminProductCategoryKeys.detail(id),\n        adminProductKeys.all\n      ],\n      options\n    )\n  )\n}\n\n/**\n * This hook adds a list of products to a product category.\n * \n * @example\n * import React from \"react\"\n * import { useAdminAddProductsToCategory } from \"medusa-react\"\n * \n * type ProductsData = {\n *   id: string\n * }\n * \n * type Props = {\n *   productCategoryId: string\n * }\n * \n * const Category = ({\n *   productCategoryId\n * }: Props) => {\n *   const addProducts = useAdminAddProductsToCategory(\n *     productCategoryId\n *   )\n *   // ...\n * \n *   const handleAddProducts = (\n *     productIds: ProductsData[]\n *   ) => {\n *     addProducts.mutate({\n *       product_ids: productIds\n *     }, {\n *       onSuccess: ({ product_category }) => {\n *         console.log(product_category.products)\n *       }\n *     })\n *   }\n * \n *   // ...\n * }\n * \n * export default Category\n * \n * @customNamespace Hooks.Admin.Product Categories\n * @category Mutations\n */\nexport const useAdminAddProductsToCategory = (\n  /**\n   * The product category's ID.\n   */\n  id: string,\n  options?: UseMutationOptions<\n    Response<AdminProductCategoriesCategoryRes>,\n    Error,\n    AdminPostProductCategoriesCategoryProductsBatchReq\n  >\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n  return useMutation(\n    (payload: AdminPostProductCategoriesCategoryProductsBatchReq) => {\n      return client.admin.productCategories.addProducts(id, payload)\n    },\n    buildOptions(\n      queryClient,\n      [\n        adminProductCategoryKeys.lists(),\n        adminProductCategoryKeys.detail(id),\n        adminProductKeys.list({ product_category_id: [id] }),\n      ],\n      options\n    )\n  )\n}\n\n/**\n * This hook removes a list of products from a product category.\n * \n * @example\n * import React from \"react\"\n * import { useAdminDeleteProductsFromCategory } from \"medusa-react\"\n * \n * type ProductsData = {\n *   id: string\n * }\n * \n * type Props = {\n *   productCategoryId: string\n * }\n * \n * const Category = ({\n *   productCategoryId\n * }: Props) => {\n *   const deleteProducts = useAdminDeleteProductsFromCategory(\n *     productCategoryId\n *   )\n *   // ...\n * \n *   const handleDeleteProducts = (\n *     productIds: ProductsData[]\n *   ) => {\n *     deleteProducts.mutate({\n *       product_ids: productIds\n *     }, {\n *       onSuccess: ({ product_category }) => {\n *         console.log(product_category.products)\n *       }\n *     })\n *   }\n * \n *   // ...\n * }\n * \n * export default Category\n * \n * @customNamespace Hooks.Admin.Product Categories\n * @category Mutations\n */\nexport const useAdminDeleteProductsFromCategory = (\n  /**\n   * The product category's ID.\n   */\n  id: string,\n  options?: UseMutationOptions<\n    Response<AdminProductCategoriesCategoryRes>,\n    Error,\n    AdminDeleteProductCategoriesCategoryProductsBatchReq\n  >\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n  return useMutation(\n    (payload: AdminDeleteProductCategoriesCategoryProductsBatchReq) => {\n      return client.admin.productCategories.removeProducts(id, payload)\n    },\n    buildOptions(\n      queryClient,\n      [\n        adminProductCategoryKeys.lists(),\n        adminProductCategoryKeys.detail(id),\n        adminProductKeys.list({ product_category_id: [id] }),\n      ],\n      options\n    )\n  )\n}\n","import {\n  AdminGetProductTagsParams,\n  AdminProductTagsListRes,\n} from \"@medusajs/medusa\"\nimport { Response } from \"@medusajs/medusa-js\"\nimport { useQuery } from \"@tanstack/react-query\"\nimport { useMedusa } from \"../../../contexts\"\nimport { UseQueryOptionsWrapper } from \"../../../types\"\nimport { queryKeysFactory } from \"../../utils/index\"\n\nconst ADMIN_PRODUCT_TAGS_QUERY_KEY = `admin_product_tags` as const\n\nexport const adminProductTagKeys = queryKeysFactory(\n  ADMIN_PRODUCT_TAGS_QUERY_KEY\n)\n\ntype ProductQueryKeys = typeof adminProductTagKeys\n\n/**\n * This hook retrieves a list of product tags. The product tags can be filtered by fields such as `q` or `value` passed \n * in the `query` parameter. The product tags can also be sorted or paginated.\n * \n * @example\n * To list product tags:\n * \n * ```tsx\n * import React from \"react\"\n * import { useAdminProductTags } from \"medusa-react\"\n * \n * function ProductTags() {\n *   const { \n *     product_tags,\n *     isLoading \n *   } = useAdminProductTags()\n * \n *   return (\n *     <div>\n *       {isLoading && <span>Loading...</span>}\n *       {product_tags && !product_tags.length && (\n *         <span>No Product Tags</span>\n *       )}\n *       {product_tags && product_tags.length > 0 && (\n *         <ul>\n *           {product_tags.map(\n *             (tag) => (\n *               <li key={tag.id}>{tag.value}</li>\n *             )\n *           )}\n *         </ul>\n *       )}\n *     </div>\n *   )\n * }\n * \n * export default ProductTags\n * ```\n * \n * By default, only the first `10` records are retrieved. You can control pagination by specifying the `limit` and `offset` properties:\n * \n * ```tsx\n * import React from \"react\"\n * import { useAdminProductTags } from \"medusa-react\"\n * \n * function ProductTags() {\n *   const { \n *     product_tags,\n *     limit,\n *     offset,\n *     isLoading \n *   } = useAdminProductTags({\n *     limit: 20,\n *     offset: 0\n *   })\n * \n *   return (\n *     <div>\n *       {isLoading && <span>Loading...</span>}\n *       {product_tags && !product_tags.length && (\n *         <span>No Product Tags</span>\n *       )}\n *       {product_tags && product_tags.length > 0 && (\n *         <ul>\n *           {product_tags.map(\n *             (tag) => (\n *               <li key={tag.id}>{tag.value}</li>\n *             )\n *           )}\n *         </ul>\n *       )}\n *     </div>\n *   )\n * }\n * \n * export default ProductTags\n * ```\n * \n * @customNamespace Hooks.Admin.Product Tags\n * @category Queries\n */\nexport const useAdminProductTags = (\n  /**\n   * Filters and pagination configurations to apply on the retrieved product tags.\n   */\n  query?: AdminGetProductTagsParams,\n  options?: UseQueryOptionsWrapper<\n    Response<AdminProductTagsListRes>,\n    Error,\n    ReturnType<ProductQueryKeys[\"list\"]>\n  >\n) => {\n  const { client } = useMedusa()\n  const { data, ...rest } = useQuery(\n    adminProductTagKeys.list(query),\n    () => client.admin.productTags.list(query),\n    options\n  )\n  return { ...data, ...rest } as const\n}\n","import {\n  AdminGetProductTypesParams,\n  AdminProductTypesListRes,\n} from \"@medusajs/medusa\"\nimport { Response } from \"@medusajs/medusa-js\"\nimport { useQuery } from \"@tanstack/react-query\"\nimport { useMedusa } from \"../../../contexts\"\nimport { UseQueryOptionsWrapper } from \"../../../types\"\nimport { queryKeysFactory } from \"../../utils/index\"\n\nconst ADMIN_PRODUCT_TYPES_QUERY_KEY = `admin_product_types` as const\n\nexport const adminProductTypeKeys = queryKeysFactory(\n  ADMIN_PRODUCT_TYPES_QUERY_KEY\n)\n\ntype ProductTypesQueryKeys = typeof adminProductTypeKeys\n\n/**\n * This hook retrieves a list of product types. The product types can be filtered by fields such as `q` or `value` passed in the `query` parameter.\n * The product types can also be sorted or paginated.\n * \n * @example\n * To list product types:\n * \n * ```tsx\n * import React from \"react\"\n * import { useAdminProductTypes } from \"medusa-react\"\n * \n * function ProductTypes() {\n *   const { \n *     product_types,\n *     isLoading \n *   } = useAdminProductTypes()\n * \n *   return (\n *     <div>\n *       {isLoading && <span>Loading...</span>}\n *       {product_types && !product_types.length && (\n *         <span>No Product Tags</span>\n *       )}\n *       {product_types && product_types.length > 0 && (\n *         <ul>\n *           {product_types.map(\n *             (type) => (\n *               <li key={type.id}>{type.value}</li>\n *             )\n *           )}\n *         </ul>\n *       )}\n *     </div>\n *   )\n * }\n * \n * export default ProductTypes\n * ```\n * \n * By default, only the first `20` records are retrieved. You can control pagination by specifying the `limit` and `offset` properties:\n * \n * ```tsx\n * import React from \"react\"\n * import { useAdminProductTypes } from \"medusa-react\"\n * \n * function ProductTypes() {\n *   const { \n *     product_types,\n *     limit,\n *     offset,\n *     isLoading \n *   } = useAdminProductTypes({\n *     limit: 10,\n *     offset: 0\n *   })\n * \n *   return (\n *     <div>\n *       {isLoading && <span>Loading...</span>}\n *       {product_types && !product_types.length && (\n *         <span>No Product Tags</span>\n *       )}\n *       {product_types && product_types.length > 0 && (\n *         <ul>\n *           {product_types.map(\n *             (type) => (\n *               <li key={type.id}>{type.value}</li>\n *             )\n *           )}\n *         </ul>\n *       )}\n *     </div>\n *   )\n * }\n * \n * export default ProductTypes\n * ```\n * \n * @customNamespace Hooks.Admin.Product Types\n * @category Queries\n */\nexport const useAdminProductTypes = (\n  /**\n   * Filters and pagination configurations to apply on the retrieved product types.\n   */\n  query?: AdminGetProductTypesParams,\n  options?: UseQueryOptionsWrapper<\n    Response<AdminProductTypesListRes>,\n    Error,\n    ReturnType<ProductTypesQueryKeys[\"list\"]>\n  >\n) => {\n  const { client } = useMedusa()\n  const { data, ...rest } = useQuery(\n    adminProductTypeKeys.list(query),\n    () => client.admin.productTypes.list(query),\n    options\n  )\n  return { ...data, ...rest } as const\n}\n","import {\n  AdminPublishableApiKeysListRes,\n  AdminPublishableApiKeysListSalesChannelsRes,\n  AdminPublishableApiKeysRes,\n  GetPublishableApiKeySalesChannelsParams,\n  GetPublishableApiKeysParams,\n} from \"@medusajs/medusa\"\nimport { Response } from \"@medusajs/medusa-js\"\nimport { useQuery } from \"@tanstack/react-query\"\n\nimport { useMedusa } from \"../../../contexts\"\nimport { UseQueryOptionsWrapper } from \"../../../types\"\nimport { queryKeysFactory } from \"../../utils\"\n\nconst ADMIN_PUBLISHABLE_API_KEYS_QUERY_KEY =\n  `admin_publishable_api_keys` as const\n\nexport const adminPublishableApiKeysKeys = {\n  ...queryKeysFactory(ADMIN_PUBLISHABLE_API_KEYS_QUERY_KEY),\n  detailSalesChannels(id: string, query?: any) {\n    return [\n      ...this.detail(id),\n      \"sales_channels\" as const,\n      { ...(query || {}) },\n    ] as const\n  },\n}\n\ntype PublishableApiKeyQueryKeys = typeof adminPublishableApiKeysKeys\n\n/**\n * This hook retrieves a publishable API key's details.\n * \n * @example\n * import React from \"react\"\n * import { \n *   useAdminPublishableApiKey,\n * } from \"medusa-react\"\n * \n * type Props = {\n *   publishableApiKeyId: string\n * }\n * \n * const PublishableApiKey = ({\n *   publishableApiKeyId\n * }: Props) => {\n *   const { publishable_api_key, isLoading } = \n *     useAdminPublishableApiKey(\n *       publishableApiKeyId\n *     )\n *  \n *     \n *   return (\n *     <div>\n *       {isLoading && <span>Loading...</span>}\n *       {publishable_api_key && <span>{publishable_api_key.title}</span>}\n *     </div>\n *   )\n * }\n * \n * export default PublishableApiKey\n * \n * @customNamespace Hooks.Admin.Publishable API Keys\n * @category Queries\n */\nexport const useAdminPublishableApiKey = (\n  /**\n   * The publishable API key's ID.\n   */\n  id: string,\n  options?: UseQueryOptionsWrapper<\n    Response<AdminPublishableApiKeysRes>,\n    Error,\n    ReturnType<PublishableApiKeyQueryKeys[\"detail\"]>\n  >\n) => {\n  const { client } = useMedusa()\n  const { data, ...rest } = useQuery(\n    adminPublishableApiKeysKeys.detail(id),\n    () => client.admin.publishableApiKeys.retrieve(id),\n    options\n  )\n  return { ...data, ...rest } as const\n}\n\n/**\n * This hook retrieves a list of publishable API keys. The publishable API keys can be filtered by fields such as `q` passed in `query`. \n * The publishable API keys can also be paginated.\n * \n * @example\n * To list publishable API keys:\n * \n * ```tsx\n * import React from \"react\"\n * import { PublishableApiKey } from \"@medusajs/medusa\"\n * import { useAdminPublishableApiKeys } from \"medusa-react\"\n * \n * const PublishableApiKeys = () => {\n *   const { publishable_api_keys, isLoading } = \n *     useAdminPublishableApiKeys()\n * \n *   return (\n *     <div>\n *       {isLoading && <span>Loading...</span>}\n *       {publishable_api_keys && !publishable_api_keys.length && (\n *         <span>No Publishable API Keys</span>\n *       )}\n *       {publishable_api_keys && \n *         publishable_api_keys.length > 0 && (\n *         <ul>\n *           {publishable_api_keys.map(\n *             (publishableApiKey: PublishableApiKey) => (\n *               <li key={publishableApiKey.id}>\n *                 {publishableApiKey.title}\n *               </li>\n *             )\n *           )}\n *         </ul>\n *       )}\n *     </div>\n *   )\n * }\n * \n * export default PublishableApiKeys\n * ```\n * \n * By default, only the first `20` records are retrieved. You can control pagination by specifying the `limit` and `offset` properties:\n * \n * ```tsx\n * import React from \"react\"\n * import { PublishableApiKey } from \"@medusajs/medusa\"\n * import { useAdminPublishableApiKeys } from \"medusa-react\"\n * \n * const PublishableApiKeys = () => {\n *   const { \n *     publishable_api_keys, \n *     limit,\n *     offset,\n *     isLoading\n *   } = \n *     useAdminPublishableApiKeys({\n *       limit: 50,\n *       offset: 0\n *     })\n * \n *   return (\n *     <div>\n *       {isLoading && <span>Loading...</span>}\n *       {publishable_api_keys && !publishable_api_keys.length && (\n *         <span>No Publishable API Keys</span>\n *       )}\n *       {publishable_api_keys && \n *         publishable_api_keys.length > 0 && (\n *         <ul>\n *           {publishable_api_keys.map(\n *             (publishableApiKey: PublishableApiKey) => (\n *               <li key={publishableApiKey.id}>\n *                 {publishableApiKey.title}\n *               </li>\n *             )\n *           )}\n *         </ul>\n *       )}\n *     </div>\n *   )\n * }\n * \n * export default PublishableApiKeys\n * ```\n * \n * @customNamespace Hooks.Admin.Publishable API Keys\n * @category Queries\n */\nexport const useAdminPublishableApiKeys = (\n  /**\n   * Filters and pagination configurations to apply on the retrieved publishable API keys.\n   */\n  query?: GetPublishableApiKeysParams,\n  options?: UseQueryOptionsWrapper<\n    Response<AdminPublishableApiKeysListRes>,\n    Error,\n    ReturnType<PublishableApiKeyQueryKeys[\"list\"]>\n  >\n) => {\n  const { client } = useMedusa()\n  const { data, ...rest } = useQuery(\n    adminPublishableApiKeysKeys.list(query),\n    () => client.admin.publishableApiKeys.list(query),\n    options\n  )\n  return { ...data, ...rest } as const\n}\n\n/**\n * This hook lists the sales channels associated with a publishable API key. The sales channels can be \n * filtered by fields such as `q` passed in the `query` parameter.\n * \n * @example\n * import React from \"react\"\n * import { \n *   useAdminPublishableApiKeySalesChannels,\n * } from \"medusa-react\"\n * \n * type Props = {\n *   publishableApiKeyId: string\n * }\n * \n * const SalesChannels = ({\n *   publishableApiKeyId\n * }: Props) => {\n *   const { sales_channels, isLoading } = \n *     useAdminPublishableApiKeySalesChannels(\n *       publishableApiKeyId\n *     )\n * \n *   return (\n *     <div>\n *       {isLoading && <span>Loading...</span>}\n *       {sales_channels && !sales_channels.length && (\n *         <span>No Sales Channels</span>\n *       )}\n *       {sales_channels && sales_channels.length > 0 && (\n *         <ul>\n *           {sales_channels.map((salesChannel) => (\n *             <li key={salesChannel.id}>{salesChannel.name}</li>\n *           ))}\n *         </ul>\n *       )}\n *     </div>\n *   )\n * }\n * \n * export default SalesChannels\n * \n * @customNamespace Hooks.Admin.Publishable API Keys\n * @category Queries\n */\nexport const useAdminPublishableApiKeySalesChannels = (\n  /**\n   * The publishable API Key's ID.\n   */\n  id: string,\n  /**\n   * Filters to apply on the retrieved sales channels.\n   */\n  query?: GetPublishableApiKeySalesChannelsParams,\n  options?: UseQueryOptionsWrapper<\n    Response<AdminPublishableApiKeysListSalesChannelsRes>,\n    Error,\n    ReturnType<PublishableApiKeyQueryKeys[\"detailSalesChannels\"]>\n  >\n) => {\n  const { client } = useMedusa()\n  const { data, ...rest } = useQuery(\n    adminPublishableApiKeysKeys.detailSalesChannels(id, query),\n    () => client.admin.publishableApiKeys.listSalesChannels(id, query),\n    options\n  )\n  return { ...data, ...rest } as const\n}\n","import { Response } from \"@medusajs/medusa-js\"\nimport {\n  useMutation,\n  UseMutationOptions,\n  useQueryClient,\n} from \"@tanstack/react-query\"\n\nimport {\n  AdminDeletePublishableApiKeySalesChannelsBatchReq,\n  AdminPostPublishableApiKeySalesChannelsBatchReq,\n  AdminPostPublishableApiKeysPublishableApiKeyReq,\n  AdminPostPublishableApiKeysReq,\n  AdminPublishableApiKeyDeleteRes,\n  AdminPublishableApiKeysRes,\n} from \"@medusajs/medusa\"\n\nimport { useMedusa } from \"../../../contexts\"\nimport { buildOptions } from \"../../utils/buildOptions\"\nimport { adminPublishableApiKeysKeys } from \"./queries\"\n\n/**\n * This hook creates a publishable API key.\n * \n * @example\n * import React from \"react\"\n * import { useAdminCreatePublishableApiKey } from \"medusa-react\"\n * \n * const CreatePublishableApiKey = () => {\n *   const createKey = useAdminCreatePublishableApiKey()\n *   // ...\n * \n *   const handleCreate = (title: string) => {\n *     createKey.mutate({\n *       title,\n *     }, {\n *       onSuccess: ({ publishable_api_key }) => {\n *         console.log(publishable_api_key.id)\n *       }\n *     })\n *   }\n * \n *   // ...\n * }\n * \n * export default CreatePublishableApiKey\n * \n * @customNamespace Hooks.Admin.Publishable API Keys\n * @category Mutations\n */\nexport const useAdminCreatePublishableApiKey = (\n  options?: UseMutationOptions<\n    Response<AdminPublishableApiKeysRes>,\n    Error,\n    AdminPostPublishableApiKeysReq\n  >\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n  return useMutation(\n    (payload: AdminPostPublishableApiKeysReq) =>\n      client.admin.publishableApiKeys.create(payload),\n    buildOptions(queryClient, [adminPublishableApiKeysKeys.lists()], options)\n  )\n}\n\n/**\n * This hook updates a publishable API key's details.\n * \n * @example\n * import React from \"react\"\n * import { useAdminUpdatePublishableApiKey } from \"medusa-react\"\n * \n * type Props = {\n *   publishableApiKeyId: string\n * }\n * \n * const PublishableApiKey = ({\n *   publishableApiKeyId\n * }: Props) => {\n *   const updateKey = useAdminUpdatePublishableApiKey(\n *     publishableApiKeyId\n *   )\n *   // ...\n * \n *   const handleUpdate = (title: string) => {\n *     updateKey.mutate({\n *       title,\n *     }, {\n *       onSuccess: ({ publishable_api_key }) => {\n *         console.log(publishable_api_key.id)\n *       }\n *     })\n *   }\n * \n *   // ...\n * }\n * \n * export default PublishableApiKey\n * \n * @customNamespace Hooks.Admin.Publishable API Keys\n * @category Mutations\n */\nexport const useAdminUpdatePublishableApiKey = (\n  /**\n   * The publishable API key's ID.\n   */\n  id: string,\n  options?: UseMutationOptions<\n    Response<AdminPublishableApiKeysRes>,\n    Error,\n    AdminPostPublishableApiKeysPublishableApiKeyReq\n  >\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n\n  return useMutation(\n    (payload: AdminPostPublishableApiKeysPublishableApiKeyReq) =>\n      client.admin.publishableApiKeys.update(id, payload),\n    buildOptions(\n      queryClient,\n      [\n        adminPublishableApiKeysKeys.lists(),\n        adminPublishableApiKeysKeys.detail(id),\n        adminPublishableApiKeysKeys.details(),\n      ],\n      options\n    )\n  )\n}\n\n/**\n * This hook deletes a publishable API key. Associated resources, such as sales channels, are not deleted.\n * \n * @example\n * import React from \"react\"\n * import { useAdminDeletePublishableApiKey } from \"medusa-react\"\n * \n * type Props = {\n *   publishableApiKeyId: string\n * }\n * \n * const PublishableApiKey = ({\n *   publishableApiKeyId\n * }: Props) => {\n *   const deleteKey = useAdminDeletePublishableApiKey(\n *     publishableApiKeyId\n *   )\n *   // ...\n * \n *   const handleDelete = () => {\n *     deleteKey.mutate(void 0, {\n *       onSuccess: ({ id, object, deleted }) => {\n *         console.log(id)\n *       }\n *     })\n *   }\n * \n *   // ...\n * }\n * \n * export default PublishableApiKey\n * \n * @customNamespace Hooks.Admin.Publishable API Keys\n * @category Mutations\n */\nexport const useAdminDeletePublishableApiKey = (\n  /**\n   * The publishable API key's ID.\n   */\n  id: string,\n  options?: UseMutationOptions<\n    Response<AdminPublishableApiKeyDeleteRes>,\n    Error,\n    void\n  >\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n\n  return useMutation(\n    () => client.admin.publishableApiKeys.delete(id),\n    buildOptions(\n      queryClient,\n      [\n        adminPublishableApiKeysKeys.detail(id),\n        adminPublishableApiKeysKeys.lists(),\n      ],\n      options\n    )\n  )\n}\n\n/**\n * This hook revokes a publishable API key. Revoking the publishable API Key can't be undone, and the key can't be used in future requests.\n * \n * @example\n * import React from \"react\"\n * import { useAdminRevokePublishableApiKey } from \"medusa-react\"\n * \n * type Props = {\n *   publishableApiKeyId: string\n * }\n * \n * const PublishableApiKey = ({\n *   publishableApiKeyId\n * }: Props) => {\n *   const revokeKey = useAdminRevokePublishableApiKey(\n *     publishableApiKeyId\n *   )\n *   // ...\n * \n *   const handleRevoke = () => {\n *     revokeKey.mutate(void 0, {\n *       onSuccess: ({ publishable_api_key }) => {\n *         console.log(publishable_api_key.revoked_at)\n *       }\n *     })\n *   }\n * \n *   // ...\n * }\n * \n * export default PublishableApiKey\n * \n * @customNamespace Hooks.Admin.Publishable API Keys\n * @category Mutations\n */\nexport const useAdminRevokePublishableApiKey = (\n  /**\n   * The publishable API key's ID.\n   */\n  id: string,\n  options?: UseMutationOptions<Response<AdminPublishableApiKeysRes>, Error>\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n\n  return useMutation(\n    () => client.admin.publishableApiKeys.revoke(id),\n    buildOptions(\n      queryClient,\n      [\n        adminPublishableApiKeysKeys.lists(),\n        adminPublishableApiKeysKeys.detail(id),\n      ],\n      options\n    )\n  )\n}\n\n/**\n * This hook adds a list of sales channels to a publishable API key.\n * \n * @example\n * import React from \"react\"\n * import {\n *   useAdminAddPublishableKeySalesChannelsBatch,\n * } from \"medusa-react\"\n * \n * type Props = {\n *   publishableApiKeyId: string\n * }\n * \n * const PublishableApiKey = ({\n *   publishableApiKeyId\n * }: Props) => {\n *   const addSalesChannels = \n *     useAdminAddPublishableKeySalesChannelsBatch(\n *       publishableApiKeyId\n *     )\n *   // ...\n * \n *   const handleAdd = (salesChannelId: string) => {\n *     addSalesChannels.mutate({\n *       sales_channel_ids: [\n *         {\n *           id: salesChannelId,\n *         },\n *       ],\n *     }, {\n *       onSuccess: ({ publishable_api_key }) => {\n *         console.log(publishable_api_key.id)\n *       }\n *     })\n *   }\n * \n *   // ...\n * }\n * \n * export default PublishableApiKey\n * \n * @customNamespace Hooks.Admin.Publishable API Keys\n * @category Mutations\n */\nexport const useAdminAddPublishableKeySalesChannelsBatch = (\n  /**\n   * The publishable API key's ID.\n   */\n  id: string,\n  options?: UseMutationOptions<\n    Response<AdminPublishableApiKeysRes>,\n    Error,\n    AdminPostPublishableApiKeySalesChannelsBatchReq\n  >\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n\n  return useMutation(\n    (payload: AdminPostPublishableApiKeySalesChannelsBatchReq) =>\n      client.admin.publishableApiKeys.addSalesChannelsBatch(id, payload),\n    buildOptions(\n      queryClient,\n      [adminPublishableApiKeysKeys.detailSalesChannels(id)],\n      options\n    )\n  )\n}\n\n/**\n * This hook removes a list of sales channels from a publishable API key. This doesn't delete the sales channels and only \n * removes the association between them and the publishable API key.\n * \n * @example\n * import React from \"react\"\n * import { \n *   useAdminRemovePublishableKeySalesChannelsBatch,\n * } from \"medusa-react\"\n * \n * type Props = {\n *   publishableApiKeyId: string\n * }\n * \n * const PublishableApiKey = ({\n *   publishableApiKeyId\n * }: Props) => {\n *   const deleteSalesChannels = \n *     useAdminRemovePublishableKeySalesChannelsBatch(\n *       publishableApiKeyId\n *     )\n *   // ...\n * \n *   const handleDelete = (salesChannelId: string) => {\n *     deleteSalesChannels.mutate({\n *       sales_channel_ids: [\n *         {\n *           id: salesChannelId,\n *         },\n *       ],\n *     }, {\n *       onSuccess: ({ publishable_api_key }) => {\n *         console.log(publishable_api_key.id)\n *       }\n *     })\n *   }\n * \n *   // ...\n * }\n * \n * export default PublishableApiKey\n * \n * @customNamespace Hooks.Admin.Publishable API Keys\n * @category Mutations\n */\nexport const useAdminRemovePublishableKeySalesChannelsBatch = (\n  /**\n   * The publishable API key's ID.\n   */\n  id: string,\n  options?: UseMutationOptions<\n    Response<AdminPublishableApiKeysRes>,\n    Error,\n    AdminDeletePublishableApiKeySalesChannelsBatchReq\n  >\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n\n  return useMutation(\n    (payload: AdminDeletePublishableApiKeySalesChannelsBatchReq) =>\n      client.admin.publishableApiKeys.deleteSalesChannelsBatch(id, payload),\n    buildOptions(\n      queryClient,\n      [adminPublishableApiKeysKeys.detailSalesChannels(id)],\n      options\n    )\n  )\n}\n","import {\n  AdminGetRegionsParams,\n  AdminGetRegionsRegionFulfillmentOptionsRes,\n  AdminRegionsListRes,\n  AdminRegionsRes,\n} from \"@medusajs/medusa\"\nimport { Response } from \"@medusajs/medusa-js\"\nimport { useQuery } from \"@tanstack/react-query\"\nimport { useMedusa } from \"../../../contexts\"\nimport { UseQueryOptionsWrapper } from \"../../../types\"\nimport { queryKeysFactory } from \"../../utils/index\"\n\nconst ADMIN_REGIONS_QUERY_KEY = `admin_regions` as const\n\nexport const adminRegionKeys = queryKeysFactory(ADMIN_REGIONS_QUERY_KEY)\n\ntype RegionQueryKeys = typeof adminRegionKeys\n\n/**\n * This hook retrieves a list of Regions. The regions can be filtered by fields such as `created_at` passed in the `query` parameter. \n * The regions can also be paginated.\n * \n * @example\n * To list regions:\n * \n * ```tsx\n * import React from \"react\"\n * import { useAdminRegions } from \"medusa-react\"\n * \n * const Regions = () => {\n *   const { regions, isLoading } = useAdminRegions()\n * \n *   return (\n *     <div>\n *       {isLoading && <span>Loading...</span>}\n *       {regions && !regions.length && <span>No Regions</span>}\n *       {regions && regions.length > 0 && (\n *         <ul>\n *           {regions.map((region) => (\n *             <li key={region.id}>{region.name}</li>\n *           ))}\n *         </ul>\n *       )}\n *     </div>\n *   )\n * }\n * \n * export default Regions\n * ```\n * \n * By default, only the first `50` records are retrieved. You can control pagination by specifying the `limit` and `offset` properties:\n * \n * ```tsx\n * import React from \"react\"\n * import { useAdminRegions } from \"medusa-react\"\n * \n * const Regions = () => {\n *   const { \n *     regions, \n *     limit,\n *     offset,\n *     isLoading\n *   } = useAdminRegions({\n *     limit: 20,\n *     offset: 0\n *   })\n * \n *   return (\n *     <div>\n *       {isLoading && <span>Loading...</span>}\n *       {regions && !regions.length && <span>No Regions</span>}\n *       {regions && regions.length > 0 && (\n *         <ul>\n *           {regions.map((region) => (\n *             <li key={region.id}>{region.name}</li>\n *           ))}\n *         </ul>\n *       )}\n *     </div>\n *   )\n * }\n * \n * export default Regions\n * ```\n * \n * @customNamespace Hooks.Admin.Regions\n * @category Queries\n */\nexport const useAdminRegions = (\n  /**\n   * Filters and pagination configurations to apply on the retrieved regions.\n   */\n  query?: AdminGetRegionsParams,\n  options?: UseQueryOptionsWrapper<\n    Response<AdminRegionsListRes>,\n    Error,\n    ReturnType<RegionQueryKeys[\"list\"]>\n  >\n) => {\n  const { client } = useMedusa()\n  const { data, ...rest } = useQuery(\n    adminRegionKeys.list(query),\n    () => client.admin.regions.list(query),\n    options\n  )\n  return { ...data, ...rest } as const\n}\n\n/**\n * This hook retrieves a region's details.\n * \n * @example\n * import React from \"react\"\n * import { useAdminRegion } from \"medusa-react\"\n * \n * type Props = {\n *   regionId: string\n * }\n * \n * const Region = ({\n *   regionId\n * }: Props) => {\n *   const { region, isLoading } = useAdminRegion(\n *     regionId\n *   )\n * \n *   return (\n *     <div>\n *       {isLoading && <span>Loading...</span>}\n *       {region && <span>{region.name}</span>}\n *     </div>\n *   )\n * }\n * \n * export default Region\n * \n * @customNamespace Hooks.Admin.Regions\n * @category Queries\n */\nexport const useAdminRegion = (\n  /**\n   * The region's ID.\n   */\n  id: string,\n  options?: UseQueryOptionsWrapper<\n    Response<AdminRegionsRes>,\n    Error,\n    ReturnType<RegionQueryKeys[\"detail\"]>\n  >\n) => {\n  const { client } = useMedusa()\n  const { data, ...rest } = useQuery(\n    adminRegionKeys.detail(id),\n    () => client.admin.regions.retrieve(id),\n    options\n  )\n  return { ...data, ...rest } as const\n}\n\n/**\n * This hook retrieves a list of fulfillment options available in a region.\n * \n * @example\n * import React from \"react\"\n * import { \n *   useAdminRegionFulfillmentOptions\n * } from \"medusa-react\"\n * \n * type Props = {\n *   regionId: string\n * }\n * \n * const Region = ({\n *   regionId\n * }: Props) => {\n *   const { \n *     fulfillment_options, \n *     isLoading\n *   } = useAdminRegionFulfillmentOptions(\n *     regionId\n *   )\n * \n *   return (\n *     <div>\n *       {isLoading && <span>Loading...</span>}\n *       {fulfillment_options && !fulfillment_options.length && (\n *         <span>No Regions</span>\n *       )}\n *       {fulfillment_options && \n *         fulfillment_options.length > 0 && (\n *         <ul>\n *           {fulfillment_options.map((option) => (\n *             <li key={option.provider_id}>\n *               {option.provider_id}\n *             </li>\n *           ))}\n *         </ul>\n *           )}\n *     </div>\n *   )\n * }\n * \n * export default Region\n * \n * @customNamespace Hooks.Admin.Regions\n * @category Queries\n */\nexport const useAdminRegionFulfillmentOptions = (\n  /**\n   * The region's ID.\n   */\n  regionId: string,\n  options?: UseQueryOptionsWrapper<\n    Response<AdminGetRegionsRegionFulfillmentOptionsRes>,\n    Error,\n    ReturnType<RegionQueryKeys[\"detail\"]>\n  >\n) => {\n  const { client } = useMedusa()\n  const { data, ...rest } = useQuery(\n    adminRegionKeys.detail(`${regionId}_fullfillment-options`),\n    () => client.admin.regions.retrieveFulfillmentOptions(regionId),\n    options\n  )\n  return { ...data, ...rest } as const\n}\n","import {\n  AdminPostRegionsRegionCountriesReq,\n  AdminPostRegionsRegionFulfillmentProvidersReq,\n  AdminPostRegionsRegionPaymentProvidersReq,\n  AdminPostRegionsRegionReq,\n  AdminPostRegionsReq,\n  AdminRegionsDeleteRes,\n  AdminRegionsRes,\n} from \"@medusajs/medusa\"\nimport { Response } from \"@medusajs/medusa-js\"\nimport {\n  useMutation,\n  UseMutationOptions,\n  useQueryClient,\n} from \"@tanstack/react-query\"\nimport { useMedusa } from \"../../../contexts/medusa\"\nimport { buildOptions } from \"../../utils/buildOptions\"\nimport { adminRegionKeys } from \"./queries\"\n\n/**\n * This hook creates a region.\n * \n * @example\n * import React from \"react\"\n * import { useAdminCreateRegion } from \"medusa-react\"\n * \n * type CreateData = {\n *   name: string\n *   currency_code: string\n *   tax_rate: number\n *   payment_providers: string[]\n *   fulfillment_providers: string[]\n *   countries: string[]\n * }\n * \n * const CreateRegion = () => {\n *   const createRegion = useAdminCreateRegion()\n *   // ...\n * \n *   const handleCreate = (regionData: CreateData) => {\n *     createRegion.mutate(regionData, {\n *       onSuccess: ({ region }) => {\n *         console.log(region.id)\n *       }\n *     })\n *   }\n * \n *   // ...\n * }\n * \n * export default CreateRegion\n * \n * @customNamespace Hooks.Admin.Regions\n * @category Mutations\n */\nexport const useAdminCreateRegion = (\n  options?: UseMutationOptions<\n    Response<AdminRegionsRes>,\n    Error,\n    AdminPostRegionsReq\n  >\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n\n  return useMutation(\n    (payload: AdminPostRegionsReq) => client.admin.regions.create(payload),\n    buildOptions(queryClient, adminRegionKeys.lists(), options)\n  )\n}\n\n/**\n * This hook updates a region's details.\n * \n * @example\n * import React from \"react\"\n * import { useAdminUpdateRegion } from \"medusa-react\"\n * \n * type Props = {\n *   regionId: string\n * }\n * \n * const Region = ({\n *   regionId\n * }: Props) => {\n *   const updateRegion = useAdminUpdateRegion(regionId)\n *   // ...\n * \n *   const handleUpdate = (\n *     countries: string[]\n *   ) => {\n *     updateRegion.mutate({\n *       countries,\n *     }, {\n *       onSuccess: ({ region }) => {\n *         console.log(region.id)\n *       }\n *     })\n *   }\n * \n *   // ...\n * }\n * \n * export default Region\n * \n * @customNamespace Hooks.Admin.Regions\n * @category Mutations\n */\nexport const useAdminUpdateRegion = (\n  /**\n   * The region's ID.\n   */\n  id: string,\n  options?: UseMutationOptions<\n    Response<AdminRegionsRes>,\n    Error,\n    AdminPostRegionsRegionReq\n  >\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n\n  return useMutation(\n    (payload: AdminPostRegionsRegionReq) =>\n      client.admin.regions.update(id, payload),\n    buildOptions(\n      queryClient,\n      [adminRegionKeys.lists(), adminRegionKeys.detail(id)],\n      options\n    )\n  )\n}\n\n/**\n * This hook deletes a region. Associated resources, such as providers or currencies are not deleted. Associated tax rates are deleted.\n * \n * @example\n * import React from \"react\"\n * import { useAdminDeleteRegion } from \"medusa-react\"\n * \n * type Props = {\n *   regionId: string\n * }\n * \n * const Region = ({\n *   regionId\n * }: Props) => {\n *   const deleteRegion = useAdminDeleteRegion(regionId)\n *   // ...\n * \n *   const handleDelete = () => {\n *     deleteRegion.mutate(void 0, {\n *       onSuccess: ({ id, object, deleted }) => {\n *         console.log(id)\n *       }\n *     })\n *   }\n * \n *   // ...\n * }\n * \n * export default Region\n * \n * @customNamespace Hooks.Admin.Regions\n * @category Mutations\n */\nexport const useAdminDeleteRegion = (\n  /**\n   * The region's ID.\n   */\n  id: string,\n  options?: UseMutationOptions<Response<AdminRegionsDeleteRes>, Error, void>\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n\n  return useMutation(\n    () => client.admin.regions.delete(id),\n    buildOptions(\n      queryClient,\n      [adminRegionKeys.lists(), adminRegionKeys.detail(id)],\n      options\n    )\n  )\n}\n\n/**\n * This hook adds a country to the list of countries in a region.\n * \n * @example\n * import React from \"react\"\n * import { useAdminRegionAddCountry } from \"medusa-react\"\n * \n * type Props = {\n *   regionId: string\n * }\n * \n * const Region = ({\n *   regionId\n * }: Props) => {\n *   const addCountry = useAdminRegionAddCountry(regionId)\n *   // ...\n * \n *   const handleAddCountry = (\n *     countryCode: string\n *   ) => {\n *     addCountry.mutate({\n *       country_code: countryCode\n *     }, {\n *       onSuccess: ({ region }) => {\n *         console.log(region.countries)\n *       }\n *     })\n *   }\n * \n *   // ...\n * }\n * \n * export default Region\n * \n * @customNamespace Hooks.Admin.Regions\n * @category Mutations\n */\nexport const useAdminRegionAddCountry = (\n  /**\n   * The region's ID.\n   */\n  id: string,\n  options?: UseMutationOptions<\n    Response<AdminRegionsRes>,\n    Error,\n    AdminPostRegionsRegionCountriesReq\n  >\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n\n  return useMutation(\n    (payload: AdminPostRegionsRegionCountriesReq) =>\n      client.admin.regions.addCountry(id, payload),\n    buildOptions(queryClient, adminRegionKeys.detail(id), options)\n  )\n}\n\n/**\n * This hook deletes a country from the list of countries in a region. The country will still be available in the system, and it can be used in other regions.\n * \n * @typeParamDefinition string - The code of the country to delete from the region.\n * \n * @example\n * import React from \"react\"\n * import { useAdminRegionRemoveCountry } from \"medusa-react\"\n * \n * type Props = {\n *   regionId: string\n * }\n * \n * const Region = ({\n *   regionId\n * }: Props) => {\n *   const removeCountry = useAdminRegionRemoveCountry(regionId)\n *   // ...\n * \n *   const handleRemoveCountry = (\n *     countryCode: string\n *   ) => {\n *     removeCountry.mutate(countryCode, {\n *       onSuccess: ({ region }) => {\n *         console.log(region.countries)\n *       }\n *     })\n *   }\n * \n *   // ...\n * }\n * \n * export default Region\n * \n * @customNamespace Hooks.Admin.Regions\n * @category Mutations\n */\nexport const useAdminRegionRemoveCountry = (\n  /**\n   * The region's ID.\n   */\n  id: string,\n  options?: UseMutationOptions<Response<AdminRegionsRes>, Error, string>\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n\n  return useMutation(\n    (country_code: string) =>\n      client.admin.regions.deleteCountry(id, country_code),\n    buildOptions(queryClient, adminRegionKeys.detail(id), options)\n  )\n}\n\n/**\n * This hook adds a fulfillment provider to the list of fulfullment providers in a region.\n * \n * @example\n * import React from \"react\"\n * import { \n *   useAdminRegionAddFulfillmentProvider\n * } from \"medusa-react\"\n * \n * type Props = {\n *   regionId: string\n * }\n * \n * const Region = ({\n *   regionId\n * }: Props) => {\n *   const addFulfillmentProvider = \n *     useAdminRegionAddFulfillmentProvider(regionId)\n *   // ...\n * \n *   const handleAddFulfillmentProvider = (\n *     providerId: string\n *   ) => {\n *     addFulfillmentProvider.mutate({\n *       provider_id: providerId\n *     }, {\n *       onSuccess: ({ region }) => {\n *         console.log(region.fulfillment_providers)\n *       }\n *     })\n *   }\n * \n *   // ...\n * }\n * \n * export default Region\n * \n * @customNamespace Hooks.Admin.Regions\n * @category Mutations\n */\nexport const useAdminRegionAddFulfillmentProvider = (\n  /**\n   * The region's ID.\n   */\n  id: string,\n  options?: UseMutationOptions<\n    Response<AdminRegionsRes>,\n    Error,\n    AdminPostRegionsRegionFulfillmentProvidersReq\n  >\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n\n  return useMutation(\n    (payload: AdminPostRegionsRegionFulfillmentProvidersReq) =>\n      client.admin.regions.addFulfillmentProvider(id, payload),\n    buildOptions(queryClient, adminRegionKeys.detail(id), options)\n  )\n}\n\n/**\n * This hook deletes a fulfillment provider from a region. The fulfillment provider will still be available for usage in other regions.\n * \n * @typeParamDefinition string - The fulfillment provider's ID to delete from the region.\n * \n * @example\n * import React from \"react\"\n * import { \n *   useAdminRegionDeleteFulfillmentProvider\n * } from \"medusa-react\"\n * \n * type Props = {\n *   regionId: string\n * }\n * \n * const Region = ({\n *   regionId\n * }: Props) => {\n *   const removeFulfillmentProvider = \n *     useAdminRegionDeleteFulfillmentProvider(regionId)\n *   // ...\n * \n *   const handleRemoveFulfillmentProvider = (\n *     providerId: string\n *   ) => {\n *     removeFulfillmentProvider.mutate(providerId, {\n *       onSuccess: ({ region }) => {\n *         console.log(region.fulfillment_providers)\n *       }\n *     })\n *   }\n * \n *   // ...\n * }\n * \n * export default Region\n * \n * @customNamespace Hooks.Admin.Regions\n * @category Mutations\n */\nexport const useAdminRegionDeleteFulfillmentProvider = (\n  /**\n   * The region's ID.\n   */\n  id: string,\n  options?: UseMutationOptions<Response<AdminRegionsRes>, Error, string>\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n\n  return useMutation(\n    (provider_id: string) =>\n      client.admin.regions.deleteFulfillmentProvider(id, provider_id),\n    buildOptions(queryClient, adminRegionKeys.detail(id), options)\n  )\n}\n\n/**\n * This hook adds a payment provider to the list of payment providers in a region.\n * \n * @example\n * import React from \"react\"\n * import { \n *   useAdminRegionAddPaymentProvider\n * } from \"medusa-react\"\n * \n * type Props = {\n *   regionId: string\n * }\n * \n * const Region = ({\n *   regionId\n * }: Props) => {\n *   const addPaymentProvider = \n *     useAdminRegionAddPaymentProvider(regionId)\n *   // ...\n * \n *   const handleAddPaymentProvider = (\n *     providerId: string\n *   ) => {\n *     addPaymentProvider.mutate({\n *       provider_id: providerId\n *     }, {\n *       onSuccess: ({ region }) => {\n *         console.log(region.payment_providers)\n *       }\n *     })\n *   }\n * \n *   // ...\n * }\n * \n * export default Region\n * \n * @customNamespace Hooks.Admin.Regions\n * @category Mutations\n */\nexport const useAdminRegionAddPaymentProvider = (\n  /**\n   * The region's ID.\n   */\n  id: string,\n  options?: UseMutationOptions<\n    Response<AdminRegionsRes>,\n    Error,\n    AdminPostRegionsRegionPaymentProvidersReq\n  >\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n\n  return useMutation(\n    (payload: AdminPostRegionsRegionPaymentProvidersReq) =>\n      client.admin.regions.addPaymentProvider(id, payload),\n    buildOptions(queryClient, adminRegionKeys.detail(id), options)\n  )\n}\n\n/**\n * This hook deletes a payment provider from a region. The payment provider will still be available for usage in other regions.\n * \n * @typeParamDefinition string - The ID of the payment provider to delete from the region.\n * \n * @example\n * import React from \"react\"\n * import { \n *   useAdminRegionDeletePaymentProvider\n * } from \"medusa-react\"\n * \n * type Props = {\n *   regionId: string\n * }\n * \n * const Region = ({\n *   regionId\n * }: Props) => {\n *   const removePaymentProvider = \n *     useAdminRegionDeletePaymentProvider(regionId)\n *   // ...\n * \n *   const handleRemovePaymentProvider = (\n *     providerId: string\n *   ) => {\n *     removePaymentProvider.mutate(providerId, {\n *       onSuccess: ({ region }) => {\n *         console.log(region.payment_providers)\n *       }\n *     })\n *   }\n * \n *   // ...\n * }\n * \n * export default Region\n * \n * @customNamespace Hooks.Admin.Regions\n * @category Mutations\n */\nexport const useAdminRegionDeletePaymentProvider = (\n  /**\n   * The region's ID.\n   */\n  id: string,\n  options?: UseMutationOptions<Response<AdminRegionsRes>, Error, string>\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n\n  return useMutation(\n    (provider_id: string) =>\n      client.admin.regions.deletePaymentProvider(id, provider_id),\n    buildOptions(queryClient, adminRegionKeys.detail(id), options)\n  )\n}\n","import {\n  AdminPostReservationsReq,\n  AdminPostReservationsReservationReq,\n  AdminReservationsDeleteRes,\n  AdminReservationsRes,\n} from \"@medusajs/medusa\"\nimport {\n  UseMutationOptions,\n  useMutation,\n  useQueryClient,\n} from \"@tanstack/react-query\"\n\nimport { Response } from \"@medusajs/medusa-js\"\nimport { useMedusa } from \"../../../contexts\"\nimport { buildOptions } from \"../../utils/buildOptions\"\nimport { adminInventoryItemsKeys } from \"../inventory-item\"\nimport { adminVariantKeys } from \"../variants\"\nimport { adminReservationsKeys } from \"./queries\"\n\n/**\n * This hook creates a reservation which can be associated with any resource, such as an order's line item.\n * \n * @example\n * import React from \"react\"\n * import { useAdminCreateReservation } from \"medusa-react\"\n * \n * const CreateReservation = () => {\n *   const createReservation = useAdminCreateReservation()\n *   // ...\n * \n *   const handleCreate = (\n *     locationId: string,\n *     inventoryItemId: string,\n *     quantity: number\n *   ) => {\n *     createReservation.mutate({\n *       location_id: locationId,\n *       inventory_item_id: inventoryItemId,\n *       quantity,\n *     }, {\n *       onSuccess: ({ reservation }) => {\n *         console.log(reservation.id)\n *       }\n *     })\n *   }\n * \n *   // ...\n * }\n * \n * export default CreateReservation\n * \n * @customNamespace Hooks.Admin.Reservations\n * @category Mutations\n */\nexport const useAdminCreateReservation = (\n  options?: UseMutationOptions<\n    Response<AdminReservationsRes>,\n    Error,\n    AdminPostReservationsReq\n  >\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n\n  return useMutation(\n    (payload: AdminPostReservationsReq) =>\n      client.admin.reservations.create(payload),\n    buildOptions(\n      queryClient,\n      [adminReservationsKeys.lists(), adminVariantKeys.all],\n      options\n    )\n  )\n}\n\n/**\n * This hook updates a reservation's details.\n * \n * @example\n * import React from \"react\"\n * import { useAdminUpdateReservation } from \"medusa-react\"\n * \n * type Props = {\n *   reservationId: string\n * }\n * \n * const Reservation = ({ reservationId }: Props) => {\n *   const updateReservation = useAdminUpdateReservation(\n *     reservationId\n *   )\n *   // ...\n * \n *   const handleUpdate = (\n *     quantity: number\n *   ) => {\n *     updateReservation.mutate({\n *       quantity,\n *     })\n *   }\n * \n *   // ...\n * }\n * \n * export default Reservation\n * \n * @customNamespace Hooks.Admin.Reservations\n * @category Mutations\n */\nexport const useAdminUpdateReservation = (\n  /**\n   * The reservation's ID.\n   */\n  id: string,\n  options?: UseMutationOptions<\n    Response<AdminReservationsRes>,\n    Error,\n    AdminPostReservationsReservationReq\n  >\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n\n  return useMutation(\n    (payload: AdminPostReservationsReservationReq) =>\n      client.admin.reservations.update(id, payload),\n    buildOptions(\n      queryClient,\n      [\n        adminReservationsKeys.lists(),\n        adminReservationsKeys.detail(id),\n        adminVariantKeys.all,\n        adminInventoryItemsKeys.details()\n      ],\n      options\n    )\n  )\n}\n\n/**\n * This hook deletes a reservation. Associated resources, such as the line item, will not be deleted.\n * \n * @example\n * import React from \"react\"\n * import { useAdminDeleteReservation } from \"medusa-react\"\n * \n * type Props = {\n *   reservationId: string\n * }\n * \n * const Reservation = ({ reservationId }: Props) => {\n *   const deleteReservation = useAdminDeleteReservation(\n *     reservationId\n *   )\n *   // ...\n * \n *   const handleDelete = () => {\n *     deleteReservation.mutate(void 0, {\n *       onSuccess: ({ id, object, deleted }) => {\n *         console.log(id)\n *       }\n *     })\n *   }\n * \n *   // ...\n * }\n * \n * export default Reservation\n * \n * @customNamespace Hooks.Admin.Reservations\n * @category Mutations\n */\nexport const useAdminDeleteReservation = (\n  /**\n   * The reservation's ID.\n   */\n  id: string,\n  options?: UseMutationOptions<\n    Response<AdminReservationsDeleteRes>,\n    Error,\n    void\n  >\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n\n  return useMutation(\n    () => client.admin.reservations.delete(id),\n    buildOptions(\n      queryClient,\n      [\n        adminReservationsKeys.lists(),\n        adminReservationsKeys.detail(id),\n        adminVariantKeys.all,\n      ],\n      options\n    )\n  )\n}\n","import {\n  AdminGetReservationsParams,\n  AdminReservationsListRes,\n  AdminReservationsRes,\n} from \"@medusajs/medusa\"\nimport { Response } from \"@medusajs/medusa-js\"\nimport { useQuery } from \"@tanstack/react-query\"\nimport { useMedusa } from \"../../../contexts\"\nimport { UseQueryOptionsWrapper } from \"../../../types\"\nimport { queryKeysFactory } from \"../../utils\"\n\nconst ADMIN_RESERVATIONS_QUERY_KEY = `admin_reservations` as const\n\nexport const adminReservationsKeys = queryKeysFactory(\n  ADMIN_RESERVATIONS_QUERY_KEY\n)\n\ntype ReservationsQueryKeys = typeof adminReservationsKeys\n\n/**\n * This hook retrieves a list of reservations. The reservations can be filtered by fields such as `location_id` or `quantity` \n * passed in the `query` parameter. The reservations can also be paginated.\n * \n * @example\n * To list reservations:\n * \n * ```tsx\n * import React from \"react\"\n * import { useAdminReservations } from \"medusa-react\"\n * \n * const Reservations = () => {\n *   const { reservations, isLoading } = useAdminReservations()\n * \n *   return (\n *     <div>\n *       {isLoading && <span>Loading...</span>}\n *       {reservations && !reservations.length && (\n *         <span>No Reservations</span>\n *       )}\n *       {reservations && reservations.length > 0 && (\n *         <ul>\n *           {reservations.map((reservation) => (\n *             <li key={reservation.id}>{reservation.quantity}</li>\n *           ))}\n *         </ul>\n *       )}\n *     </div>\n *   )\n * }\n * \n * export default Reservations\n * ```\n * \n * To specify relations that should be retrieved within the reservations:\n * \n * ```tsx\n * import React from \"react\"\n * import { useAdminReservations } from \"medusa-react\"\n * \n * const Reservations = () => {\n *   const { \n *     reservations, \n *     isLoading\n *   } = useAdminReservations({\n *     expand: \"location\"\n *   })\n * \n *   return (\n *     <div>\n *       {isLoading && <span>Loading...</span>}\n *       {reservations && !reservations.length && (\n *         <span>No Reservations</span>\n *       )}\n *       {reservations && reservations.length > 0 && (\n *         <ul>\n *           {reservations.map((reservation) => (\n *             <li key={reservation.id}>{reservation.quantity}</li>\n *           ))}\n *         </ul>\n *       )}\n *     </div>\n *   )\n * }\n * \n * export default Reservations\n * ```\n * \n * By default, only the first `20` records are retrieved. You can control pagination by specifying the `limit` and `offset` properties:\n * \n * ```tsx\n * import React from \"react\"\n * import { useAdminReservations } from \"medusa-react\"\n * \n * const Reservations = () => {\n *   const { \n *     reservations,\n *     limit,\n *     offset, \n *     isLoading\n *   } = useAdminReservations({\n *     expand: \"location\",\n *     limit: 10,\n *     offset: 0\n *   })\n * \n *   return (\n *     <div>\n *       {isLoading && <span>Loading...</span>}\n *       {reservations && !reservations.length && (\n *         <span>No Reservations</span>\n *       )}\n *       {reservations && reservations.length > 0 && (\n *         <ul>\n *           {reservations.map((reservation) => (\n *             <li key={reservation.id}>{reservation.quantity}</li>\n *           ))}\n *         </ul>\n *       )}\n *     </div>\n *   )\n * }\n * \n * export default Reservations\n * ```\n * \n * @customNamespace Hooks.Admin.Reservations\n * @category Queries\n */\nexport const useAdminReservations = (\n  /**\n   * Filters and pagination parameters to apply on the retrieved reservations.\n   */\n  query?: AdminGetReservationsParams,\n  options?: UseQueryOptionsWrapper<\n    Response<AdminReservationsListRes>,\n    Error,\n    ReturnType<ReservationsQueryKeys[\"list\"]>\n  >\n) => {\n  const { client } = useMedusa()\n\n  const { data, ...rest } = useQuery(\n    adminReservationsKeys.list(query),\n    () => client.admin.reservations.list(query),\n    { ...options }\n  )\n\n  return { ...data, ...rest } as const\n}\n\n/**\n * This hook retrieves a reservation's details.\n * \n * @example\n * import React from \"react\"\n * import { useAdminReservation } from \"medusa-react\"\n * \n * type Props = {\n *   reservationId: string\n * }\n * \n * const Reservation = ({ reservationId }: Props) => {\n *   const { reservation, isLoading } = useAdminReservation(\n *     reservationId\n *   )\n * \n *   return (\n *     <div>\n *       {isLoading && <span>Loading...</span>}\n *       {reservation && (\n *         <span>{reservation.inventory_item_id}</span>\n *       )}\n *     </div>\n *   )\n * }\n * \n * export default Reservation\n * \n * @customNamespace Hooks.Admin.Reservations\n * @category Queries\n */\nexport const useAdminReservation = (\n  /**\n   * The reservation's ID.\n   */\n  id: string,\n  options?: UseQueryOptionsWrapper<\n    Response<AdminReservationsRes>,\n    Error,\n    ReturnType<ReservationsQueryKeys[\"detail\"]>\n  >\n) => {\n  const { client } = useMedusa()\n\n  const { data, ...rest } = useQuery(\n    adminReservationsKeys.detail(id),\n    () => client.admin.reservations.retrieve(id),\n    options\n  )\n\n  return { ...data, ...rest } as const\n}\n","import {\n  AdminReturnReasonsListRes,\n  AdminReturnReasonsRes,\n} from \"@medusajs/medusa\"\nimport { Response } from \"@medusajs/medusa-js\"\nimport { useQuery } from \"@tanstack/react-query\"\nimport { useMedusa } from \"../../../contexts\"\nimport { UseQueryOptionsWrapper } from \"../../../types\"\nimport { queryKeysFactory } from \"../../utils/index\"\n\nconst ADMIN_RETURNS_REASONS_QUERY_KEY = `admin_return_reasons` as const\n\nexport const adminReturnReasonKeys = queryKeysFactory(\n  ADMIN_RETURNS_REASONS_QUERY_KEY\n)\n\ntype ReturnReasonQueryKeys = typeof adminReturnReasonKeys\n\n/**\n * This hook retrieves a list of return reasons.\n * \n * @example\n * import React from \"react\"\n * import { useAdminReturnReasons } from \"medusa-react\"\n * \n * const ReturnReasons = () => {\n *   const { return_reasons, isLoading } = useAdminReturnReasons()\n * \n *   return (\n *     <div>\n *       {isLoading && <span>Loading...</span>}\n *       {return_reasons && !return_reasons.length && (\n *         <span>No Return Reasons</span>\n *       )}\n *       {return_reasons && return_reasons.length > 0 && (\n *         <ul>\n *           {return_reasons.map((reason) => (\n *             <li key={reason.id}>\n *               {reason.label}: {reason.value}\n *             </li>\n *           ))}\n *         </ul>\n *       )}\n *     </div>\n *   )\n * }\n * \n * export default ReturnReasons\n * \n * @customNamespace Hooks.Admin.Return Reasons\n * @category Queries\n */\nexport const useAdminReturnReasons = (\n  options?: UseQueryOptionsWrapper<\n    Response<AdminReturnReasonsListRes>,\n    Error,\n    ReturnType<ReturnReasonQueryKeys[\"lists\"]>\n  >\n) => {\n  const { client } = useMedusa()\n  const { data, ...rest } = useQuery(\n    adminReturnReasonKeys.lists(),\n    () => client.admin.returnReasons.list(),\n    options\n  )\n  return { ...data, ...rest } as const\n}\n\n/**\n * This hook retrieves a return reason's details.\n * \n * @example\n * import React from \"react\"\n * import { useAdminReturnReason } from \"medusa-react\"\n * \n * type Props = {\n *   returnReasonId: string\n * }\n * \n * const ReturnReason = ({ returnReasonId }: Props) => {\n *   const { return_reason, isLoading } = useAdminReturnReason(\n *     returnReasonId\n *   )\n * \n *   return (\n *     <div>\n *       {isLoading && <span>Loading...</span>}\n *       {return_reason && <span>{return_reason.label}</span>}\n *     </div>\n *   )\n * }\n * \n * export default ReturnReason\n * \n * @customNamespace Hooks.Admin.Return Reasons\n * @category Queries\n */\nexport const useAdminReturnReason = (\n  /**\n   * The return reason's ID.\n   */\n  id: string,\n  options?: UseQueryOptionsWrapper<\n    Response<AdminReturnReasonsRes>,\n    Error,\n    ReturnType<ReturnReasonQueryKeys[\"detail\"]>\n  >\n) => {\n  const { client } = useMedusa()\n  const { data, ...rest } = useQuery(\n    adminReturnReasonKeys.detail(id),\n    () => client.admin.returnReasons.retrieve(id),\n    options\n  )\n  return { ...data, ...rest } as const\n}\n","import {\n  AdminPostReturnReasonsReasonReq,\n  AdminPostReturnReasonsReq,\n  AdminReturnReasonsRes,\n} from \"@medusajs/medusa\"\nimport { Response } from \"@medusajs/medusa-js\"\nimport {\n  useMutation,\n  UseMutationOptions,\n  useQueryClient,\n} from \"@tanstack/react-query\"\nimport { useMedusa } from \"../../../contexts/medusa\"\nimport { buildOptions } from \"../../utils/buildOptions\"\nimport { adminReturnReasonKeys } from \"./queries\"\n\n/**\n * This hook creates a return reason.\n * \n * @example\n * import React from \"react\"\n * import { useAdminCreateReturnReason } from \"medusa-react\"\n * \n * const CreateReturnReason = () => {\n *   const createReturnReason = useAdminCreateReturnReason()\n *   // ...\n * \n *   const handleCreate = (\n *     label: string,\n *     value: string\n *   ) => {\n *     createReturnReason.mutate({\n *       label,\n *       value,\n *     }, {\n *       onSuccess: ({ return_reason }) => {\n *         console.log(return_reason.id)\n *       }\n *     })\n *   }\n * \n *   // ...\n * }\n * \n * export default CreateReturnReason\n * \n * @customNamespace Hooks.Admin.Return Reasons\n * @category Mutations\n */\nexport const useAdminCreateReturnReason = (\n  options?: UseMutationOptions<\n    Response<AdminReturnReasonsRes>,\n    Error,\n    AdminPostReturnReasonsReq\n  >\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n\n  return useMutation(\n    (payload: AdminPostReturnReasonsReq) =>\n      client.admin.returnReasons.create(payload),\n    buildOptions(queryClient, adminReturnReasonKeys.lists(), options)\n  )\n}\n\n/**\n * This hook updates a return reason's details.\n * \n * @example\n * import React from \"react\"\n * import { useAdminUpdateReturnReason } from \"medusa-react\"\n * \n * type Props = {\n *   returnReasonId: string\n * }\n * \n * const ReturnReason = ({ returnReasonId }: Props) => {\n *   const updateReturnReason = useAdminUpdateReturnReason(\n *     returnReasonId\n *   )\n *   // ...\n * \n *   const handleUpdate = (\n *     label: string\n *   ) => {\n *     updateReturnReason.mutate({\n *       label,\n *     }, {\n *       onSuccess: ({ return_reason }) => {\n *         console.log(return_reason.label)\n *       }\n *     })\n *   }\n * \n *   // ...\n * }\n * \n * export default ReturnReason\n * \n * @customNamespace Hooks.Admin.Return Reasons\n * @category Mutations\n */\nexport const useAdminUpdateReturnReason = (\n  /**\n   * The return reason's ID.\n   */\n  id: string,\n  options?: UseMutationOptions<\n    Response<AdminReturnReasonsRes>,\n    Error,\n    AdminPostReturnReasonsReasonReq\n  >\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n\n  return useMutation(\n    (payload: AdminPostReturnReasonsReasonReq) =>\n      client.admin.returnReasons.update(id, payload),\n    buildOptions(\n      queryClient,\n      [adminReturnReasonKeys.detail(id), adminReturnReasonKeys.lists()],\n      options\n    )\n  )\n}\n\n/**\n * This hook deletes a return reason.\n * \n * @example\n * import React from \"react\"\n * import { useAdminDeleteReturnReason } from \"medusa-react\"\n * \n * type Props = {\n *   returnReasonId: string\n * }\n * \n * const ReturnReason = ({ returnReasonId }: Props) => {\n *   const deleteReturnReason = useAdminDeleteReturnReason(\n *     returnReasonId\n *   )\n *   // ...\n * \n *   const handleDelete = () => {\n *     deleteReturnReason.mutate(void 0, {\n *       onSuccess: ({ id, object, deleted }) => {\n *         console.log(id)\n *       }\n *     })\n *   }\n * \n *   // ...\n * }\n * \n * export default ReturnReason\n * \n * @customNamespace Hooks.Admin.Return Reasons\n * @category Mutations\n */\nexport const useAdminDeleteReturnReason = (\n  /**\n   * The return reason's ID.\n   */\n  id: string,\n  options?: UseMutationOptions\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n\n  return useMutation(\n    () => client.admin.returnReasons.delete(id),\n    buildOptions(\n      queryClient,\n      [adminReturnReasonKeys.detail(id), adminReturnReasonKeys.lists()],\n      options\n    )\n  )\n}\n","import { AdminReturnsListRes } from \"@medusajs/medusa\"\nimport { Response } from \"@medusajs/medusa-js\"\nimport { useQuery } from \"@tanstack/react-query\"\nimport { useMedusa } from \"../../../contexts\"\nimport { UseQueryOptionsWrapper } from \"../../../types\"\nimport { queryKeysFactory } from \"../../utils/index\"\n\nconst ADMIN_RETURNS_QUERY_KEY = `admin_returns` as const\n\nexport const adminReturnKeys = queryKeysFactory(ADMIN_RETURNS_QUERY_KEY)\n\ntype ReturnQueryKeys = typeof adminReturnKeys\n\n/**\n * This hook retrieves a list of Returns. The returns can be paginated.\n * \n * @example\n * import React from \"react\"\n * import { useAdminReturns } from \"medusa-react\"\n * \n * const Returns = () => {\n *   const { returns, isLoading } = useAdminReturns()\n * \n *   return (\n *     <div>\n *       {isLoading && <span>Loading...</span>}\n *       {returns && !returns.length && (\n *         <span>No Returns</span>\n *       )}\n *       {returns && returns.length > 0 && (\n *         <ul>\n *           {returns.map((returnData) => (\n *             <li key={returnData.id}>\n *               {returnData.status}\n *             </li>\n *           ))}\n *         </ul>\n *       )}\n *     </div>\n *   )\n * }\n * \n * export default Returns\n * \n * @customNamespace Hooks.Admin.Returns\n * @category Queries\n */\nexport const useAdminReturns = (\n  options?: UseQueryOptionsWrapper<\n    Response<AdminReturnsListRes>,\n    Error,\n    ReturnType<ReturnQueryKeys[\"lists\"]>\n  >\n) => {\n  const { client } = useMedusa()\n  const { data, ...rest } = useQuery(\n    adminReturnKeys.lists(),\n    () => client.admin.returns.list(),\n    options\n  )\n  return { ...data, ...rest } as const\n}\n","import {\n  AdminPostReturnsReturnReceiveReq,\n  AdminReturnsCancelRes,\n  AdminReturnsRes,\n} from \"@medusajs/medusa\"\nimport { Response } from \"@medusajs/medusa-js\"\nimport {\n  useMutation,\n  UseMutationOptions,\n  useQueryClient,\n} from \"@tanstack/react-query\"\nimport { useMedusa } from \"../../../contexts/medusa\"\nimport { buildOptions } from \"../../utils/buildOptions\"\nimport { adminReturnKeys } from \"./queries\"\n\n/**\n * This hook marks a return as received. This also updates the status of associated order, claim, or swap accordingly.\n * \n * @example\n * import React from \"react\"\n * import { useAdminReceiveReturn } from \"medusa-react\"\n * \n * type ReceiveReturnData = {\n *   items: {\n *     item_id: string\n *     quantity: number\n *   }[]\n * }\n * \n * type Props = {\n *   returnId: string\n * }\n * \n * const Return = ({ returnId }: Props) => {\n *   const receiveReturn = useAdminReceiveReturn(\n *     returnId\n *   )\n *   // ...\n * \n *   const handleReceive = (data: ReceiveReturnData) => {\n *     receiveReturn.mutate(data, {\n *       onSuccess: ({ return: dataReturn }) => {\n *         console.log(dataReturn.status)\n *       }\n *     })\n *   }\n * \n *   // ...\n * }\n * \n * export default Return\n * \n * @customNamespace Hooks.Admin.Returns\n * @category Mutations\n */\nexport const useAdminReceiveReturn = (\n  /**\n   * The return's ID.\n   */\n  id: string,\n  options?: UseMutationOptions<\n    Response<AdminReturnsRes>,\n    Error,\n    AdminPostReturnsReturnReceiveReq\n  >\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n\n  return useMutation(\n    (payload) => client.admin.returns.receive(id, payload),\n    buildOptions(\n      queryClient,\n      [adminReturnKeys.detail(id), adminReturnKeys.list()],\n      options\n    )\n  )\n}\n\n/**\n * This hook registers a return as canceled. The return can be associated with an order, claim, or swap.\n * \n * @example\n * import React from \"react\"\n * import { useAdminCancelReturn } from \"medusa-react\"\n * \n * type Props = {\n *   returnId: string\n * }\n * \n * const Return = ({ returnId }: Props) => {\n *   const cancelReturn = useAdminCancelReturn(\n *     returnId\n *   )\n *   // ...\n * \n *   const handleCancel = () => {\n *     cancelReturn.mutate(void 0, {\n *       onSuccess: ({ order }) => {\n *         console.log(order.returns)\n *       }\n *     })\n *   }\n * \n *   // ...\n * }\n * \n * export default Return\n * \n * @customNamespace Hooks.Admin.Returns\n * @category Mutations\n */\nexport const useAdminCancelReturn = (\n  /**\n   * The return's ID.\n   */\n  id: string,\n  options?: UseMutationOptions<Response<AdminReturnsCancelRes>, Error, void>\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n\n  return useMutation(\n    () => client.admin.returns.cancel(id),\n    buildOptions(\n      queryClient,\n      [adminReturnKeys.detail(id), adminReturnKeys.list()],\n      options\n    )\n  )\n}\n","import {\n  AdminGetSalesChannelsParams,\n  AdminSalesChannelsListRes,\n  AdminSalesChannelsRes,\n} from \"@medusajs/medusa\"\nimport { Response } from \"@medusajs/medusa-js\"\nimport { useQuery } from \"@tanstack/react-query\"\nimport { useMedusa } from \"../../../contexts\"\nimport { UseQueryOptionsWrapper } from \"../../../types\"\nimport { queryKeysFactory } from \"../../utils\"\n\nconst ADMIN_SALES_CHANNELS_QUERY_KEY = `admin_sales_channels` as const\n\nexport const adminSalesChannelsKeys = queryKeysFactory(\n  ADMIN_SALES_CHANNELS_QUERY_KEY\n)\n\ntype SalesChannelsQueryKeys = typeof adminSalesChannelsKeys\n\n/**\n * This hook retrieves a sales channel's details.\n * \n * @example\n * import React from \"react\"\n * import { useAdminSalesChannel } from \"medusa-react\"\n * \n * type Props = {\n *   salesChannelId: string\n * }\n * \n * const SalesChannel = ({ salesChannelId }: Props) => {\n *   const { \n *     sales_channel, \n *     isLoading, \n *   } = useAdminSalesChannel(salesChannelId)\n * \n *   return (\n *     <div>\n *       {isLoading && <span>Loading...</span>}\n *       {sales_channel && <span>{sales_channel.name}</span>}\n *     </div>\n *   )\n * }\n * \n * export default SalesChannel\n * \n * @customNamespace Hooks.Admin.Sales Channels\n * @category Queries\n */\nexport const useAdminSalesChannel = (\n  /**\n   * The sales channel's ID.\n   */\n  id: string,\n  options?: UseQueryOptionsWrapper<\n    Response<AdminSalesChannelsRes>,\n    Error,\n    ReturnType<SalesChannelsQueryKeys[\"detail\"]>\n  >\n) => {\n  const { client } = useMedusa()\n  const { data, ...rest } = useQuery(\n    adminSalesChannelsKeys.detail(id),\n    () => client.admin.salesChannels.retrieve(id),\n    options\n  )\n  return { ...data, ...rest } as const\n}\n\n/**\n * This hook retrieves a list of sales channels. The sales channels can be filtered by fields such as `q` or `name` \n * passed in the `query` parameter. The sales channels can also be sorted or paginated.\n * \n * @example\n * To list sales channels:\n * \n * ```tsx\n * import React from \"react\"\n * import { useAdminSalesChannels } from \"medusa-react\"\n * \n * const SalesChannels = () => {\n *   const { sales_channels, isLoading } = useAdminSalesChannels()\n * \n *   return (\n *     <div>\n *       {isLoading && <span>Loading...</span>}\n *       {sales_channels && !sales_channels.length && (\n *         <span>No Sales Channels</span>\n *       )}\n *       {sales_channels && sales_channels.length > 0 && (\n *         <ul>\n *           {sales_channels.map((salesChannel) => (\n *             <li key={salesChannel.id}>{salesChannel.name}</li>\n *           ))}\n *         </ul>\n *       )}\n *     </div>\n *   )\n * }\n * \n * export default SalesChannels\n * ```\n * \n * To specify relations that should be retrieved within the sales channels:\n * \n * ```tsx\n * import React from \"react\"\n * import { useAdminSalesChannels } from \"medusa-react\"\n * \n * const SalesChannels = () => {\n *   const { \n *     sales_channels, \n *     isLoading\n *   } = useAdminSalesChannels({\n *     expand: \"locations\"\n *   })\n * \n *   return (\n *     <div>\n *       {isLoading && <span>Loading...</span>}\n *       {sales_channels && !sales_channels.length && (\n *         <span>No Sales Channels</span>\n *       )}\n *       {sales_channels && sales_channels.length > 0 && (\n *         <ul>\n *           {sales_channels.map((salesChannel) => (\n *             <li key={salesChannel.id}>{salesChannel.name}</li>\n *           ))}\n *         </ul>\n *       )}\n *     </div>\n *   )\n * }\n * \n * export default SalesChannels\n * ```\n * \n * By default, only the first `20` records are retrieved. You can control pagination by specifying the `limit` and `offset` properties:\n * \n * ```tsx\n * import React from \"react\"\n * import { useAdminSalesChannels } from \"medusa-react\"\n * \n * const SalesChannels = () => {\n *   const { \n *     sales_channels, \n *     limit,\n *     offset,\n *     isLoading\n *   } = useAdminSalesChannels({\n *     expand: \"locations\",\n *     limit: 10,\n *     offset: 0\n *   })\n * \n *   return (\n *     <div>\n *       {isLoading && <span>Loading...</span>}\n *       {sales_channels && !sales_channels.length && (\n *         <span>No Sales Channels</span>\n *       )}\n *       {sales_channels && sales_channels.length > 0 && (\n *         <ul>\n *           {sales_channels.map((salesChannel) => (\n *             <li key={salesChannel.id}>{salesChannel.name}</li>\n *           ))}\n *         </ul>\n *       )}\n *     </div>\n *   )\n * }\n * \n * export default SalesChannels\n * ```\n * \n * @customNamespace Hooks.Admin.Sales Channels\n * @category Queries\n */\nexport const useAdminSalesChannels = (\n  /**\n   * Filters and pagination configurations applied on the retrieved sales channels.\n   */\n  query?: AdminGetSalesChannelsParams,\n  options?: UseQueryOptionsWrapper<\n    Response<AdminSalesChannelsListRes>,\n    Error,\n    ReturnType<SalesChannelsQueryKeys[\"list\"]>\n  >\n) => {\n  const { client } = useMedusa()\n  const { data, ...rest } = useQuery(\n    adminSalesChannelsKeys.list(query),\n    () => client.admin.salesChannels.list(query),\n    options\n  )\n  return { ...data, ...rest } as const\n}\n","import {\n  AdminDeleteSalesChannelsChannelProductsBatchReq,\n  AdminPostSalesChannelsChannelProductsBatchReq,\n  AdminPostSalesChannelsReq,\n  AdminPostSalesChannelsSalesChannelReq,\n  AdminSalesChannelsDeleteRes,\n  AdminSalesChannelsRes,\n} from \"@medusajs/medusa\"\nimport { Response } from \"@medusajs/medusa-js\"\nimport {\n  useMutation,\n  UseMutationOptions,\n  useQueryClient,\n} from \"@tanstack/react-query\"\n\nimport { useMedusa } from \"../../../contexts\"\nimport { buildOptions } from \"../../utils/buildOptions\"\nimport { adminProductKeys } from \"../products\"\nimport { adminStockLocationsKeys } from \"../stock-locations\"\nimport { adminSalesChannelsKeys } from \"./queries\"\n\n/**\n * This hook creates a sales channel.\n * \n * @example\n * import React from \"react\"\n * import { useAdminCreateSalesChannel } from \"medusa-react\"\n * \n * const CreateSalesChannel = () => {\n *   const createSalesChannel = useAdminCreateSalesChannel()\n *   // ...\n * \n *   const handleCreate = (name: string, description: string) => {\n *     createSalesChannel.mutate({\n *       name,\n *       description,\n *     }, {\n *       onSuccess: ({ sales_channel }) => {\n *         console.log(sales_channel.id)\n *       }\n *     })\n *   }\n * \n *   // ...\n * }\n * \n * export default CreateSalesChannel\n * \n * @customNamespace Hooks.Admin.Sales Channels\n * @category Mutations\n */\nexport const useAdminCreateSalesChannel = (\n  options?: UseMutationOptions<\n    Response<AdminSalesChannelsRes>,\n    Error,\n    AdminPostSalesChannelsReq\n  >\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n\n  return useMutation(\n    (payload: AdminPostSalesChannelsReq) =>\n      client.admin.salesChannels.create(payload),\n    buildOptions(queryClient, [adminSalesChannelsKeys.list()], options)\n  )\n}\n\n/**\n * This hook updates a sales channel's details.\n * \n * @example\n * import React from \"react\"\n * import { useAdminUpdateSalesChannel } from \"medusa-react\"\n * \n * type Props = {\n *   salesChannelId: string\n * }\n * \n * const SalesChannel = ({ salesChannelId }: Props) => {\n *   const updateSalesChannel = useAdminUpdateSalesChannel(\n *     salesChannelId\n *   )\n *   // ...\n * \n *   const handleUpdate = (\n *     is_disabled: boolean\n *   ) => {\n *     updateSalesChannel.mutate({\n *       is_disabled,\n *     }, {\n *       onSuccess: ({ sales_channel }) => {\n *         console.log(sales_channel.is_disabled)\n *       }\n *     })\n *   }\n * \n *   // ...\n * }\n * \n * export default SalesChannel\n * \n * @customNamespace Hooks.Admin.Sales Channels\n * @category Mutations\n */\nexport const useAdminUpdateSalesChannel = (\n  /**\n   * The sales channel's ID.\n   */\n  id: string,\n  options?: UseMutationOptions<\n    Response<AdminSalesChannelsRes>,\n    Error,\n    AdminPostSalesChannelsSalesChannelReq\n  >\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n  return useMutation(\n    (payload: AdminPostSalesChannelsSalesChannelReq) =>\n      client.admin.salesChannels.update(id, payload),\n    buildOptions(\n      queryClient,\n      [adminSalesChannelsKeys.lists(), adminSalesChannelsKeys.detail(id)],\n      options\n    )\n  )\n}\n\n/**\n * This hook deletes a sales channel. Associated products, stock locations, and other resources are not deleted.\n * \n * @example\n * import React from \"react\"\n * import { useAdminDeleteSalesChannel } from \"medusa-react\"\n * \n * type Props = {\n *   salesChannelId: string\n * }\n * \n * const SalesChannel = ({ salesChannelId }: Props) => {\n *   const deleteSalesChannel = useAdminDeleteSalesChannel(\n *     salesChannelId\n *   )\n *   // ...\n * \n *   const handleDelete = () => {\n *     deleteSalesChannel.mutate(void 0, {\n *       onSuccess: ({ id, object, deleted }) => {\n *         console.log(id)\n *       }\n *     })\n *   }\n * \n *   // ...\n * }\n * \n * export default SalesChannel\n * \n * @customNamespace Hooks.Admin.Sales Channels\n * @category Mutations\n */\nexport const useAdminDeleteSalesChannel = (\n  /**\n   * The sales channel's ID.\n   */\n  id: string,\n  options?: UseMutationOptions<\n    Response<AdminSalesChannelsDeleteRes>,\n    Error,\n    void\n  >\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n  return useMutation(\n    () => client.admin.salesChannels.delete(id),\n    buildOptions(\n      queryClient,\n      [adminSalesChannelsKeys.lists(), adminSalesChannelsKeys.detail(id)],\n      options\n    )\n  )\n}\n\n/**\n * This hook removes a list of products from a sales channel. This doesn't delete the product. It only removes the \n * association between the product and the sales channel.\n * \n * @example\n * import React from \"react\"\n * import { \n *   useAdminDeleteProductsFromSalesChannel, \n * } from \"medusa-react\"\n * \n * type Props = {\n *   salesChannelId: string\n * }\n * \n * const SalesChannel = ({ salesChannelId }: Props) => {\n *   const deleteProducts = useAdminDeleteProductsFromSalesChannel(\n *     salesChannelId\n *   )\n *   // ...\n * \n *   const handleDeleteProducts = (productId: string) => {\n *     deleteProducts.mutate({\n *       product_ids: [\n *         {\n *           id: productId,\n *         },\n *       ],\n *     }, {\n *       onSuccess: ({ sales_channel }) => {\n *         console.log(sales_channel.id)\n *       }\n *     })\n *   }\n * \n *   // ...\n * }\n * \n * export default SalesChannel\n * \n * @customNamespace Hooks.Admin.Sales Channels\n * @category Mutations\n */\nexport const useAdminDeleteProductsFromSalesChannel = (\n  /**\n   * The sales channel's ID.\n   */\n  id: string,\n  options?: UseMutationOptions<\n    Response<AdminSalesChannelsRes>,\n    Error,\n    AdminDeleteSalesChannelsChannelProductsBatchReq\n  >\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n  return useMutation(\n    (payload: AdminDeleteSalesChannelsChannelProductsBatchReq) => {\n      return client.admin.salesChannels.removeProducts(id, payload)\n    },\n    buildOptions(\n      queryClient,\n      [\n        adminSalesChannelsKeys.lists(),\n        adminSalesChannelsKeys.detail(id),\n        adminProductKeys.list({ sales_channel_id: [id] }),\n      ],\n      options\n    )\n  )\n}\n\n/**\n * This hook adds a list of products to a sales channel.\n * \n * @example\n * import React from \"react\"\n * import { useAdminAddProductsToSalesChannel } from \"medusa-react\"\n * \n * type Props = {\n *   salesChannelId: string\n * }\n * \n * const SalesChannel = ({ salesChannelId }: Props) => {\n *   const addProducts = useAdminAddProductsToSalesChannel(\n *     salesChannelId\n *   )\n *   // ...\n * \n *   const handleAddProducts = (productId: string) => {\n *     addProducts.mutate({\n *       product_ids: [\n *         {\n *           id: productId,\n *         },\n *       ],\n *     }, {\n *       onSuccess: ({ sales_channel }) => {\n *         console.log(sales_channel.id)\n *       }\n *     })\n *   }\n * \n *   // ...\n * }\n * \n * export default SalesChannel\n * \n * @customNamespace Hooks.Admin.Sales Channels\n * @category Mutations\n */\nexport const useAdminAddProductsToSalesChannel = (\n  /**\n   * The sales channel's ID.\n   */\n  id: string,\n  options?: UseMutationOptions<\n    Response<AdminSalesChannelsRes>,\n    Error,\n    AdminPostSalesChannelsChannelProductsBatchReq\n  >\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n  return useMutation(\n    (payload: AdminPostSalesChannelsChannelProductsBatchReq) => {\n      return client.admin.salesChannels.addProducts(id, payload)\n    },\n    buildOptions(\n      queryClient,\n      [\n        adminSalesChannelsKeys.lists(),\n        adminSalesChannelsKeys.detail(id),\n        adminProductKeys.list({ sales_channel_id: [id] }),\n      ],\n      options\n    )\n  )\n}\n\n/**\n * This hook associates a stock location with a sales channel. It requires the \n * [@medusajs/stock-location](https://docs.medusajs.com/modules/multiwarehouse/install-modules#stock-location-module) module to be installed in\n * your Medusa backend.\n * \n * @example\n * import React from \"react\"\n * import { \n *   useAdminAddLocationToSalesChannel\n * } from \"medusa-react\"\n * \n * type Props = {\n *   salesChannelId: string\n * }\n * \n * const SalesChannel = ({ salesChannelId }: Props) => {\n *   const addLocation = useAdminAddLocationToSalesChannel()\n *   // ...\n * \n *   const handleAddLocation = (locationId: string) => {\n *     addLocation.mutate({\n *       sales_channel_id: salesChannelId,\n *       location_id: locationId\n *     }, {\n *       onSuccess: ({ sales_channel }) => {\n *         console.log(sales_channel.locations)\n *       }\n *     })\n *   }\n * \n *   // ...\n * }\n * \n * export default SalesChannel\n * \n * @customNamespace Hooks.Admin.Sales Channels\n * @category Mutations\n */\nexport const useAdminAddLocationToSalesChannel = (\n  options?: UseMutationOptions<\n    Response<AdminSalesChannelsRes>,\n    Error,\n    {\n      /**\n       * The sales channel's ID.\n       */\n      sales_channel_id: string\n      /**\n       * The location's ID.\n       */\n      location_id: string\n    }\n  >\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n  return useMutation(({ sales_channel_id, location_id }) => {\n    return client.admin.salesChannels.addLocation(sales_channel_id, {\n      location_id,\n    })\n  }, buildOptions(\n    queryClient, \n    [\n      adminSalesChannelsKeys.lists(), \n      adminSalesChannelsKeys.details(), \n      adminStockLocationsKeys.all\n    ], \n    options\n    )\n  )\n}\n\n/**\n * This hook removes a stock location from a sales channel. This only removes the association between the stock \n * location and the sales channel. It does not delete the stock location. This hook requires the \n * [@medusajs/stock-location](https://docs.medusajs.com/modules/multiwarehouse/install-modules#stock-location-module) module to be installed in\n * your Medusa backend.\n * \n * @example\n * import React from \"react\"\n * import { \n *   useAdminRemoveLocationFromSalesChannel\n * } from \"medusa-react\"\n * \n * type Props = {\n *   salesChannelId: string\n * }\n * \n * const SalesChannel = ({ salesChannelId }: Props) => {\n *   const removeLocation = useAdminRemoveLocationFromSalesChannel()\n *   // ...\n * \n *   const handleRemoveLocation = (locationId: string) => {\n *     removeLocation.mutate({\n *       sales_channel_id: salesChannelId,\n *       location_id: locationId\n *     }, {\n *       onSuccess: ({ sales_channel }) => {\n *         console.log(sales_channel.locations)\n *       }\n *     })\n *   }\n * \n *   // ...\n * }\n * \n * export default SalesChannel\n * \n * @customNamespace Hooks.Admin.Sales Channels\n * @category Mutations\n */\nexport const useAdminRemoveLocationFromSalesChannel = (\n  options?: UseMutationOptions<\n    Response<AdminSalesChannelsRes>,\n    Error,\n    {\n      /**\n       * The sales channel's ID.\n       */\n      sales_channel_id: string\n      /**\n       * The location's ID.\n       */\n      location_id: string\n    }\n  >\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n  return useMutation(({ sales_channel_id, location_id }) => {\n    return client.admin.salesChannels.removeLocation(sales_channel_id, {\n      location_id,\n    })\n  }, buildOptions(\n    queryClient, \n    [\n      adminSalesChannelsKeys.lists(), \n      adminSalesChannelsKeys.details(), \n      adminStockLocationsKeys.all\n    ], \n    options\n    )\n  )\n}\n","import {\n  AdminGetStockLocationsParams,\n  AdminStockLocationsListRes,\n  AdminStockLocationsRes,\n} from \"@medusajs/medusa\"\nimport { Response } from \"@medusajs/medusa-js\"\nimport { useQuery } from \"@tanstack/react-query\"\nimport { useMedusa } from \"../../../contexts\"\nimport { UseQueryOptionsWrapper } from \"../../../types\"\nimport { queryKeysFactory } from \"../../utils\"\n\nconst ADMIN_STOCK_LOCATIONS_QUERY_KEY = `admin_stock_locations` as const\n\nexport const adminStockLocationsKeys = queryKeysFactory(\n  ADMIN_STOCK_LOCATIONS_QUERY_KEY\n)\n\ntype StockLocationsQueryKeys = typeof adminStockLocationsKeys\n\n/**\n * This hook retrieves a list of stock locations. The stock locations can be filtered by fields such as `name` or `created_at` passed in the `query` parameter.\n * The stock locations can also be sorted or paginated.\n * \n * @example\n * To list stock locations:\n * \n * ```tsx\n * import React from \"react\"\n * import { useAdminStockLocations } from \"medusa-react\"\n * \n * function StockLocations() {\n *   const { \n *     stock_locations,\n *     isLoading\n *   } = useAdminStockLocations()\n * \n *   return (\n *     <div>\n *       {isLoading && <span>Loading...</span>}\n *       {stock_locations && !stock_locations.length && (\n *         <span>No Locations</span>\n *       )}\n *       {stock_locations && stock_locations.length > 0 && (\n *         <ul>\n *           {stock_locations.map(\n *             (location) => (\n *               <li key={location.id}>{location.name}</li>\n *             )\n *           )}\n *         </ul>\n *       )}\n *     </div>\n *   )\n * }\n * \n * export default StockLocations\n * ```\n * \n * To specify relations that should be retrieved within the stock locations:\n * \n * ```tsx\n * import React from \"react\"\n * import { useAdminStockLocations } from \"medusa-react\"\n * \n * function StockLocations() {\n *   const { \n *     stock_locations,\n *     isLoading\n *   } = useAdminStockLocations({\n *     expand: \"address\"\n *   })\n * \n *   return (\n *     <div>\n *       {isLoading && <span>Loading...</span>}\n *       {stock_locations && !stock_locations.length && (\n *         <span>No Locations</span>\n *       )}\n *       {stock_locations && stock_locations.length > 0 && (\n *         <ul>\n *           {stock_locations.map(\n *             (location) => (\n *               <li key={location.id}>{location.name}</li>\n *             )\n *           )}\n *         </ul>\n *       )}\n *     </div>\n *   )\n * }\n * \n * export default StockLocations\n * ```\n * \n * By default, only the first `20` records are retrieved. You can control pagination by specifying the `limit` and `offset` properties:\n * \n * ```tsx\n * import React from \"react\"\n * import { useAdminStockLocations } from \"medusa-react\"\n * \n * function StockLocations() {\n *   const { \n *     stock_locations,\n *     limit,\n *     offset,\n *     isLoading\n *   } = useAdminStockLocations({\n *     expand: \"address\",\n *     limit: 10,\n *     offset: 0\n *   })\n * \n *   return (\n *     <div>\n *       {isLoading && <span>Loading...</span>}\n *       {stock_locations && !stock_locations.length && (\n *         <span>No Locations</span>\n *       )}\n *       {stock_locations && stock_locations.length > 0 && (\n *         <ul>\n *           {stock_locations.map(\n *             (location) => (\n *               <li key={location.id}>{location.name}</li>\n *             )\n *           )}\n *         </ul>\n *       )}\n *     </div>\n *   )\n * }\n * \n * export default StockLocations\n * ```\n * \n * @customNamespace Hooks.Admin.Stock Locations\n * @category Queries\n */\nexport const useAdminStockLocations = (\n  /**\n   * Filters and pagination configurations to apply on the retrieved stock locations.\n   */\n  query?: AdminGetStockLocationsParams,\n  options?: UseQueryOptionsWrapper<\n    Response<AdminStockLocationsListRes>,\n    Error,\n    ReturnType<StockLocationsQueryKeys[\"list\"]>\n  >\n) => {\n  const { client } = useMedusa()\n\n  const { data, ...rest } = useQuery(\n    adminStockLocationsKeys.list(query),\n    () => client.admin.stockLocations.list(query),\n    options\n  )\n\n  return { ...data, ...rest } as const\n}\n\n/**\n * This hook retrieves a stock location's details.\n * \n * @example\n * import React from \"react\"\n * import { useAdminStockLocation } from \"medusa-react\"\n * \n * type Props = {\n *   stockLocationId: string\n * }\n * \n * const StockLocation = ({ stockLocationId }: Props) => {\n *   const { \n *     stock_location,\n *     isLoading\n *   } = useAdminStockLocation(stockLocationId)\n * \n *   return (\n *     <div>\n *       {isLoading && <span>Loading...</span>}\n *       {stock_location && (\n *         <span>{stock_location.name}</span>\n *       )}\n *     </div>\n *   )\n * }\n * \n * export default StockLocation\n * \n * @customNamespace Hooks.Admin.Stock Locations\n * @category Queries\n */\nexport const useAdminStockLocation = (\n  /**\n   * The stock location's ID.\n   */\n  id: string,\n  options?: UseQueryOptionsWrapper<\n    Response<AdminStockLocationsRes>,\n    Error,\n    ReturnType<StockLocationsQueryKeys[\"detail\"]>\n  >\n) => {\n  const { client } = useMedusa()\n\n  const { data, ...rest } = useQuery(\n    adminStockLocationsKeys.detail(id),\n    () => client.admin.stockLocations.retrieve(id),\n    options\n  )\n\n  return { ...data, ...rest } as const\n}\n","import {\n  AdminPostStockLocationsLocationReq,\n  AdminPostStockLocationsReq,\n  AdminStockLocationsDeleteRes,\n  AdminStockLocationsRes,\n} from \"@medusajs/medusa\"\nimport { Response } from \"@medusajs/medusa-js\"\nimport {\n  useMutation,\n  UseMutationOptions,\n  useQueryClient,\n} from \"@tanstack/react-query\"\nimport { useMedusa } from \"../../../contexts\"\nimport { buildOptions } from \"../../utils/buildOptions\"\nimport { adminProductKeys } from \"../products\"\nimport { adminVariantKeys } from \"../variants\"\nimport { adminStockLocationsKeys } from \"./queries\"\n\n/**\n * This hook creates a stock location.\n * \n * @example\n * import React from \"react\"\n * import { useAdminCreateStockLocation } from \"medusa-react\"\n * \n * const CreateStockLocation = () => {\n *   const createStockLocation = useAdminCreateStockLocation()\n *   // ...\n * \n *   const handleCreate = (name: string) => {\n *     createStockLocation.mutate({\n *       name,\n *     }, {\n *       onSuccess: ({ stock_location }) => {\n *         console.log(stock_location.id)\n *       }\n *     })\n *   }\n * \n *   // ...\n * }\n * \n * export default CreateStockLocation\n * \n * @customNamespace Hooks.Admin.Stock Locations\n * @category Mutations\n */\nexport const useAdminCreateStockLocation = (\n  options?: UseMutationOptions<\n    Response<AdminStockLocationsRes>,\n    Error,\n    AdminPostStockLocationsReq\n  >\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n\n  return useMutation(\n    (payload: AdminPostStockLocationsReq) =>\n      client.admin.stockLocations.create(payload),\n    buildOptions(queryClient, [adminStockLocationsKeys.lists()], options)\n  )\n}\n\n/**\n * This hook updates a stock location's details.\n * \n * @example\n * import React from \"react\"\n * import { useAdminUpdateStockLocation } from \"medusa-react\"\n * \n * type Props = {\n *   stockLocationId: string\n * }\n * \n * const StockLocation = ({ stockLocationId }: Props) => {\n *   const updateLocation = useAdminUpdateStockLocation(\n *     stockLocationId\n *   )\n *   // ...\n * \n *   const handleUpdate = (\n *     name: string\n *   ) => {\n *     updateLocation.mutate({\n *       name\n *     }, {\n *       onSuccess: ({ stock_location }) => {\n *         console.log(stock_location.name)\n *       }\n *     })\n *   }\n * }\n * \n * export default StockLocation\n * \n * @customNamespace Hooks.Admin.Stock Locations\n * @category Mutations\n */\nexport const useAdminUpdateStockLocation = (\n  /**\n   * The stock location's ID.\n   */\n  id: string,\n  options?: UseMutationOptions<\n    Response<AdminStockLocationsRes>,\n    Error,\n    AdminPostStockLocationsLocationReq\n  >\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n\n  return useMutation(\n    (payload: AdminPostStockLocationsLocationReq) =>\n      client.admin.stockLocations.update(id, payload),\n    buildOptions(\n      queryClient,\n      [adminStockLocationsKeys.lists(), adminStockLocationsKeys.detail(id)],\n      options\n    )\n  )\n}\n\n/**\n * This hook deletes a stock location.\n * \n * @example\n * import React from \"react\"\n * import { useAdminDeleteStockLocation } from \"medusa-react\"\n * \n * type Props = {\n *   stockLocationId: string\n * }\n * \n * const StockLocation = ({ stockLocationId }: Props) => {\n *   const deleteLocation = useAdminDeleteStockLocation(\n *     stockLocationId\n *   )\n *   // ...\n * \n *   const handleDelete = () => {\n *     deleteLocation.mutate(void 0, {\n *       onSuccess: ({ id, object, deleted }) => {\n *         console.log(id)\n *       }\n *     })\n *   }\n * }\n * \n * export default StockLocation\n * \n * @customNamespace Hooks.Admin.Stock Locations\n * @category Mutations\n */\nexport const useAdminDeleteStockLocation = (\n  /**\n   * The stock location's ID.\n   */\n  id: string,\n  options?: UseMutationOptions<\n    Response<AdminStockLocationsDeleteRes>,\n    Error,\n    void\n  >\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n\n  return useMutation(\n    () => client.admin.stockLocations.delete(id),\n    buildOptions(\n      queryClient,\n      [\n        adminStockLocationsKeys.lists(),\n        adminStockLocationsKeys.detail(id),\n        adminVariantKeys.all,\n        adminProductKeys.lists(),\n      ],\n      options\n    )\n  )\n}\n","import {\n  AdminGetShippingOptionsParams,\n  AdminShippingOptionsListRes,\n  AdminShippingOptionsRes,\n} from \"@medusajs/medusa\"\nimport { Response } from \"@medusajs/medusa-js\"\nimport { useQuery } from \"@tanstack/react-query\"\nimport { useMedusa } from \"../../../contexts\"\nimport { UseQueryOptionsWrapper } from \"../../../types\"\nimport { queryKeysFactory } from \"../../utils/index\"\n\nconst ADMIN_SHIPPING_OPTIONS_QUERY_KEY = `admin_shipping_options` as const\n\nexport const adminShippingOptionKeys = queryKeysFactory(\n  ADMIN_SHIPPING_OPTIONS_QUERY_KEY\n)\n\ntype ShippingOptionQueryKeys = typeof adminShippingOptionKeys\n\n/**\n * This hook retrieves a list of shipping options. The shipping options can be filtered by fields such as `region_id` \n * or `is_return` passed in the `query` parameter.\n * \n * @example\n * import React from \"react\"\n * import { useAdminShippingOptions } from \"medusa-react\"\n * \n * const ShippingOptions = () => {\n *   const {\n *     shipping_options, \n *     isLoading\n *   } = useAdminShippingOptions()\n * \n *   return (\n *     <div>\n *       {isLoading && <span>Loading...</span>}\n *       {shipping_options && !shipping_options.length && (\n *         <span>No Shipping Options</span>\n *       )}\n *       {shipping_options && shipping_options.length > 0 && (\n *         <ul>\n *           {shipping_options.map((option) => (\n *             <li key={option.id}>{option.name}</li>\n *           ))}\n *         </ul>\n *       )}\n *     </div>\n *   )\n * }\n * \n * export default ShippingOptions\n * \n * @customNamespace Hooks.Admin.Shipping Options\n * @category Queries\n */\nexport const useAdminShippingOptions = (\n  /**\n   * Filters to apply on the retrieved shipping options.\n   */\n  query?: AdminGetShippingOptionsParams,\n  options?: UseQueryOptionsWrapper<\n    Response<AdminShippingOptionsListRes>,\n    Error,\n    ReturnType<ShippingOptionQueryKeys[\"list\"]>\n  >\n) => {\n  const { client } = useMedusa()\n  const { data, ...rest } = useQuery(\n    adminShippingOptionKeys.list(query),\n    () => client.admin.shippingOptions.list(query),\n    options\n  )\n  return { ...data, ...rest } as const\n}\n\n/**\n * This hook retrieves a shipping option's details.\n * \n * @example\n * import React from \"react\"\n * import { useAdminShippingOption } from \"medusa-react\"\n * \n * type Props = {\n *   shippingOptionId: string\n * }\n * \n * const ShippingOption = ({ shippingOptionId }: Props) => {\n *   const {\n *     shipping_option, \n *     isLoading\n *   } = useAdminShippingOption(\n *     shippingOptionId\n *   )\n * \n *   return (\n *     <div>\n *       {isLoading && <span>Loading...</span>}\n *       {shipping_option && <span>{shipping_option.name}</span>}\n *     </div>\n *   )\n * }\n * \n * export default ShippingOption\n * \n * @customNamespace Hooks.Admin.Shipping Options\n * @category Queries\n */\nexport const useAdminShippingOption = (\n  /**\n   * The shipping option's ID.\n   */\n  id: string,\n  options?: UseQueryOptionsWrapper<\n    Response<AdminShippingOptionsRes>,\n    Error,\n    ReturnType<ShippingOptionQueryKeys[\"detail\"]>\n  >\n) => {\n  const { client } = useMedusa()\n  const { data, ...rest } = useQuery(\n    adminShippingOptionKeys.detail(id),\n    () => client.admin.shippingOptions.retrieve(id),\n    options\n  )\n  return { ...data, ...rest } as const\n}\n","import {\n  AdminPostShippingOptionsOptionReq,\n  AdminPostShippingOptionsReq,\n  AdminShippingOptionsRes,\n} from \"@medusajs/medusa\"\nimport { Response } from \"@medusajs/medusa-js\"\nimport {\n  useMutation,\n  UseMutationOptions,\n  useQueryClient,\n} from \"@tanstack/react-query\"\nimport { useMedusa } from \"../../../contexts/medusa\"\nimport { buildOptions } from \"../../utils/buildOptions\"\nimport { adminShippingOptionKeys } from \"./queries\"\n\n/**\n * This hook creates a shipping option.\n * \n * @example\n * import React from \"react\"\n * import { useAdminCreateShippingOption } from \"medusa-react\"\n * \n * type CreateShippingOption = {\n *   name: string\n *   provider_id: string\n *   data: Record<string, unknown>\n *   price_type: string\n *   amount: number\n * }\n * \n * type Props = {\n *   regionId: string\n * }\n * \n * const Region = ({ regionId }: Props) => {\n *   const createShippingOption = useAdminCreateShippingOption()\n *   // ...\n * \n *   const handleCreate = (\n *     data: CreateShippingOption\n *   ) => {\n *     createShippingOption.mutate({\n *       ...data,\n *       region_id: regionId\n *     }, {\n *       onSuccess: ({ shipping_option }) => {\n *         console.log(shipping_option.id)\n *       }\n *     })\n *   }\n * \n *   // ...\n * }\n * \n * export default Region\n * \n * @customNamespace Hooks.Admin.Shipping Options\n * @category Mutations\n */\nexport const useAdminCreateShippingOption = (\n  options?: UseMutationOptions<\n    Response<AdminShippingOptionsRes>,\n    Error,\n    AdminPostShippingOptionsReq\n  >\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n\n  return useMutation(\n    (payload: AdminPostShippingOptionsReq) =>\n      client.admin.shippingOptions.create(payload),\n    buildOptions(queryClient, adminShippingOptionKeys.lists(), options)\n  )\n}\n\n/**\n * This hook updates a shipping option's details.\n * \n * @example\n * import React from \"react\"\n * import { useAdminUpdateShippingOption } from \"medusa-react\"\n * \n * type Props = {\n *   shippingOptionId: string\n * }\n * \n * const ShippingOption = ({ shippingOptionId }: Props) => {\n *   const updateShippingOption = useAdminUpdateShippingOption(\n *     shippingOptionId\n *   )\n *   // ...\n * \n *   const handleUpdate = (\n *     name: string,\n *     requirements: {\n *       id: string,\n *       type: string,\n *       amount: number\n *     }[]\n *   ) => {\n *     updateShippingOption.mutate({\n *       name,\n *       requirements\n *     }, {\n *       onSuccess: ({ shipping_option }) => {\n *         console.log(shipping_option.requirements)\n *       }\n *     })\n *   }\n * \n *   // ...\n * }\n * \n * export default ShippingOption\n * \n * @customNamespace Hooks.Admin.Shipping Options\n * @category Mutations\n */\nexport const useAdminUpdateShippingOption = (\n  /**\n   * The shipping option's ID.\n   */\n  id: string,\n  options?: UseMutationOptions<\n    Response<AdminShippingOptionsRes>,\n    Error,\n    AdminPostShippingOptionsOptionReq\n  >\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n\n  return useMutation(\n    (payload: AdminPostShippingOptionsOptionReq) =>\n      client.admin.shippingOptions.update(id, payload),\n    buildOptions(\n      queryClient,\n      [adminShippingOptionKeys.lists(), adminShippingOptionKeys.detail(id)],\n      options\n    )\n  )\n}\n\n/**\n * This hook deletes a shipping option. Once deleted, it can't be used when creating orders or returns.\n * \n * @example\n * import React from \"react\"\n * import { useAdminDeleteShippingOption } from \"medusa-react\"\n * \n * type Props = {\n *   shippingOptionId: string\n * }\n * \n * const ShippingOption = ({ shippingOptionId }: Props) => {\n *   const deleteShippingOption = useAdminDeleteShippingOption(\n *     shippingOptionId\n *   )\n *   // ...\n * \n *   const handleDelete = () => {\n *     deleteShippingOption.mutate(void 0, {\n *       onSuccess: ({ id, object, deleted }) => {\n *         console.log(id)\n *       }\n *     })\n *   }\n * \n *   // ...\n * }\n * \n * export default ShippingOption\n * \n * @customNamespace Hooks.Admin.Shipping Options\n * @category Mutations\n */\nexport const useAdminDeleteShippingOption = (\n  /**\n   * The shipping option's ID.\n   */\n  id: string,\n  options?: UseMutationOptions\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n\n  return useMutation(\n    () => client.admin.shippingOptions.delete(id),\n    buildOptions(\n      queryClient,\n      [adminShippingOptionKeys.lists(), adminShippingOptionKeys.detail(id)],\n      options\n    )\n  )\n}\n","import {\n  AdminShippingProfilesListRes,\n  AdminShippingProfilesRes,\n} from \"@medusajs/medusa\"\nimport { Response } from \"@medusajs/medusa-js\"\nimport { useQuery } from \"@tanstack/react-query\"\nimport { useMedusa } from \"../../../contexts\"\nimport { UseQueryOptionsWrapper } from \"../../../types\"\nimport { queryKeysFactory } from \"../../utils/index\"\n\nconst ADMIN_COLLECTIONS_QUERY_KEY = `admin_shippingProfiles` as const\n\nexport const adminShippingProfileKeys = queryKeysFactory(\n  ADMIN_COLLECTIONS_QUERY_KEY\n)\n\ntype ShippingProfileQueryKeys = typeof adminShippingProfileKeys\n\n/**\n * This hook retrieves a list of shipping profiles.\n * \n * @example\n * import React from \"react\"\n * import { useAdminShippingProfiles } from \"medusa-react\"\n * \n * const ShippingProfiles = () => {\n *   const { \n *     shipping_profiles, \n *     isLoading\n *   } = useAdminShippingProfiles()\n * \n *   return (\n *     <div>\n *       {isLoading && <span>Loading...</span>}\n *       {shipping_profiles && !shipping_profiles.length && (\n *         <span>No Shipping Profiles</span>\n *       )}\n *       {shipping_profiles && shipping_profiles.length > 0 && (\n *         <ul>\n *           {shipping_profiles.map((profile) => (\n *             <li key={profile.id}>{profile.name}</li>\n *           ))}\n *         </ul>\n *       )}\n *     </div>\n *   )\n * }\n * \n * export default ShippingProfiles\n * \n * @customNamespace Hooks.Admin.Shipping Profiles\n * @category Queries\n */\nexport const useAdminShippingProfiles = (\n  options?: UseQueryOptionsWrapper<\n    Response<AdminShippingProfilesListRes>,\n    Error,\n    ReturnType<ShippingProfileQueryKeys[\"lists\"]>\n  >\n) => {\n  const { client } = useMedusa()\n  const { data, ...rest } = useQuery(\n    adminShippingProfileKeys.lists(),\n    () => client.admin.shippingProfiles.list(),\n    options\n  )\n  return { ...data, ...rest } as const\n}\n\n/**\n * This hook retrieves a shipping profile's details.\n * \n * @example\n * import React from \"react\"\n * import { useAdminShippingProfile } from \"medusa-react\"\n * \n * type Props = {\n *   shippingProfileId: string\n * }\n * \n * const ShippingProfile = ({ shippingProfileId }: Props) => {\n *   const { \n *     shipping_profile, \n *     isLoading\n *   } = useAdminShippingProfile(\n *     shippingProfileId\n *   )\n * \n *   return (\n *     <div>\n *       {isLoading && <span>Loading...</span>}\n *       {shipping_profile && (\n *         <span>{shipping_profile.name}</span>\n *       )}\n *     </div>\n *   )\n * }\n * \n * export default ShippingProfile\n * \n * @customNamespace Hooks.Admin.Shipping Profiles\n * @category Queries\n */\nexport const useAdminShippingProfile = (\n  /**\n   * The shipping option's ID.\n   */\n  id: string,\n  options?: UseQueryOptionsWrapper<\n    Response<AdminShippingProfilesRes>,\n    Error,\n    ReturnType<ShippingProfileQueryKeys[\"detail\"]>\n  >\n) => {\n  const { client } = useMedusa()\n  const { data, ...rest } = useQuery(\n    adminShippingProfileKeys.detail(id),\n    () => client.admin.shippingProfiles.retrieve(id),\n    options\n  )\n  return { ...data, ...rest } as const\n}\n","import {\n  AdminDeleteShippingProfileRes,\n  AdminPostShippingProfilesProfileReq,\n  AdminPostShippingProfilesReq,\n  AdminShippingProfilesRes,\n} from \"@medusajs/medusa\"\nimport { Response } from \"@medusajs/medusa-js\"\nimport {\n  useMutation,\n  UseMutationOptions,\n  useQueryClient,\n} from \"@tanstack/react-query\"\nimport { useMedusa } from \"../../../contexts/medusa\"\nimport { buildOptions } from \"../../utils/buildOptions\"\nimport { adminShippingProfileKeys } from \"./queries\"\n\n/**\n * This hook creates a shipping profile.\n * \n * @example\n * import React from \"react\"\n * import { ShippingProfileType } from \"@medusajs/medusa\"\n * import { useAdminCreateShippingProfile } from \"medusa-react\"\n * \n * const CreateShippingProfile = () => {\n *   const createShippingProfile = useAdminCreateShippingProfile()\n *   // ...\n * \n *   const handleCreate = (\n *     name: string,\n *     type: ShippingProfileType\n *   ) => {\n *     createShippingProfile.mutate({\n *       name,\n *       type\n *     }, {\n *       onSuccess: ({ shipping_profile }) => {\n *         console.log(shipping_profile.id)\n *       }\n *     })\n *   }\n * \n *   // ...\n * }\n * \n * export default CreateShippingProfile\n * \n * @customNamespace Hooks.Admin.Shipping Profiles\n * @category Mutations\n */\nexport const useAdminCreateShippingProfile = (\n  options?: UseMutationOptions<\n    Response<AdminShippingProfilesRes>,\n    Error,\n    AdminPostShippingProfilesReq\n  >\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n  return useMutation(\n    (payload: AdminPostShippingProfilesReq) =>\n      client.admin.shippingProfiles.create(payload),\n    buildOptions(queryClient, adminShippingProfileKeys.lists(), options)\n  )\n}\n\n/**\n * This hook updates a shipping profile's details.\n * \n * @example\n * import React from \"react\"\n * import { ShippingProfileType } from \"@medusajs/medusa\"\n * import { useAdminUpdateShippingProfile } from \"medusa-react\"\n * \n * type Props = {\n *   shippingProfileId: string\n * }\n * \n * const ShippingProfile = ({ shippingProfileId }: Props) => {\n *   const updateShippingProfile = useAdminUpdateShippingProfile(\n *     shippingProfileId\n *   )\n *   // ...\n * \n *   const handleUpdate = (\n *     name: string,\n *     type: ShippingProfileType\n *   ) => {\n *     updateShippingProfile.mutate({\n *       name,\n *       type\n *     }, {\n *       onSuccess: ({ shipping_profile }) => {\n *         console.log(shipping_profile.name)\n *       }\n *     })\n *   }\n * \n *   // ...\n * }\n * \n * export default ShippingProfile\n * \n * @customNamespace Hooks.Admin.Shipping Profiles\n * @category Mutations\n */\nexport const useAdminUpdateShippingProfile = (\n  /**\n   * The shipping profile's ID.\n   */\n  id: string,\n  options?: UseMutationOptions<\n    Response<AdminShippingProfilesRes>,\n    Error,\n    AdminPostShippingProfilesProfileReq\n  >\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n\n  return useMutation(\n    (payload: AdminPostShippingProfilesProfileReq) =>\n      client.admin.shippingProfiles.update(id, payload),\n    buildOptions(\n      queryClient,\n      [adminShippingProfileKeys.lists(), adminShippingProfileKeys.detail(id)],\n      options\n    )\n  )\n}\n\n/**\n * This hook deletes a shipping profile. Associated shipping options are deleted as well.\n * \n * @example\n * import React from \"react\"\n * import { useAdminDeleteShippingProfile } from \"medusa-react\"\n * \n * type Props = {\n *   shippingProfileId: string\n * }\n * \n * const ShippingProfile = ({ shippingProfileId }: Props) => {\n *   const deleteShippingProfile = useAdminDeleteShippingProfile(\n *     shippingProfileId\n *   )\n *   // ...\n * \n *   const handleDelete = () => {\n *     deleteShippingProfile.mutate(void 0, {\n *       onSuccess: ({ id, object, deleted }) => {\n *         console.log(id)\n *       }\n *     })\n *   }\n * \n *   // ...\n * }\n * \n * export default ShippingProfile\n * \n * @customNamespace Hooks.Admin.Shipping Profiles\n * @category Mutations\n */\nexport const useAdminDeleteShippingProfile = (\n  /**\n   * The shipping profile's ID.\n   */\n  id: string,\n  options?: UseMutationOptions<\n    Response<AdminDeleteShippingProfileRes>,\n    Error,\n    void\n  >\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n\n  return useMutation(\n    () => client.admin.shippingProfiles.delete(id),\n    buildOptions(\n      queryClient,\n      [adminShippingProfileKeys.lists(), adminShippingProfileKeys.detail(id)],\n      options\n    )\n  )\n}\n","import {\n  AdminExtendedStoresRes,\n  AdminPaymentProvidersList,\n  AdminTaxProvidersList,\n} from \"@medusajs/medusa\"\nimport { Response } from \"@medusajs/medusa-js\"\nimport { useQuery } from \"@tanstack/react-query\"\nimport { useMedusa } from \"../../../contexts\"\nimport { UseQueryOptionsWrapper } from \"../../../types\"\nimport { queryKeysFactory } from \"../../utils/index\"\n\nconst ADMIN_STORE_QUERY_KEY = `admin_store` as const\n\nexport const adminStoreKeys = queryKeysFactory(ADMIN_STORE_QUERY_KEY)\n\ntype StoreQueryKeys = typeof adminStoreKeys\n\n/**\n * This hook retrieves a list of available payment providers in a store.\n * \n * @example\n * import React from \"react\"\n * import { useAdminStorePaymentProviders } from \"medusa-react\"\n * \n * const PaymentProviders = () => {\n *   const { \n *     payment_providers,\n *     isLoading\n *   } = useAdminStorePaymentProviders()\n * \n *   return (\n *     <div>\n *       {isLoading && <span>Loading...</span>}\n *       {payment_providers && !payment_providers.length && (\n *         <span>No Payment Providers</span>\n *       )}\n *       {payment_providers && \n *         payment_providers.length > 0 &&(\n *           <ul>\n *             {payment_providers.map((provider) => (\n *               <li key={provider.id}>{provider.id}</li>\n *             ))}\n *           </ul>\n *       )}\n *     </div>\n *   )\n * }\n * \n * export default PaymentProviders\n * \n * @customNamespace Hooks.Admin.Stores\n * @category Queries\n */\nexport const useAdminStorePaymentProviders = (\n  options?: UseQueryOptionsWrapper<\n    Response<AdminPaymentProvidersList>,\n    Error,\n    ReturnType<StoreQueryKeys[\"detail\"]>\n  >\n) => {\n  const { client } = useMedusa()\n  const { data, ...rest } = useQuery(\n    adminStoreKeys.detail(\"payment_providers\"),\n    () => client.admin.store.listPaymentProviders(),\n    options\n  )\n  return { ...data, ...rest } as const\n}\n\n/**\n * This hook retrieves a list of available tax providers in a store.\n * \n * @example\n * import React from \"react\"\n * import { useAdminStoreTaxProviders } from \"medusa-react\"\n * \n * const TaxProviders = () => {\n *   const { \n *     tax_providers,\n *     isLoading\n *   } = useAdminStoreTaxProviders()\n * \n *   return (\n *     <div>\n *       {isLoading && <span>Loading...</span>}\n *       {tax_providers && !tax_providers.length && (\n *         <span>No Tax Providers</span>\n *       )}\n *       {tax_providers && \n *         tax_providers.length > 0 &&(\n *           <ul>\n *             {tax_providers.map((provider) => (\n *               <li key={provider.id}>{provider.id}</li>\n *             ))}\n *           </ul>\n *       )}\n *     </div>\n *   )\n * }\n * \n * export default TaxProviders\n * \n * @customNamespace Hooks.Admin.Stores\n * @category Queries\n */\nexport const useAdminStoreTaxProviders = (\n  options?: UseQueryOptionsWrapper<\n    Response<AdminTaxProvidersList>,\n    Error,\n    ReturnType<StoreQueryKeys[\"detail\"]>\n  >\n) => {\n  const { client } = useMedusa()\n  const { data, ...rest } = useQuery(\n    adminStoreKeys.detail(\"tax_providers\"),\n    () => client.admin.store.listTaxProviders(),\n    options\n  )\n  return { ...data, ...rest } as const\n}\n\n/**\n * This hook retrieves the store's details.\n * \n * @example\n * import React from \"react\"\n * import { useAdminStore } from \"medusa-react\"\n * \n * const Store = () => {\n *   const { \n *     store,\n *     isLoading\n *   } = useAdminStore()\n * \n *   return (\n *     <div>\n *       {isLoading && <span>Loading...</span>}\n *       {store && <span>{store.name}</span>}\n *     </div>\n *   )\n * }\n * \n * export default Store\n * \n * @customNamespace Hooks.Admin.Stores\n * @category Queries\n */\nexport const useAdminStore = (\n  options?: UseQueryOptionsWrapper<\n    Response<AdminExtendedStoresRes>,\n    Error,\n    ReturnType<StoreQueryKeys[\"details\"]>\n  >\n) => {\n  const { client } = useMedusa()\n  const { data, ...rest } = useQuery(\n    adminStoreKeys.details(),\n    () => client.admin.store.retrieve(),\n    options\n  )\n  return { ...data, ...rest } as const\n}\n","import { AdminPostStoreReq, AdminStoresRes } from \"@medusajs/medusa\"\nimport { Response } from \"@medusajs/medusa-js\"\nimport {\n  useMutation,\n  UseMutationOptions,\n  useQueryClient,\n} from \"@tanstack/react-query\"\nimport { useMedusa } from \"../../../contexts/medusa\"\nimport { buildOptions } from \"../../utils/buildOptions\"\nimport { adminStoreKeys } from \"./queries\"\n\n/**\n * This hook updates the store's details.\n * \n * @example\n * import React from \"react\"\n * import { useAdminUpdateStore } from \"medusa-react\"\n * \n * function Store() {\n *   const updateStore = useAdminUpdateStore()\n *   // ...\n * \n *   const handleUpdate = (\n *     name: string\n *   ) => {\n *     updateStore.mutate({\n *       name\n *     }, {\n *       onSuccess: ({ store }) => {\n *         console.log(store.name)\n *       }\n *     })\n *   }\n * }\n * \n * export default Store\n * \n * @customNamespace Hooks.Admin.Stores\n * @category Mutations\n */\nexport const useAdminUpdateStore = (\n  options?: UseMutationOptions<\n    Response<AdminStoresRes>,\n    Error,\n    AdminPostStoreReq\n  >\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n\n  return useMutation(\n    (payload: AdminPostStoreReq) => client.admin.store.update(payload),\n    buildOptions(queryClient, adminStoreKeys.details(), options)\n  )\n}\n\n/**\n * This hook adds a currency code to the available currencies in a store. This doesn't create new currencies, as currencies are defined within the Medusa backend. \n * To create a currency, you can [create a migration](https://docs.medusajs.com/development/entities/migrations/create) that inserts the currency into the database.\n * \n * @typeParamDefinition string - The code of the currency to add to the store.\n * \n * @example\n * import React from \"react\"\n * import { useAdminAddStoreCurrency } from \"medusa-react\"\n * \n * const Store = () => {\n *   const addCurrency = useAdminAddStoreCurrency()\n *   // ...\n * \n *   const handleAdd = (code: string) => {\n *     addCurrency.mutate(code, {\n *       onSuccess: ({ store }) => {\n *         console.log(store.currencies)\n *       }\n *     })\n *   }\n * \n *   // ...\n * }\n * \n * export default Store\n * \n * @customNamespace Hooks.Admin.Stores\n * @category Mutations\n */\nexport const useAdminAddStoreCurrency = (\n  options?: UseMutationOptions<Response<AdminStoresRes>, Error, string>\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n\n  return useMutation(\n    (currency_code: string) => client.admin.store.addCurrency(currency_code),\n    buildOptions(queryClient, adminStoreKeys.details(), options)\n  )\n}\n\n/**\n * This hook deletes a currency code from the available currencies in a store. This doesn't completely \n * delete the currency and it can be added again later to the store.\n * \n * @typeParamDefinition string - The code of the currency to remove from the store.\n * \n * @example\n * import React from \"react\"\n * import { useAdminDeleteStoreCurrency } from \"medusa-react\"\n * \n * const Store = () => {\n *   const deleteCurrency = useAdminDeleteStoreCurrency()\n *   // ...\n * \n *   const handleAdd = (code: string) => {\n *     deleteCurrency.mutate(code, {\n *       onSuccess: ({ store }) => {\n *         console.log(store.currencies)\n *       }\n *     })\n *   }\n * \n *   // ...\n * }\n * \n * export default Store\n * \n * @customNamespace Hooks.Admin.Stores\n * @category Mutations\n */\nexport const useAdminDeleteStoreCurrency = (\n  options?: UseMutationOptions<Response<AdminStoresRes>, Error, string>\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n\n  return useMutation(\n    (currency_code: string) => client.admin.store.deleteCurrency(currency_code),\n    buildOptions(queryClient, adminStoreKeys.details(), options)\n  )\n}\n","import {\n  AdminGetSwapsParams,\n  AdminSwapsListRes,\n  AdminSwapsRes,\n} from \"@medusajs/medusa\"\nimport { Response } from \"@medusajs/medusa-js\"\nimport { useQuery } from \"@tanstack/react-query\"\nimport { useMedusa } from \"../../../contexts\"\nimport { UseQueryOptionsWrapper } from \"../../../types\"\nimport { queryKeysFactory } from \"../../utils/index\"\n\nconst ADMIN_SWAPS_QUERY_KEY = `admin_swaps` as const\n\nexport const adminSwapKeys = queryKeysFactory(ADMIN_SWAPS_QUERY_KEY)\n\ntype SwapsQueryKey = typeof adminSwapKeys\n\n/**\n * This hook retrieves a list of swaps. The swaps can be paginated.\n * \n * @example\n * To list swaps:\n * \n * ```tsx\n * import React from \"react\"\n * import { useAdminSwaps } from \"medusa-react\"\n * \n * const Swaps = () => {\n *   const { swaps, isLoading } = useAdminSwaps()\n * \n *   return (\n *     <div>\n *       {isLoading && <span>Loading...</span>}\n *       {swaps && !swaps.length && <span>No Swaps</span>}\n *       {swaps && swaps.length > 0 && (\n *         <ul>\n *           {swaps.map((swap) => (\n *             <li key={swap.id}>{swap.payment_status}</li>\n *           ))}\n *         </ul>\n *       )}\n *     </div>\n *   )\n * }\n * \n * export default Swaps\n * ```\n * \n * By default, only the first `50` records are retrieved. You can control pagination by specifying the `limit` and `offset` properties:\n * \n * ```tsx\n * import React from \"react\"\n * import { useAdminSwaps } from \"medusa-react\"\n * \n * const Swaps = () => {\n *   const { \n *     swaps, \n *     limit,\n *     offset,\n *     isLoading\n *   } = useAdminSwaps({\n *     limit: 10,\n *     offset: 0\n *   })\n * \n *   return (\n *     <div>\n *       {isLoading && <span>Loading...</span>}\n *       {swaps && !swaps.length && <span>No Swaps</span>}\n *       {swaps && swaps.length > 0 && (\n *         <ul>\n *           {swaps.map((swap) => (\n *             <li key={swap.id}>{swap.payment_status}</li>\n *           ))}\n *         </ul>\n *       )}\n *     </div>\n *   )\n * }\n * \n * export default Swaps\n * ```\n * \n * @customNamespace Hooks.Admin.Swaps\n * @category Queries\n */\nexport const useAdminSwaps = (\n  /**\n   * Pagination configurations to apply on the retrieved swaps.\n   */\n  query?: AdminGetSwapsParams,\n  options?: UseQueryOptionsWrapper<\n    Response<AdminSwapsListRes>,\n    Error,\n    ReturnType<SwapsQueryKey[\"list\"]>\n  >\n) => {\n  const { client } = useMedusa()\n  const { data, ...rest } = useQuery(\n    adminSwapKeys.list(query),\n    () => client.admin.swaps.list(query),\n    options\n  )\n  return { ...data, ...rest } as const\n}\n\n/**\n * This hook retrieves a swap's details.\n * \n * @example\n * import React from \"react\"\n * import { useAdminSwap } from \"medusa-react\"\n * \n * type Props = {\n *   swapId: string\n * }\n * \n * const Swap = ({ swapId }: Props) => {\n *   const { swap, isLoading } = useAdminSwap(swapId)\n * \n *   return (\n *     <div>\n *       {isLoading && <span>Loading...</span>}\n *       {swap && <span>{swap.id}</span>}\n *     </div>\n *   )\n * }\n * \n * export default Swap\n * \n * @customNamespace Hooks.Admin.Swaps\n * @category Queries\n */\nexport const useAdminSwap = (\n  /**\n   * The swap's ID.\n   */\n  id: string,\n  options?: UseQueryOptionsWrapper<\n    Response<AdminSwapsRes>,\n    Error,\n    ReturnType<SwapsQueryKey[\"detail\"]>\n  >\n) => {\n  const { client } = useMedusa()\n  const { data, ...rest } = useQuery(\n    adminSwapKeys.detail(id),\n    () => client.admin.swaps.retrieve(id),\n    options\n  )\n  return { ...data, ...rest } as const\n}\n","import {\n  AdminOrdersRes,\n  AdminPostOrdersOrderSwapsReq,\n  AdminPostOrdersOrderSwapsSwapFulfillmentsReq,\n  AdminPostOrdersOrderSwapsSwapShipmentsReq,\n} from \"@medusajs/medusa\"\nimport { Response } from \"@medusajs/medusa-js\"\nimport {\n  useMutation,\n  UseMutationOptions,\n  useQueryClient,\n} from \"@tanstack/react-query\"\nimport { adminOrderKeys, adminProductKeys, adminVariantKeys } from \"..\"\nimport { useMedusa } from \"../../../contexts/medusa\"\nimport { buildOptions } from \"../../utils/buildOptions\"\nimport { adminSwapKeys } from \"./queries\"\n\n/**\n * This hook creates a swap for an order. This includes creating a return that is associated with the swap.\n * \n * @example\n * import React from \"react\"\n * import { useAdminCreateSwap } from \"medusa-react\"\n * \n * type Props = {\n *   orderId: string\n * }\n * \n * const CreateSwap = ({ orderId }: Props) => {\n *   const createSwap = useAdminCreateSwap(orderId)\n *   // ...\n * \n *   const handleCreate = (\n *     returnItems: {\n *       item_id: string,\n *       quantity: number\n *     }[]\n *   ) => {\n *     createSwap.mutate({\n *       return_items: returnItems\n *     }, {\n *       onSuccess: ({ order }) => {\n *         console.log(order.swaps)\n *       }\n *     })\n *   }\n * \n *   // ...\n * }\n * \n * export default CreateSwap\n * \n * @customNamespace Hooks.Admin.Swaps\n * @category Mutations\n */\nexport const useAdminCreateSwap = (\n  /**\n   * The associated order's ID.\n   */\n  orderId: string,\n  options?: UseMutationOptions<\n    Response<AdminOrdersRes>,\n    Error,\n    AdminPostOrdersOrderSwapsReq\n  >\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n  return useMutation(\n    (payload: AdminPostOrdersOrderSwapsReq) =>\n      client.admin.orders.createSwap(orderId, payload),\n    buildOptions(\n      queryClient,\n      [adminOrderKeys.detail(orderId), adminSwapKeys.lists()],\n      options\n    )\n  )\n}\n\n/**\n * This hook cancels a swap and change its status.\n * \n * @typeParamDefinition string - The swap's ID.\n * \n * @example\n * import React from \"react\"\n * import { useAdminCancelSwap } from \"medusa-react\"\n * \n * type Props = {\n *   orderId: string,\n *   swapId: string\n * }\n * \n * const Swap = ({\n *   orderId,\n *   swapId\n * }: Props) => {\n *   const cancelSwap = useAdminCancelSwap(\n *     orderId\n *   )\n *   // ...\n * \n *   const handleCancel = () => {\n *     cancelSwap.mutate(swapId, {\n *       onSuccess: ({ order }) => {\n *         console.log(order.swaps)\n *       }\n *     })\n *   }\n * \n *   // ...\n * }\n * \n * export default Swap\n * \n * @customNamespace Hooks.Admin.Swaps\n * @category Mutations\n */\nexport const useAdminCancelSwap = (\n  /**\n   * The associated order's ID.\n   */\n  orderId: string,\n  options?: UseMutationOptions<Response<AdminOrdersRes>, Error, string>\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n\n  return useMutation(\n    (swapId: string) => client.admin.orders.cancelSwap(orderId, swapId),\n    buildOptions(\n      queryClient,\n      [adminOrderKeys.detail(orderId), adminSwapKeys.lists()],\n      options\n    )\n  )\n}\n\nexport type AdminFulfillSwapReq = AdminPostOrdersOrderSwapsSwapFulfillmentsReq & { \n  /**\n   * The swap's ID.\n   */\n  swap_id: string\n}\n\n/**\n * This hook creates a Fulfillment for a Swap and change its fulfillment status to `fulfilled`. If it requires any additional actions,\n * its fulfillment status may change to `requires_action`.\n * \n * @example\n * import React from \"react\"\n * import { useAdminFulfillSwap } from \"medusa-react\"\n * \n * type Props = {\n *   orderId: string,\n *   swapId: string\n * }\n * \n * const Swap = ({\n *   orderId,\n *   swapId\n * }: Props) => {\n *   const fulfillSwap = useAdminFulfillSwap(\n *     orderId\n *   )\n *   // ...\n * \n *   const handleFulfill = () => {\n *     fulfillSwap.mutate({\n *       swap_id: swapId,\n *     }, {\n *       onSuccess: ({ order }) => {\n *         console.log(order.swaps)\n *       }\n *     })\n *   }\n * \n *   // ...\n * }\n * \n * export default Swap\n * \n * @customNamespace Hooks.Admin.Swaps\n * @category Mutations\n */\nexport const useAdminFulfillSwap = (\n  /**\n   * The associated order's ID.\n   */\n  orderId: string,\n  options?: UseMutationOptions<\n    Response<AdminOrdersRes>,\n    Error,\n    AdminFulfillSwapReq\n  >\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n\n  return useMutation(\n    ({\n      swap_id,\n      ...payload\n    }: AdminFulfillSwapReq) =>\n      client.admin.orders.fulfillSwap(orderId, swap_id, payload),\n    buildOptions(\n      queryClient,\n      [\n        adminOrderKeys.detail(orderId),\n        adminSwapKeys.lists(),\n        adminVariantKeys.all,\n        adminProductKeys.lists(),\n      ],\n      options\n    )\n  )\n}\n\nexport type AdminCreateSwapShipmentReq = AdminPostOrdersOrderSwapsSwapShipmentsReq & { \n  /**\n   * The swap's ID.\n   */\n  swap_id: string\n}\n\n/**\n * This hook creates a shipment for a swap and mark its fulfillment as shipped. This changes the swap's fulfillment status\n * to either `shipped` or `partially_shipped`, depending on whether all the items were shipped.\n * \n * @example\n * import React from \"react\"\n * import { useAdminCreateSwapShipment } from \"medusa-react\"\n * \n * type Props = {\n *   orderId: string,\n *   swapId: string\n * }\n * \n * const Swap = ({\n *   orderId,\n *   swapId\n * }: Props) => {\n *   const createShipment = useAdminCreateSwapShipment(\n *     orderId\n *   )\n *   // ...\n * \n *   const handleCreateShipment = (\n *     fulfillmentId: string\n *   ) => {\n *     createShipment.mutate({\n *       swap_id: swapId,\n *       fulfillment_id: fulfillmentId,\n *     }, {\n *       onSuccess: ({ order }) => {\n *         console.log(order.swaps)\n *       }\n *     })\n *   }\n * \n *   // ...\n * }\n * \n * export default Swap\n * \n * @customNamespace Hooks.Admin.Swaps\n * @category Mutations\n */\nexport const useAdminCreateSwapShipment = (\n  /**\n   * The associated order's ID.\n   */\n  orderId: string,\n  options?: UseMutationOptions<\n    Response<AdminOrdersRes>,\n    Error,\n    AdminCreateSwapShipmentReq\n  >\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n\n  return useMutation(\n    ({\n      swap_id,\n      ...payload\n    }: AdminCreateSwapShipmentReq) =>\n      client.admin.orders.createSwapShipment(orderId, swap_id, payload),\n    buildOptions(queryClient, adminOrderKeys.detail(orderId), options)\n  )\n}\n\n/**\n * This hook process a swap's payment either by refunding or issuing a payment. This depends on the `difference_due` \n * of the swap. If `difference_due` is negative, the amount is refunded. If `difference_due` is positive, the amount is captured.\n * \n * @typeParamDefinition string - The swap's ID.\n * \n * @example\n * import React from \"react\"\n * import { useAdminProcessSwapPayment } from \"medusa-react\"\n * \n * type Props = {\n *   orderId: string,\n *   swapId: string\n * }\n * \n * const Swap = ({\n *   orderId,\n *   swapId\n * }: Props) => {\n *   const processPayment = useAdminProcessSwapPayment(\n *     orderId\n *   )\n *   // ...\n * \n *   const handleProcessPayment = () => {\n *     processPayment.mutate(swapId, {\n *       onSuccess: ({ order }) => {\n *         console.log(order.swaps)\n *       }\n *     })\n *   }\n * \n *   // ...\n * }\n * \n * export default Swap\n * \n * @customNamespace Hooks.Admin.Swaps\n * @category Mutations\n */\nexport const useAdminProcessSwapPayment = (\n  /**\n   * The associated order's ID.\n   */\n  orderId: string,\n  options?: UseMutationOptions<Response<AdminOrdersRes>, Error, string>\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n\n  return useMutation(\n    (swapId: string) => client.admin.orders.processSwapPayment(orderId, swapId),\n    buildOptions(\n      queryClient,\n      [adminOrderKeys.detail(orderId), adminSwapKeys.lists()],\n      options\n    )\n  )\n}\n\n/**\n * The details of the swap's fulfillment to cancel.\n */\nexport type AdminCancelSwapFulfillmentReq = { \n  /**\n   * The swap's ID.\n   */\n  swap_id: string\n  /**\n   * The fulfillment's ID.\n   */\n  fulfillment_id: string\n}\n\n/**\n * This hook cancels a swap's fulfillment and change its fulfillment status to `canceled`.\n * \n * @example\n * import React from \"react\"\n * import { useAdminCancelSwapFulfillment } from \"medusa-react\"\n * \n * type Props = {\n *   orderId: string,\n *   swapId: string\n * }\n * \n * const Swap = ({\n *   orderId,\n *   swapId\n * }: Props) => {\n *   const cancelFulfillment = useAdminCancelSwapFulfillment(\n *     orderId\n *   )\n *   // ...\n * \n *   const handleCancelFulfillment = (\n *     fulfillmentId: string\n *   ) => {\n *     cancelFulfillment.mutate({\n *       swap_id: swapId,\n *       fulfillment_id: fulfillmentId,\n *     })\n *   }\n * \n *   // ...\n * }\n * \n * export default Swap\n * \n * @customNamespace Hooks.Admin.Swaps\n * @category Mutations\n */\nexport const useAdminCancelSwapFulfillment = (\n  /**\n   * The associated order's ID.\n   */\n  orderId: string,\n  options?: UseMutationOptions<\n    Response<AdminOrdersRes>,\n    Error,\n    { swap_id: string; fulfillment_id: string }\n  >\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n\n  return useMutation(\n    ({\n      swap_id,\n      fulfillment_id,\n    }: {\n      swap_id: string\n      fulfillment_id: string\n    }) =>\n      client.admin.orders.cancelSwapFulfillment(\n        orderId,\n        swap_id,\n        fulfillment_id\n      ),\n    buildOptions(\n      queryClient,\n      [adminOrderKeys.detail(orderId), adminSwapKeys.lists()],\n      options\n    )\n  )\n}\n","import {\n  AdminGetTaxRatesParams,\n  AdminTaxRatesListRes,\n  AdminTaxRatesRes,\n} from \"@medusajs/medusa\"\nimport { Response } from \"@medusajs/medusa-js\"\nimport { useQuery } from \"@tanstack/react-query\"\nimport { useMedusa } from \"../../../contexts\"\nimport { UseQueryOptionsWrapper } from \"../../../types\"\nimport { queryKeysFactory } from \"../../utils/index\"\n\nconst ADMIN_TAX_RATES_QUERY_KEY = `admin_tax_rates` as const\n\nexport const adminTaxRateKeys = queryKeysFactory(ADMIN_TAX_RATES_QUERY_KEY)\n\ntype TaxRateQueryKeys = typeof adminTaxRateKeys\n\n/**\n * This hook retrieves a list of tax rates. The tax rates can be filtered by fields such as `name` or `rate` \n * passed in the `query` parameter. The tax rates can also be paginated.\n * \n * @example\n * To list tax rates:\n * \n * ```tsx\n * import React from \"react\"\n * import { useAdminTaxRates } from \"medusa-react\"\n * \n * const TaxRates = () => {\n *   const { \n *     tax_rates, \n *     isLoading\n *   } = useAdminTaxRates()\n * \n *   return (\n *     <div>\n *       {isLoading && <span>Loading...</span>}\n *       {tax_rates && !tax_rates.length && (\n *         <span>No Tax Rates</span>\n *       )}\n *       {tax_rates && tax_rates.length > 0 && (\n *         <ul>\n *           {tax_rates.map((tax_rate) => (\n *             <li key={tax_rate.id}>{tax_rate.code}</li>\n *           ))}\n *         </ul>\n *       )}\n *     </div>\n *   )\n * }\n * \n * export default TaxRates\n * ```\n * \n * To specify relations that should be retrieved within the tax rates:\n * \n * ```tsx\n * import React from \"react\"\n * import { useAdminTaxRates } from \"medusa-react\"\n * \n * const TaxRates = () => {\n *   const { \n *     tax_rates, \n *     isLoading\n *   } = useAdminTaxRates({\n *     expand: [\"shipping_options\"]\n *   })\n * \n *   return (\n *     <div>\n *       {isLoading && <span>Loading...</span>}\n *       {tax_rates && !tax_rates.length && (\n *         <span>No Tax Rates</span>\n *       )}\n *       {tax_rates && tax_rates.length > 0 && (\n *         <ul>\n *           {tax_rates.map((tax_rate) => (\n *             <li key={tax_rate.id}>{tax_rate.code}</li>\n *           ))}\n *         </ul>\n *       )}\n *     </div>\n *   )\n * }\n * \n * export default TaxRates\n * ```\n * \n * By default, only the first `50` records are retrieved. You can control pagination by specifying the `limit` and `offset` properties:\n * \n * ```tsx\n * import React from \"react\"\n * import { useAdminTaxRates } from \"medusa-react\"\n * \n * const TaxRates = () => {\n *   const { \n *     tax_rates, \n *     limit,\n *     offset,\n *     isLoading\n *   } = useAdminTaxRates({\n *     expand: [\"shipping_options\"],\n *     limit: 10,\n *     offset: 0\n *   })\n * \n *   return (\n *     <div>\n *       {isLoading && <span>Loading...</span>}\n *       {tax_rates && !tax_rates.length && (\n *         <span>No Tax Rates</span>\n *       )}\n *       {tax_rates && tax_rates.length > 0 && (\n *         <ul>\n *           {tax_rates.map((tax_rate) => (\n *             <li key={tax_rate.id}>{tax_rate.code}</li>\n *           ))}\n *         </ul>\n *       )}\n *     </div>\n *   )\n * }\n * \n * export default TaxRates\n * ```\n * \n * @customNamespace Hooks.Admin.Tax Rates\n * @category Queries\n */\nexport const useAdminTaxRates = (\n  /**\n   * Filters and pagination configurations applied to the retrieved tax rates.\n   */\n  query?: AdminGetTaxRatesParams,\n  options?: UseQueryOptionsWrapper<\n    Response<AdminTaxRatesListRes>,\n    Error,\n    ReturnType<TaxRateQueryKeys[\"list\"]>\n  >\n) => {\n  const { client } = useMedusa()\n  const { data, ...rest } = useQuery(\n    adminTaxRateKeys.list(query),\n    () => client.admin.taxRates.list(query),\n    options\n  )\n  return { ...data, ...rest } as const\n}\n\n/**\n * This hook retrieves a tax rate's details.\n * \n * @example\n * A simple example that retrieves a tax rate by its ID:\n * \n * ```tsx\n * import React from \"react\"\n * import { useAdminTaxRate } from \"medusa-react\"\n * \n * type Props = {\n *   taxRateId: string\n * }\n * \n * const TaxRate = ({ taxRateId }: Props) => {\n *   const { tax_rate, isLoading } = useAdminTaxRate(taxRateId)\n * \n *   return (\n *     <div>\n *       {isLoading && <span>Loading...</span>}\n *       {tax_rate && <span>{tax_rate.code}</span>}\n *     </div>\n *   )\n * }\n * \n * export default TaxRate\n * ```\n * \n * To specify relations that should be retrieved:\n * \n * ```tsx\n * import React from \"react\"\n * import { useAdminTaxRate } from \"medusa-react\"\n * \n * const TaxRate = (taxRateId: string) => {\n *   const { tax_rate, isLoading } = useAdminTaxRate(taxRateId, {\n *     expand: [\"shipping_options\"]\n *   })\n * \n *   return (\n *     <div>\n *       {isLoading && <span>Loading...</span>}\n *       {tax_rate && <span>{tax_rate.code}</span>}\n *     </div>\n *   )\n * }\n * \n * export default TaxRate\n * ```\n * \n * @customNamespace Hooks.Admin.Tax Rates\n * @category Queries\n */\nexport const useAdminTaxRate = (\n  /**\n   * The tax rate's ID.\n   */\n  id: string,\n  /**\n   * Configurations to apply on retrieved tax rates.\n   */\n  query?: AdminGetTaxRatesParams,\n  options?: UseQueryOptionsWrapper<\n    Response<AdminTaxRatesRes>,\n    Error,\n    ReturnType<TaxRateQueryKeys[\"detail\"]>\n  >\n) => {\n  const { client } = useMedusa()\n  const { data, ...rest } = useQuery(\n    adminTaxRateKeys.detail(id),\n    () => client.admin.taxRates.retrieve(id, query),\n    options\n  )\n  return { ...data, ...rest } as const\n}\n","import {\n  AdminDeleteTaxRatesTaxRateProductsReq,\n  AdminDeleteTaxRatesTaxRateProductTypesReq,\n  AdminDeleteTaxRatesTaxRateShippingOptionsReq,\n  AdminPostTaxRatesReq,\n  AdminPostTaxRatesTaxRateProductsReq,\n  AdminPostTaxRatesTaxRateProductTypesReq,\n  AdminPostTaxRatesTaxRateReq,\n  AdminPostTaxRatesTaxRateShippingOptionsReq,\n  AdminTaxRatesDeleteRes,\n  AdminTaxRatesRes,\n} from \"@medusajs/medusa\"\nimport { Response } from \"@medusajs/medusa-js\"\nimport {\n  useMutation,\n  UseMutationOptions,\n  useQueryClient,\n} from \"@tanstack/react-query\"\nimport { useMedusa } from \"../../../contexts/medusa\"\nimport { buildOptions } from \"../../utils/buildOptions\"\nimport { adminTaxRateKeys } from \"./queries\"\n\n/**\n * This hook creates a tax rate.\n * \n * @example\n * import React from \"react\"\n * import { useAdminCreateTaxRate } from \"medusa-react\"\n * \n * type Props = {\n *   regionId: string\n * }\n * \n * const CreateTaxRate = ({ regionId }: Props) => {\n *   const createTaxRate = useAdminCreateTaxRate()\n *   // ...\n * \n *   const handleCreate = (\n *     code: string,\n *     name: string,\n *     rate: number\n *   ) => {\n *     createTaxRate.mutate({\n *       code,\n *       name,\n *       region_id: regionId,\n *       rate,\n *     }, {\n *       onSuccess: ({ tax_rate }) => {\n *         console.log(tax_rate.id)\n *       }\n *     })\n *   }\n * \n *   // ...\n * }\n * \n * export default CreateTaxRate\n * \n * @customNamespace Hooks.Admin.Tax Rates\n * @category Mutations\n */\nexport const useAdminCreateTaxRate = (\n  options?: UseMutationOptions<\n    Response<AdminTaxRatesRes>,\n    Error,\n    AdminPostTaxRatesReq\n  >\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n  return useMutation(\n    (payload: AdminPostTaxRatesReq) => client.admin.taxRates.create(payload),\n    buildOptions(queryClient, adminTaxRateKeys.lists(), options)\n  )\n}\n\n/**\n * This hook updates a tax rate's details.\n * \n * @example\n * import React from \"react\"\n * import { useAdminUpdateTaxRate } from \"medusa-react\"\n * \n * type Props = {\n *   taxRateId: string\n * }\n * \n * const TaxRate = ({ taxRateId }: Props) => {\n *   const updateTaxRate = useAdminUpdateTaxRate(taxRateId)\n *   // ...\n * \n *   const handleUpdate = (\n *     name: string\n *   ) => {\n *     updateTaxRate.mutate({\n *       name\n *     }, {\n *       onSuccess: ({ tax_rate }) => {\n *         console.log(tax_rate.name)\n *       }\n *     })\n *   }\n * \n *   // ...\n * }\n * \n * export default TaxRate\n * \n * @customNamespace Hooks.Admin.Tax Rates\n * @category Mutations\n */\nexport const useAdminUpdateTaxRate = (\n  /**\n   * The tax rate's ID.\n   */\n  id: string,\n  options?: UseMutationOptions<\n    Response<AdminTaxRatesRes>,\n    Error,\n    AdminPostTaxRatesTaxRateReq\n  >\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n\n  return useMutation(\n    (payload: AdminPostTaxRatesTaxRateReq) =>\n      client.admin.taxRates.update(id, payload),\n    buildOptions(\n      queryClient,\n      [adminTaxRateKeys.lists(), adminTaxRateKeys.detail(id)],\n      options\n    )\n  )\n}\n\n/**\n * This hook deletes a tax rate. Resources associated with the tax rate, such as products or product types, are not deleted.\n * \n * @example\n * import React from \"react\"\n * import { useAdminDeleteTaxRate } from \"medusa-react\"\n * \n * type Props = {\n *   taxRateId: string\n * }\n * \n * const TaxRate = ({ taxRateId }: Props) => {\n *   const deleteTaxRate = useAdminDeleteTaxRate(taxRateId)\n *   // ...\n * \n *   const handleDelete = () => {\n *     deleteTaxRate.mutate(void 0, {\n *       onSuccess: ({ id, object, deleted }) => {\n *         console.log(id)\n *       }\n *     })\n *   }\n * \n *   // ...\n * }\n * \n * export default TaxRate\n * \n * @customNamespace Hooks.Admin.Tax Rates\n * @category Mutations\n */\nexport const useAdminDeleteTaxRate = (\n  /**\n   * The tax rate's ID.\n   */\n  id: string,\n  options?: UseMutationOptions<Response<AdminTaxRatesDeleteRes>, Error, void>\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n\n  return useMutation(\n    () => client.admin.taxRates.delete(id),\n    buildOptions(\n      queryClient,\n      [adminTaxRateKeys.lists(), adminTaxRateKeys.detail(id)],\n      options\n    )\n  )\n}\n\n/**\n * This hook adds products to a tax rate.\n * \n * @example\n * import React from \"react\"\n * import { useAdminCreateProductTaxRates } from \"medusa-react\"\n * \n * type Props = {\n *   taxRateId: string\n * }\n * \n * const TaxRate = ({ taxRateId }: Props) => {\n *   const addProduct = useAdminCreateProductTaxRates(taxRateId)\n *   // ...\n * \n *   const handleAddProduct = (productIds: string[]) => {\n *     addProduct.mutate({\n *       products: productIds,\n *     }, {\n *       onSuccess: ({ tax_rate }) => {\n *         console.log(tax_rate.products)\n *       }\n *     })\n *   }\n * \n *   // ...\n * }\n * \n * export default TaxRate\n * \n * @customNamespace Hooks.Admin.Tax Rates\n * @category Mutations\n */\nexport const useAdminCreateProductTaxRates = (\n  /**\n   * The tax rate's ID.\n   */\n  id: string,\n  options?: UseMutationOptions<\n    Response<AdminTaxRatesRes>,\n    Error,\n    AdminPostTaxRatesTaxRateProductsReq\n  >\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n\n  return useMutation(\n    (payload: AdminPostTaxRatesTaxRateProductsReq) =>\n      client.admin.taxRates.addProducts(id, payload),\n    buildOptions(\n      queryClient,\n      [adminTaxRateKeys.lists(), adminTaxRateKeys.detail(id)],\n      options\n    )\n  )\n}\n\n/**\n * This hook removes products from a tax rate. This only removes the association between the products and the tax rate. It does not delete the products.\n * \n * @example\n * import React from \"react\"\n * import { useAdminDeleteProductTaxRates } from \"medusa-react\"\n * \n * type Props = {\n *   taxRateId: string\n * }\n * \n * const TaxRate = ({ taxRateId }: Props) => {\n *   const removeProduct = useAdminDeleteProductTaxRates(taxRateId)\n *   // ...\n * \n *   const handleRemoveProduct = (productIds: string[]) => {\n *     removeProduct.mutate({\n *       products: productIds,\n *     }, {\n *       onSuccess: ({ tax_rate }) => {\n *         console.log(tax_rate.products)\n *       }\n *     })\n *   }\n * \n *   // ...\n * }\n * \n * export default TaxRate\n * \n * @customNamespace Hooks.Admin.Tax Rates\n * @category Mutations\n */\nexport const useAdminDeleteProductTaxRates = (\n  /**\n   * The tax rate's ID.\n   */\n  id: string,\n  options?: UseMutationOptions<\n    Response<AdminTaxRatesRes>,\n    Error,\n    AdminDeleteTaxRatesTaxRateProductsReq\n  >\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n\n  return useMutation(\n    (payload: AdminDeleteTaxRatesTaxRateProductsReq) =>\n      client.admin.taxRates.removeProducts(id, payload),\n    buildOptions(\n      queryClient,\n      [adminTaxRateKeys.lists(), adminTaxRateKeys.detail(id)],\n      options\n    )\n  )\n}\n\n/**\n * This hook adds product types to a tax rate.\n * \n * @example\n * import React from \"react\"\n * import { \n *   useAdminCreateProductTypeTaxRates,\n * } from \"medusa-react\"\n * \n * type Props = {\n *   taxRateId: string\n * }\n * \n * const TaxRate = ({ taxRateId }: Props) => {\n *   const addProductTypes = useAdminCreateProductTypeTaxRates(\n *     taxRateId\n *   )\n *   // ...\n * \n *   const handleAddProductTypes = (productTypeIds: string[]) => {\n *     addProductTypes.mutate({\n *       product_types: productTypeIds,\n *     }, {\n *       onSuccess: ({ tax_rate }) => {\n *         console.log(tax_rate.product_types)\n *       }\n *     })\n *   }\n * \n *   // ...\n * }\n * \n * export default TaxRate\n * \n * @customNamespace Hooks.Admin.Tax Rates\n * @category Mutations\n */\nexport const useAdminCreateProductTypeTaxRates = (\n  /**\n   * The tax rate's ID.\n   */\n  id: string,\n  options?: UseMutationOptions<\n    Response<AdminTaxRatesRes>,\n    Error,\n    AdminPostTaxRatesTaxRateProductTypesReq\n  >\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n\n  return useMutation(\n    (payload: AdminPostTaxRatesTaxRateProductTypesReq) =>\n      client.admin.taxRates.addProductTypes(id, payload),\n    buildOptions(\n      queryClient,\n      [adminTaxRateKeys.lists(), adminTaxRateKeys.detail(id)],\n      options\n    )\n  )\n}\n\n/**\n * This hook removes product types from a tax rate. This only removes the association between the \n * product types and the tax rate. It does not delete the product types.\n * \n * @example\n * import React from \"react\"\n * import { \n *   useAdminDeleteProductTypeTaxRates,\n * } from \"medusa-react\"\n * \n * type Props = {\n *   taxRateId: string\n * }\n * \n * const TaxRate = ({ taxRateId }: Props) => {\n *   const removeProductTypes = useAdminDeleteProductTypeTaxRates(\n *     taxRateId\n *   )\n *   // ...\n * \n *   const handleRemoveProductTypes = (\n *     productTypeIds: string[]\n *   ) => {\n *     removeProductTypes.mutate({\n *       product_types: productTypeIds,\n *     }, {\n *       onSuccess: ({ tax_rate }) => {\n *         console.log(tax_rate.product_types)\n *       }\n *     })\n *   }\n * \n *   // ...\n * }\n * \n * export default TaxRate\n * \n * @customNamespace Hooks.Admin.Tax Rates\n * @category Mutations\n */\nexport const useAdminDeleteProductTypeTaxRates = (\n  /**\n   * The tax rate's ID.\n   */\n  id: string,\n  options?: UseMutationOptions<\n    Response<AdminTaxRatesRes>,\n    Error,\n    AdminDeleteTaxRatesTaxRateProductTypesReq\n  >\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n\n  return useMutation(\n    (payload: AdminDeleteTaxRatesTaxRateProductTypesReq) =>\n      client.admin.taxRates.removeProductTypes(id, payload),\n    buildOptions(\n      queryClient,\n      [adminTaxRateKeys.lists(), adminTaxRateKeys.detail(id)],\n      options\n    )\n  )\n}\n\n/**\n * This hook adds shipping options to a tax rate.\n * \n * @example\n * import React from \"react\"\n * import { useAdminCreateShippingTaxRates } from \"medusa-react\"\n * \n * type Props = {\n *   taxRateId: string\n * }\n * \n * const TaxRate = ({ taxRateId }: Props) => {\n *   const addShippingOption = useAdminCreateShippingTaxRates(\n *     taxRateId\n *   )\n *   // ...\n * \n *   const handleAddShippingOptions = (\n *     shippingOptionIds: string[]\n *   ) => {\n *     addShippingOption.mutate({\n *       shipping_options: shippingOptionIds,\n *     }, {\n *       onSuccess: ({ tax_rate }) => {\n *         console.log(tax_rate.shipping_options)\n *       }\n *     })\n *   }\n * \n *   // ...\n * }\n * \n * export default TaxRate\n * \n * @customNamespace Hooks.Admin.Tax Rates\n * @category Mutations\n */\nexport const useAdminCreateShippingTaxRates = (\n  /**\n   * The tax rate's ID.\n   */\n  id: string,\n  options?: UseMutationOptions<\n    Response<AdminTaxRatesRes>,\n    Error,\n    AdminPostTaxRatesTaxRateShippingOptionsReq\n  >\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n\n  return useMutation(\n    (payload: AdminPostTaxRatesTaxRateShippingOptionsReq) =>\n      client.admin.taxRates.addShippingOptions(id, payload),\n    buildOptions(\n      queryClient,\n      [adminTaxRateKeys.lists(), adminTaxRateKeys.detail(id)],\n      options\n    )\n  )\n}\n\n/**\n * This hook removes shipping options from a tax rate. This only removes the association between \n * the shipping options and the tax rate. It does not delete the shipping options.\n * \n * @example\n * import React from \"react\"\n * import { useAdminDeleteShippingTaxRates } from \"medusa-react\"\n * \n * type Props = {\n *   taxRateId: string\n * }\n * \n * const TaxRate = ({ taxRateId }: Props) => {\n *   const removeShippingOptions = useAdminDeleteShippingTaxRates(\n *     taxRateId\n *   )\n *   // ...\n * \n *   const handleRemoveShippingOptions = (\n *     shippingOptionIds: string[]\n *   ) => {\n *     removeShippingOptions.mutate({\n *       shipping_options: shippingOptionIds,\n *     }, {\n *       onSuccess: ({ tax_rate }) => {\n *         console.log(tax_rate.shipping_options)\n *       }\n *     })\n *   }\n * \n *   // ...\n * }\n * \n * export default TaxRate\n * \n * @customNamespace Hooks.Admin.Tax Rates\n * @category Mutations\n */\nexport const useAdminDeleteShippingTaxRates = (\n  /**\n   * The tax rate's ID.\n   */\n  id: string,\n  options?: UseMutationOptions<\n    Response<AdminTaxRatesRes>,\n    Error,\n    AdminDeleteTaxRatesTaxRateShippingOptionsReq\n  >\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n\n  return useMutation(\n    (payload: AdminDeleteTaxRatesTaxRateShippingOptionsReq) =>\n      client.admin.taxRates.removeShippingOptions(id, payload),\n    buildOptions(\n      queryClient,\n      [adminTaxRateKeys.lists(), adminTaxRateKeys.detail(id)],\n      options\n    )\n  )\n}\n","import {\n  AdminDeleteUploadsReq,\n  AdminDeleteUploadsRes,\n  AdminPostUploadsDownloadUrlReq,\n  AdminUploadsDownloadUrlRes,\n  AdminUploadsRes,\n} from \"@medusajs/medusa\"\nimport { AdminCreateUploadPayload, Response } from \"@medusajs/medusa-js\"\nimport {\n  useMutation,\n  UseMutationOptions,\n  useQueryClient,\n} from \"@tanstack/react-query\"\nimport { useMedusa } from \"../../../contexts\"\nimport { buildOptions } from \"../../utils/buildOptions\"\n\n/**\n * This hook uploads a file to a public bucket or storage. The file upload is handled by the file service installed on the Medusa backend.\n * \n * @example\n * import React from \"react\"\n * import { useAdminUploadFile } from \"medusa-react\"\n * \n * const UploadFile = () => {\n *   const uploadFile = useAdminUploadFile()\n *   // ...\n * \n *   const handleFileUpload = (file: File) => {\n *     uploadFile.mutate(file, {\n *       onSuccess: ({ uploads }) => {\n *         console.log(uploads[0].key)\n *       }\n *     })\n *   }\n * \n *   // ...\n * }\n * \n * export default UploadFile\n * \n * @customNamespace Hooks.Admin.Uploads\n * @category Mutations\n */\nexport const useAdminUploadFile = (\n  options?: UseMutationOptions<\n    Response<AdminUploadsRes>,\n    Error,\n    AdminCreateUploadPayload\n  >\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n\n  return useMutation((payload: AdminCreateUploadPayload) => {\n    return client.admin.uploads.create(payload)\n  }, buildOptions(queryClient, undefined, options))\n}\n\n/**\n * This hook uploads a file to an ACL or a non-public bucket. The file upload is handled by the file service installed on the Medusa backend.\n * \n * @example\n * import React from \"react\"\n * import { useAdminUploadProtectedFile } from \"medusa-react\"\n * \n * const UploadFile = () => {\n *   const uploadFile = useAdminUploadProtectedFile()\n *   // ...\n * \n *   const handleFileUpload = (file: File) => {\n *     uploadFile.mutate(file, {\n *       onSuccess: ({ uploads }) => {\n *         console.log(uploads[0].key)\n *       }\n *     })\n *   }\n * \n *   // ...\n * }\n * \n * export default UploadFile\n * \n * @customNamespace Hooks.Admin.Uploads\n * @category Mutations\n */\nexport const useAdminUploadProtectedFile = (\n  options?: UseMutationOptions<\n    Response<AdminUploadsRes>,\n    Error,\n    AdminCreateUploadPayload\n  >\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n\n  return useMutation((payload: AdminCreateUploadPayload) => {\n    return client.admin.uploads.createProtected(payload)\n  }, buildOptions(queryClient, undefined, options))\n}\n\n/**\n * This hook creates and retrieve a presigned or public download URL for a file. The URL creation is handled by the file service installed on the Medusa backend.\n * \n * @example\n * import React from \"react\"\n * import { useAdminCreatePresignedDownloadUrl } from \"medusa-react\"\n * \n * const Image = () => {\n *   const createPresignedUrl = useAdminCreatePresignedDownloadUrl()\n *   // ...\n * \n *   const handlePresignedUrl = (fileKey: string) => {\n *     createPresignedUrl.mutate({\n *       file_key: fileKey\n *     }, {\n *       onSuccess: ({ download_url }) => {\n *         console.log(download_url)\n *       }\n *     })\n *   }\n * \n *   // ...\n * }\n * \n * export default Image\n * \n * @customNamespace Hooks.Admin.Uploads\n * @category Mutations\n */\nexport const useAdminCreatePresignedDownloadUrl = (\n  options?: UseMutationOptions<\n    Response<AdminUploadsDownloadUrlRes>,\n    Error,\n    AdminPostUploadsDownloadUrlReq\n  >\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n\n  return useMutation(\n    (payload: AdminPostUploadsDownloadUrlReq) =>\n      client.admin.uploads.getPresignedDownloadUrl(payload),\n    buildOptions(queryClient, undefined, options)\n  )\n}\n\n/**\n * This hook deletes an uploaded file from storage. The file is deleted using the installed file service on the Medusa backend.\n * \n * @example\n * import React from \"react\"\n * import { useAdminDeleteFile } from \"medusa-react\"\n * \n * const Image = () => {\n *   const deleteFile = useAdminDeleteFile()\n *   // ...\n * \n *   const handleDeleteFile = (fileKey: string) => {\n *     deleteFile.mutate({\n *       file_key: fileKey\n *     }, {\n *       onSuccess: ({ id, object, deleted }) => {\n *         console.log(id)\n *       }\n *     })\n *   }\n * \n *   // ...\n * }\n * \n * export default Image\n * \n * @customNamespace Hooks.Admin.Uploads\n * @category Mutations\n */\nexport const useAdminDeleteFile = (\n  options?: UseMutationOptions<\n    Response<AdminDeleteUploadsRes>,\n    Error,\n    AdminDeleteUploadsReq\n  >\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n\n  return useMutation(\n    (payload: AdminDeleteUploadsReq) => client.admin.uploads.delete(payload),\n    buildOptions(queryClient, undefined, options)\n  )\n}\n","import {\n  AdminGetUsersParams,\n  AdminUserRes,\n  AdminUsersListRes,\n} from \"@medusajs/medusa\"\nimport { Response } from \"@medusajs/medusa-js\"\nimport { useQuery } from \"@tanstack/react-query\"\nimport { useMedusa } from \"../../../contexts\"\nimport { UseQueryOptionsWrapper } from \"../../../types\"\nimport { queryKeysFactory } from \"../../utils/index\"\n\nconst ADMIN_USERS_QUERY_KEY = `admin_users` as const\n\nexport const adminUserKeys = queryKeysFactory(ADMIN_USERS_QUERY_KEY)\n\ntype UserQueryKeys = typeof adminUserKeys\n\n/**\n * This hook retrieves all admin users.\n *\n * @example\n * To list users:\n *\n * ```tsx\n * import React from \"react\"\n * import { useAdminUsers } from \"medusa-react\"\n *\n * const Users = () => {\n *   const { users, isLoading } = useAdminUsers()\n *\n *   return (\n *     <div>\n *       {isLoading && <span>Loading...</span>}\n *       {users && !users.length && <span>No Users</span>}\n *       {users && users.length > 0 && (\n *         <ul>\n *           {users.map((user) => (\n *             <li key={user.id}>{user.email}</li>\n *           ))}\n *         </ul>\n *       )}\n *     </div>\n *   )\n * }\n *\n * export default Users\n * ```\n *\n * By default, only the first `20` records are retrieved. You can control pagination by specifying the `limit` and `offset` properties:\n *\n * ```tsx\n * import React from \"react\"\n * import { useAdminUsers } from \"medusa-react\"\n *\n * const Users = () => {\n *   const {\n *     users,\n *     limit,\n *     offset,\n *     isLoading\n *   } = useAdminUsers({\n *     limit: 20,\n *     offset: 0\n *   })\n *\n *   return (\n *     <div>\n *       {isLoading && <span>Loading...</span>}\n *       {users && !users.length && <span>No Users</span>}\n *       {users && users.length > 0 && (\n *         <ul>\n *           {users.map((user) => (\n *             <li key={user.id}>{user.email}</li>\n *           ))}\n *         </ul>\n *       )}\n *     </div>\n *   )\n * }\n *\n * export default Users\n * ```\n *\n * @customNamespace Hooks.Admin.Users\n * @category Queries\n */\nexport const useAdminUsers = (\n  query?: AdminGetUsersParams,\n  options?: UseQueryOptionsWrapper<\n    Response<AdminUsersListRes>,\n    Error,\n    ReturnType<UserQueryKeys[\"list\"]>\n  >\n) => {\n  const { client } = useMedusa()\n  const { data, ...rest } = useQuery(\n    adminUserKeys.list(query),\n    () => client.admin.users.list(query),\n    options\n  )\n  return { ...data, ...rest } as const\n}\n\n/**\n * This hook retrieves an admin user's details.\n *\n * @example\n * import React from \"react\"\n * import { useAdminUser } from \"medusa-react\"\n *\n * type Props = {\n *   userId: string\n * }\n *\n * const User = ({ userId }: Props) => {\n *   const { user, isLoading } = useAdminUser(\n *     userId\n *   )\n *\n *   return (\n *     <div>\n *       {isLoading && <span>Loading...</span>}\n *       {user && <span>{user.first_name} {user.last_name}</span>}\n *     </div>\n *   )\n * }\n *\n * export default User\n *\n * @customNamespace Hooks.Admin.Users\n * @category Queries\n */\nexport const useAdminUser = (\n  /**\n   * The user's ID.\n   */\n  id: string,\n  options?: UseQueryOptionsWrapper<\n    Response<AdminUserRes>,\n    Error,\n    ReturnType<UserQueryKeys[\"detail\"]>\n  >\n) => {\n  const { client } = useMedusa()\n  const { data, ...rest } = useQuery(\n    adminUserKeys.detail(id),\n    () => client.admin.users.retrieve(id),\n    options\n  )\n  return { ...data, ...rest } as const\n}\n","import {\n  AdminDeleteUserRes,\n  AdminResetPasswordRequest,\n  AdminResetPasswordTokenRequest,\n  AdminUserRes,\n} from \"@medusajs/medusa\"\nimport {\n  AdminCreateUserPayload,\n  AdminUpdateUserPayload,\n  Response,\n} from \"@medusajs/medusa-js\"\nimport {\n  useMutation,\n  UseMutationOptions,\n  useQueryClient,\n} from \"@tanstack/react-query\"\nimport { adminUserKeys } from \"./queries\"\nimport { useMedusa } from \"../../../contexts/medusa\"\nimport { buildOptions } from \"../../utils/buildOptions\"\n\n/**\n * This hook creates an admin user. The user has the same privileges as all admin users, and will be able to \n * authenticate and perform admin functionalities right after creation.\n * \n * @example\n * import React from \"react\"\n * import { useAdminCreateUser } from \"medusa-react\"\n * \n * const CreateUser = () => {\n *   const createUser = useAdminCreateUser()\n *   // ...\n * \n *   const handleCreateUser = () => {\n *     createUser.mutate({\n *       email: \"user@example.com\",\n *       password: \"supersecret\",\n *     }, {\n *       onSuccess: ({ user }) => {\n *         console.log(user.id)\n *       }\n *     })\n *   }\n * \n *   // ...\n * }\n * \n * export default CreateUser\n * \n * @customNamespace Hooks.Admin.Users\n * @category Mutations\n */\nexport const useAdminCreateUser = (\n  options?: UseMutationOptions<\n    Response<AdminUserRes>,\n    Error,\n    AdminCreateUserPayload\n  >\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n\n  return useMutation(\n    (payload: AdminCreateUserPayload) => client.admin.users.create(payload),\n    buildOptions(queryClient, adminUserKeys.lists(), options)\n  )\n}\n\n/**\n * This hook updates an admin user's details.\n * \n * @example\n * import React from \"react\"\n * import { useAdminUpdateUser } from \"medusa-react\"\n * \n * type Props = {\n *   userId: string\n * }\n * \n * const User = ({ userId }: Props) => {\n *   const updateUser = useAdminUpdateUser(userId)\n *   // ...\n * \n *   const handleUpdateUser = (\n *     firstName: string\n *   ) => {\n *     updateUser.mutate({\n *       first_name: firstName,\n *     }, {\n *       onSuccess: ({ user }) => {\n *         console.log(user.first_name)\n *       }\n *     })\n *   }\n * \n *   // ...\n * }\n * \n * export default User\n * \n * @customNamespace Hooks.Admin.Users\n * @category Mutations\n */\nexport const useAdminUpdateUser = (\n  /**\n   * The user's ID.\n   */\n  id: string,\n  options?: UseMutationOptions<\n    Response<AdminUserRes>,\n    Error,\n    AdminUpdateUserPayload\n  >\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n\n  return useMutation(\n    (payload: AdminUpdateUserPayload) => client.admin.users.update(id, payload),\n    buildOptions(\n      queryClient,\n      [adminUserKeys.lists(), adminUserKeys.detail(id)],\n      options\n    )\n  )\n}\n\n/**\n * This hook deletes a user. Once deleted, the user will not be able to authenticate or perform admin functionalities.\n * \n * @example\n * import React from \"react\"\n * import { useAdminDeleteUser } from \"medusa-react\"\n * \n * type Props = {\n *   userId: string\n * }\n * \n * const User = ({ userId }: Props) => {\n *   const deleteUser = useAdminDeleteUser(userId)\n *   // ...\n * \n *   const handleDeleteUser = () => {\n *     deleteUser.mutate(void 0, {\n *       onSuccess: ({ id, object, deleted }) => {\n *         console.log(id)\n *       }\n *     })\n *   }\n * \n *   // ...\n * }\n * \n * export default User\n * \n * @customNamespace Hooks.Admin.Users\n * @category Mutations\n */\nexport const useAdminDeleteUser = (\n  /**\n   * The user's ID.\n   */\n  id: string,\n  options?: UseMutationOptions<Response<AdminDeleteUserRes>, Error, void>\n) => {\n  const { client } = useMedusa()\n  const queryClient = useQueryClient()\n\n  return useMutation(\n    () => client.admin.users.delete(id),\n    buildOptions(\n      queryClient,\n      [adminUserKeys.detail(id), adminUserKeys.lists()],\n      options\n    )\n  )\n}\n\n/**\n * This hook resets the password of an admin user using their reset password token. You must generate a reset password token first \n * for the user using the {@link useAdminSendResetPasswordToken} hook, then use that token to reset the password in this hook.\n * \n * @example\n * import React from \"react\"\n * import { useAdminResetPassword } from \"medusa-react\"\n * \n * const ResetPassword = () => {\n *   const resetPassword = useAdminResetPassword()\n *   // ...\n * \n *   const handleResetPassword = (\n *     token: string,\n *     password: string\n *   ) => {\n *     resetPassword.mutate({\n *       token,\n *       password,\n *     }, {\n *       onSuccess: ({ user }) => {\n *         console.log(user.id)\n *       }\n *     })\n *   }\n * \n *   // ...\n * }\n * \n * export default ResetPassword\n * \n * @customNamespace Hooks.Admin.Users\n * @category Mutations\n */\nexport const useAdminResetPassword = (\n  options?: UseMutationOptions<\n    Response<AdminUserRes>,\n    Error,\n    AdminResetPasswordRequest\n  >\n) => {\n  const { client } = useMedusa()\n  return useMutation(\n    (payload: AdminResetPasswordRequest) =>\n      client.admin.users.resetPassword(payload),\n    options\n  )\n}\n\n/**\n * This hook generates a password token for an admin user with a given email. This also triggers the `user.password_reset` event. So, if you have a Notification Service installed\n * that can handle this event, a notification, such as an email, will be sent to the user. The token is triggered as part of the `user.password_reset` event's payload. \n * That token must be used later to reset the password using the {@link useAdminResetPassword} hook.\n * \n * @example\n * import React from \"react\"\n * import { useAdminSendResetPasswordToken } from \"medusa-react\"\n * \n * const Login = () => {\n *   const requestPasswordReset = useAdminSendResetPasswordToken()\n *   // ...\n * \n *   const handleResetPassword = (\n *     email: string\n *   ) => {\n *     requestPasswordReset.mutate({\n *       email\n *     }, {\n *       onSuccess: () => {\n *         // successful\n *       }\n *     })\n *   }\n * \n *   // ...\n * }\n * \n * export default Login\n * \n * @customNamespace Hooks.Admin.Users\n * @category Mutations\n */\nexport const useAdminSendResetPasswordToken = (\n  options?: UseMutationOptions<\n    Response<void>,\n    Error,\n    AdminResetPasswordTokenRequest\n  >\n) => {\n  const { client } = useMedusa()\n  return useMutation(\n    (payload: AdminResetPasswordTokenRequest) =>\n      client.admin.users.sendResetPasswordToken(payload),\n    options\n  )\n}\n"],"mappings":"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","names":["Medusa","QueryClientProvider","React","MedusaContext","useMedusa","context","MedusaProvider","queryClientProviderProps","baseUrl","apiKey","publishableApiKey","customHeaders","maxRetries","children","medusaClient","React","useContext","useEffect","isObject","input","isArray","isEmpty","formatVariantPrice","variant","region","includeTaxes","rest","amount","computeVariantPrice","convertToLocale","getVariantPrice","computeAmount","p","toDecimal","convertToDecimal","taxRate","getTaxRate","formatAmount","taxAwareAmount","noDivisionCurrencies","divisor","isEmpty","currency_code","minimumFractionDigits","maximumFractionDigits","locale","queryKeysFactory","globalKey","queryKeyFactory","query","id","React","useLocalStorage","key","initialState","item","setItem","data","SessionCartContext","React","reducer","state","action","generateCartState","duplicateVariantIndex","item","items","newItems","generateItems","sum","calculateSessionCartTotal","region","getVariantPrice","total","defaultInitialState","SessionCartProvider","initialState","children","saved","save","useLocalStorage","dispatch","React","useEffect","setRegion","isObject","isEmpty","getItem","id","setItems","isArray","addItem","updateItem","updateItemQuantity","quantity","incrementItemQuantity","decrementItemQuantity","removeItem","clearItems","SessionCartContext","useSessionCart","context","useContext","React","useState","useQuery","CARTS_QUERY_KEY","cartKeys","queryKeysFactory","useGetCart","id","options","client","useMedusa","data","rest","useQuery","useMutation","useCreateCart","options","client","useMedusa","useMutation","data","useUpdateCart","cartId","useCompleteCart","useCreatePaymentSession","useUpdatePaymentSession","provider_id","useRefreshPaymentSession","useSetPaymentSession","useAddShippingMethodToCart","useDeletePaymentSession","useStartCheckout","cart","useQuery","COLLECTIONS_QUERY_KEY","collectionKeys","queryKeysFactory","useCollection","id","options","client","useMedusa","data","rest","useQuery","useCollections","query","useQuery","CUSTOMERS_QUERY_KEY","customerKeys","queryKeysFactory","id","useMeCustomer","options","client","useMedusa","data","rest","useQuery","useCustomerOrders","query","useMutation","useCreateCustomer","options","client","useMedusa","useMutation","data","useUpdateMe","id","useQuery","GIFT_CARDS_QUERY_KEY","giftCardKeys","queryKeysFactory","useGiftCard","id","options","client","useMedusa","data","rest","useQuery","useMutation","useCreateLineItem","cartId","options","client","useMedusa","useMutation","data","useUpdateLineItem","lineId","useDeleteLineItem","useQuery","ORDER_EDITS_QUERY_KEY","orderEditQueryKeys","queryKeysFactory","useOrderEdit","id","options","client","useMedusa","data","rest","useQuery","useMutation","useQueryClient","buildOptions","queryClient","queryKey","options","args","key","useDeclineOrderEdit","id","options","client","useMedusa","queryClient","useQueryClient","useMutation","payload","buildOptions","orderEditQueryKeys","useCompleteOrderEdit","useQuery","ORDERS_QUERY_KEY","orderKeys","queryKeysFactory","cartId","useOrder","id","options","client","useMedusa","data","rest","useQuery","useCartOrder","useOrders","query","useMutation","useQueryClient","useRequestOrderAccess","options","client","useMedusa","queryClient","useQueryClient","useMutation","payload","buildOptions","orderKeys","useGrantOrderAccess","useQuery","PAYMENT_COLLECTION_QUERY_KEY","paymentCollectionQueryKeys","queryKeysFactory","usePaymentCollection","id","options","client","useMedusa","data","rest","useQuery","useMutation","useQueryClient","useManageMultiplePaymentSessions","id","options","client","useMedusa","queryClient","useQueryClient","useMutation","payload","buildOptions","paymentCollectionQueryKeys","useManagePaymentSession","useAuthorizePaymentSession","session_id","useAuthorizePaymentSessionsBatch","usePaymentCollectionRefreshPaymentSession","useQuery","STORE_PRODUCT_CATEGORIES_QUERY_KEY","storeProductCategoryKeys","queryKeysFactory","useProductCategories","query","options","client","useMedusa","data","rest","useQuery","useProductCategory","id","useQuery","PRODUCT_TAGS_QUERY_KEY","productTagKeys","queryKeysFactory","useProductTags","query","options","client","useMedusa","data","rest","useQuery","useQuery","PRODUCT_TYPES_QUERY_KEY","productTypeKeys","queryKeysFactory","useProductTypes","query","options","client","useMedusa","data","rest","useQuery","useQuery","PRODUCTS_QUERY_KEY","productKeys","queryKeysFactory","useProducts","query","options","client","useMedusa","data","rest","useQuery","useProduct","id","useQuery","REGIONS_QUERY_KEY","regionsKey","queryKeysFactory","useRegions","options","client","useMedusa","data","rest","useQuery","useRegion","id","useQuery","RETURNS_REASONS_QUERY_KEY","returnReasonsKey","queryKeysFactory","useReturnReasons","options","client","useMedusa","data","rest","useQuery","useReturnReason","id","useMutation","useCreateReturn","options","client","useMedusa","useMutation","data","useQuery","SHIPPING_OPTION_QUERY_KEY","shippingOptionKey","queryKeysFactory","cartId","useShippingOptions","query","options","client","useMedusa","data","rest","useQuery","useCartShippingOptions","useQuery","SWAPS_QUERY_KEY","swapKey","queryKeysFactory","cartId","useCartSwap","options","client","useMedusa","data","rest","useQuery","useMutation","useCreateSwap","options","client","useMedusa","useMutation","data","CartContext","React","useCart","context","defaultInitialState","CartProvider","children","initialState","cart","setCart","useState","createCart","useCreateCart","updateCart","useUpdateCart","addShippingMethod","useAddShippingMethodToCart","startCheckout","useCreatePaymentSession","pay","useSetPaymentSession","completeCheckout","useCompleteCart","totalItems","i","acc","curr","useQuery","ADMIN_AUTH_QUERY_KEY","adminAuthKeys","queryKeysFactory","useAdminGetSession","options","client","useMedusa","data","rest","useQuery","useMutation","useQueryClient","useAdminLogin","options","client","useMedusa","queryClient","useQueryClient","useMutation","payload","buildOptions","adminAuthKeys","useAdminDeleteSession","useQuery","ADMIN_COLLECTIONS_QUERY_KEY","adminBatchJobsKeys","queryKeysFactory","useAdminBatchJobs","query","options","client","useMedusa","data","rest","useQuery","useAdminBatchJob","id","useMutation","useQueryClient","useAdminCreateBatchJob","options","client","useMedusa","queryClient","useQueryClient","useMutation","payload","buildOptions","adminBatchJobsKeys","useAdminCancelBatchJob","id","useAdminConfirmBatchJob","useMutation","useQueryClient","useQuery","ADMIN_PRODUCTS_QUERY_KEY","adminProductKeys","queryKeysFactory","id","query","useAdminProducts","options","client","useMedusa","data","rest","useQuery","useAdminProduct","useAdminProductVariants","useAdminProductTagUsage","useMutation","useQueryClient","useAdminCreateProduct","options","client","useMedusa","queryClient","useQueryClient","useMutation","payload","buildOptions","adminProductKeys","useAdminUpdateProduct","id","useAdminDeleteProduct","useAdminCreateVariant","productId","useAdminUpdateVariant","variant_id","useAdminDeleteVariant","variantId","useAdminCreateProductOption","useAdminUpdateProductOption","option_id","useAdminDeleteProductOption","optionId","useQuery","ADMIN_VARIANT_QUERY_KEY","adminVariantKeys","queryKeysFactory","useAdminVariants","query","options","client","useMedusa","data","rest","useQuery","useAdminVariant","id","useAdminVariantsInventory","useQuery","ADMIN_ORDERS_QUERY_KEY","adminOrderKeys","queryKeysFactory","id","query","useAdminOrders","options","client","useMedusa","data","rest","useQuery","useAdminOrder","useAdminCreateClaim","orderId","options","client","useMedusa","queryClient","useQueryClient","useMutation","payload","buildOptions","adminOrderKeys","useAdminUpdateClaim","claim_id","useAdminCancelClaim","claimId","useAdminFulfillClaim","adminVariantKeys","adminProductKeys","useAdminCancelClaimFulfillment","fulfillment_id","useAdminCreateClaimShipment","useQuery","ADMIN_COLLECTIONS_QUERY_KEY","adminCollectionKeys","queryKeysFactory","useAdminCollections","query","options","client","useMedusa","data","rest","useQuery","useAdminCollection","id","useMutation","useQueryClient","useAdminCreateCollection","options","client","useMedusa","queryClient","useQueryClient","useMutation","payload","buildOptions","adminCollectionKeys","useAdminUpdateCollection","id","useAdminDeleteCollection","useAdminAddProductsToCollection","useAdminRemoveProductsFromCollection","useMutation","useQueryClient","useQuery","ADMIN_CURRENCIES_QUERY_KEY","adminCurrenciesKeys","queryKeysFactory","useAdminCurrencies","query","options","client","useMedusa","data","rest","useQuery","useAdminUpdateCurrency","code","options","client","useMedusa","queryClient","useQueryClient","useMutation","payload","buildOptions","adminCurrenciesKeys","useMutation","useQueryClient","useQuery","ADMIN_CUSTOMER_GROUPS_QUERY_KEY","adminCustomerGroupKeys","queryKeysFactory","id","query","useAdminCustomerGroup","options","client","useMedusa","data","rest","useQuery","useAdminCustomerGroups","useAdminCustomerGroupCustomers","useMutation","useQueryClient","useAdminCreateCustomerGroup","options","client","useMedusa","queryClient","useQueryClient","useMutation","payload","buildOptions","adminCustomerGroupKeys","useAdminUpdateCustomerGroup","id","useAdminDeleteCustomerGroup","useAdminAddCustomersToCustomerGroup","useAdminRemoveCustomersFromCustomerGroup","useQuery","ADMIN_CUSTOMERS_QUERY_KEY","adminCustomerKeys","queryKeysFactory","useAdminCustomers","query","options","client","useMedusa","data","rest","useQuery","useAdminCustomer","id","useMutation","useQueryClient","useAdminCreateCustomer","options","client","useMedusa","queryClient","useQueryClient","useMutation","payload","buildOptions","adminCustomerKeys","useAdminUpdateCustomer","id","useQuery","ADMIN_DISCOUNTS_QUERY_KEY","adminDiscountKeys","queryKeysFactory","id","query","useAdminDiscounts","options","client","useMedusa","data","rest","useQuery","useAdminDiscount","useAdminGetDiscountByCode","code","useAdminGetDiscountCondition","conditionId","useMutation","useQueryClient","useAdminAddDiscountConditionResourceBatch","discountId","conditionId","query","options","client","useMedusa","queryClient","useQueryClient","useMutation","payload","buildOptions","adminDiscountKeys","useAdminDeleteDiscountConditionResourceBatch","useAdminCreateDiscount","useAdminUpdateDiscount","id","useAdminDeleteDiscount","useAdminDiscountAddRegion","regionId","useAdminDiscountRemoveRegion","useAdminCreateDynamicDiscountCode","useAdminDeleteDynamicDiscountCode","code","useAdminDiscountCreateCondition","useAdminDiscountUpdateCondition","useAdminDiscountRemoveCondition","useQuery","ADMIN_GIFT_CARDS_QUERY_KEY","adminGiftCardKeys","queryKeysFactory","useAdminGiftCards","query","options","client","useMedusa","data","rest","useQuery","useAdminGiftCard","id","useMutation","useQueryClient","useAdminCreateGiftCard","options","client","useMedusa","queryClient","useQueryClient","useMutation","payload","buildOptions","adminGiftCardKeys","useAdminUpdateGiftCard","id","useAdminDeleteGiftCard","useMutation","useQueryClient","useAdminUpdateOrder","id","options","client","useMedusa","queryClient","useQueryClient","useMutation","payload","buildOptions","adminOrderKeys","useAdminCancelOrder","useAdminCompleteOrder","useAdminCapturePayment","useAdminRefundPayment","useAdminCreateFulfillment","orderId","adminVariantKeys","adminProductKeys","useAdminCancelFulfillment","fulfillmentId","useAdminCreateShipment","useAdminRequestReturn","useAdminAddShippingMethod","useAdminArchiveOrder","useQuery","ADMIN_PRICE_LISTS_QUERY_KEY","adminPriceListKeys","queryKeysFactory","id","query","useAdminPriceLists","options","client","useMedusa","data","rest","useQuery","useAdminPriceListProducts","useAdminPriceList","useMutation","useQueryClient","useAdminCreatePriceList","options","client","useMedusa","queryClient","useQueryClient","useMutation","payload","buildOptions","adminPriceListKeys","useAdminUpdatePriceList","id","useAdminDeletePriceList","useAdminCreatePriceListPrices","useAdminDeletePriceListPrices","useAdminDeletePriceListProductsPrices","useAdminDeletePriceListProductPrices","productId","adminProductKeys","useAdminDeletePriceListVariantPrices","variantId","adminVariantKeys","invalidateRelatedDomain","queryClient","domain","adminProductKeys","adminCustomerKeys","adminCustomerGroupKeys","adminOrderKeys","adminDiscountKeys","adminGiftCardKeys","adminPriceListKeys","buildCustomOptions","queryKey","options","relatedDomains","args","key","useAdminCustomPost","path","client","useMedusa","useQueryClient","useMutation","payload","useAdminCustomDelete","useQuery","useAdminCustomQuery","path","queryKey","query","options","client","useMedusa","data","rest","useQuery","useQuery","ADMIN_DRAFT_ORDERS_QUERY_KEY","adminDraftOrderKeys","queryKeysFactory","useAdminDraftOrders","query","options","client","useMedusa","data","rest","useQuery","useAdminDraftOrder","id","useMutation","useQueryClient","useAdminCreateDraftOrder","options","client","useMedusa","queryClient","useQueryClient","useMutation","payload","buildOptions","adminDraftOrderKeys","useAdminUpdateDraftOrder","id","useAdminDeleteDraftOrder","useAdminDraftOrderRegisterPayment","useAdminDraftOrderAddLineItem","useAdminDraftOrderRemoveLineItem","itemId","useAdminDraftOrderUpdateLineItem","item_id","useQuery","ADMIN_INVENTORY_ITEMS_QUERY_KEY","adminInventoryItemsKeys","queryKeysFactory","useAdminInventoryItems","query","options","client","useMedusa","data","rest","useAdminInventoryItem","inventoryItemId","useAdminInventoryItemLocationLevels","useMutation","useQueryClient","useAdminCreateInventoryItem","options","client","useMedusa","queryClient","useQueryClient","useMutation","payload","query","buildOptions","adminInventoryItemsKeys","useAdminUpdateInventoryItem","inventoryItemId","useAdminDeleteInventoryItem","useAdminUpdateLocationLevel","useAdminDeleteLocationLevel","stockLocationId","useAdminCreateLocationLevel","useQuery","ADMIN_INVITES_QUERY_KEY","adminInviteKeys","queryKeysFactory","useAdminInvites","options","client","useMedusa","data","rest","useQuery","useMutation","useQueryClient","useAdminAcceptInvite","options","client","useMedusa","queryClient","useQueryClient","useMutation","payload","buildOptions","adminInviteKeys","useAdminResendInvite","id","useAdminCreateInvite","useAdminDeleteInvite","useQuery","ADMIN_NOTE_QUERY_KEY","adminNoteKeys","queryKeysFactory","useAdminNotes","query","options","client","useMedusa","data","rest","useQuery","useAdminNote","id","useMutation","useQueryClient","useAdminCreateNote","options","client","useMedusa","queryClient","useQueryClient","useMutation","payload","buildOptions","adminNoteKeys","useAdminUpdateNote","id","useAdminDeleteNote","useQuery","ADMIN_NOTIFICATIONS_QUERY_KEY","adminNotificationKeys","queryKeysFactory","useAdminNotifications","query","options","client","useMedusa","data","rest","useQuery","useMutation","useQueryClient","useAdminResendNotification","id","options","client","useMedusa","queryClient","useQueryClient","useMutation","payload","buildOptions","adminNotificationKeys","useQuery","ADMIN_ORDER_EDITS_QUERY_KEY","adminOrderEditsKeys","queryKeysFactory","useAdminOrderEdit","id","query","options","client","useMedusa","data","rest","useQuery","useAdminOrderEdits","useMutation","useQueryClient","useAdminCreateOrderEdit","options","client","useMedusa","queryClient","useQueryClient","useMutation","payload","buildOptions","adminOrderEditsKeys","adminOrderKeys","useAdminDeleteOrderEdit","id","useAdminDeleteOrderEditItemChange","orderEditId","itemChangeId","useAdminOrderEditUpdateLineItem","itemId","useAdminOrderEditDeleteLineItem","useAdminUpdateOrderEdit","useAdminOrderEditAddLineItem","useAdminRequestOrderEditConfirmation","useAdminCancelOrderEdit","useAdminConfirmOrderEdit","useQuery","PAYMENT_COLLECTION_QUERY_KEY","adminPaymentCollectionQueryKeys","queryKeysFactory","useAdminPaymentCollection","id","options","client","useMedusa","data","rest","useQuery","useMutation","useQueryClient","useAdminDeletePaymentCollection","id","options","client","useMedusa","queryClient","useQueryClient","useMutation","buildOptions","adminPaymentCollectionQueryKeys","useAdminUpdatePaymentCollection","payload","useAdminMarkPaymentCollectionAsAuthorized","useQuery","PAYMENT_QUERY_KEY","adminPaymentQueryKeys","queryKeysFactory","useAdminPayment","id","options","client","useMedusa","data","rest","useQuery","useMutation","useQueryClient","useAdminPaymentsCapturePayment","id","options","client","useMedusa","queryClient","useQueryClient","useMutation","buildOptions","adminPaymentQueryKeys","useAdminPaymentsRefundPayment","payload","useQuery","ADMIN_PRODUCT_CATEGORIES_QUERY_KEY","adminProductCategoryKeys","queryKeysFactory","useAdminProductCategories","query","options","client","useMedusa","data","rest","useQuery","useAdminProductCategory","id","useMutation","useQueryClient","useAdminCreateProductCategory","options","client","useMedusa","queryClient","useQueryClient","useMutation","payload","buildOptions","adminProductCategoryKeys","adminProductKeys","useAdminUpdateProductCategory","id","useAdminDeleteProductCategory","useAdminAddProductsToCategory","useAdminDeleteProductsFromCategory","useQuery","ADMIN_PRODUCT_TAGS_QUERY_KEY","adminProductTagKeys","queryKeysFactory","useAdminProductTags","query","options","client","useMedusa","data","rest","useQuery","useQuery","ADMIN_PRODUCT_TYPES_QUERY_KEY","adminProductTypeKeys","queryKeysFactory","useAdminProductTypes","query","options","client","useMedusa","data","rest","useQuery","useQuery","ADMIN_PUBLISHABLE_API_KEYS_QUERY_KEY","adminPublishableApiKeysKeys","queryKeysFactory","id","query","useAdminPublishableApiKey","options","client","useMedusa","data","rest","useQuery","useAdminPublishableApiKeys","useAdminPublishableApiKeySalesChannels","useMutation","useQueryClient","useAdminCreatePublishableApiKey","options","client","useMedusa","queryClient","useQueryClient","useMutation","payload","buildOptions","adminPublishableApiKeysKeys","useAdminUpdatePublishableApiKey","id","useAdminDeletePublishableApiKey","useAdminRevokePublishableApiKey","useAdminAddPublishableKeySalesChannelsBatch","useAdminRemovePublishableKeySalesChannelsBatch","useQuery","ADMIN_REGIONS_QUERY_KEY","adminRegionKeys","queryKeysFactory","useAdminRegions","query","options","client","useMedusa","data","rest","useQuery","useAdminRegion","id","useAdminRegionFulfillmentOptions","regionId","useMutation","useQueryClient","useAdminCreateRegion","options","client","useMedusa","queryClient","useQueryClient","useMutation","payload","buildOptions","adminRegionKeys","useAdminUpdateRegion","id","useAdminDeleteRegion","useAdminRegionAddCountry","useAdminRegionRemoveCountry","country_code","useAdminRegionAddFulfillmentProvider","useAdminRegionDeleteFulfillmentProvider","provider_id","useAdminRegionAddPaymentProvider","useAdminRegionDeletePaymentProvider","useMutation","useQueryClient","useQuery","ADMIN_RESERVATIONS_QUERY_KEY","adminReservationsKeys","queryKeysFactory","useAdminReservations","query","options","client","useMedusa","data","rest","useQuery","useAdminReservation","id","useAdminCreateReservation","options","client","useMedusa","queryClient","useQueryClient","useMutation","payload","buildOptions","adminReservationsKeys","adminVariantKeys","useAdminUpdateReservation","id","adminInventoryItemsKeys","useAdminDeleteReservation","useQuery","ADMIN_RETURNS_REASONS_QUERY_KEY","adminReturnReasonKeys","queryKeysFactory","useAdminReturnReasons","options","client","useMedusa","data","rest","useQuery","useAdminReturnReason","id","useMutation","useQueryClient","useAdminCreateReturnReason","options","client","useMedusa","queryClient","useQueryClient","useMutation","payload","buildOptions","adminReturnReasonKeys","useAdminUpdateReturnReason","id","useAdminDeleteReturnReason","useQuery","ADMIN_RETURNS_QUERY_KEY","adminReturnKeys","queryKeysFactory","useAdminReturns","options","client","useMedusa","data","rest","useQuery","useMutation","useQueryClient","useAdminReceiveReturn","id","options","client","useMedusa","queryClient","useQueryClient","useMutation","payload","buildOptions","adminReturnKeys","useAdminCancelReturn","useQuery","ADMIN_SALES_CHANNELS_QUERY_KEY","adminSalesChannelsKeys","queryKeysFactory","useAdminSalesChannel","id","options","client","useMedusa","data","rest","useQuery","useAdminSalesChannels","query","useMutation","useQueryClient","useQuery","ADMIN_STOCK_LOCATIONS_QUERY_KEY","adminStockLocationsKeys","queryKeysFactory","useAdminStockLocations","query","options","client","useMedusa","data","rest","useQuery","useAdminStockLocation","id","useMutation","useQueryClient","useAdminCreateStockLocation","options","client","useMedusa","queryClient","useQueryClient","useMutation","payload","buildOptions","adminStockLocationsKeys","useAdminUpdateStockLocation","id","useAdminDeleteStockLocation","adminVariantKeys","adminProductKeys","useAdminCreateSalesChannel","options","client","useMedusa","queryClient","useQueryClient","useMutation","payload","buildOptions","adminSalesChannelsKeys","useAdminUpdateSalesChannel","id","useAdminDeleteSalesChannel","useAdminDeleteProductsFromSalesChannel","adminProductKeys","useAdminAddProductsToSalesChannel","useAdminAddLocationToSalesChannel","sales_channel_id","location_id","adminStockLocationsKeys","useAdminRemoveLocationFromSalesChannel","useQuery","ADMIN_SHIPPING_OPTIONS_QUERY_KEY","adminShippingOptionKeys","queryKeysFactory","useAdminShippingOptions","query","options","client","useMedusa","data","rest","useQuery","useAdminShippingOption","id","useMutation","useQueryClient","useAdminCreateShippingOption","options","client","useMedusa","queryClient","useQueryClient","useMutation","payload","buildOptions","adminShippingOptionKeys","useAdminUpdateShippingOption","id","useAdminDeleteShippingOption","useQuery","ADMIN_COLLECTIONS_QUERY_KEY","adminShippingProfileKeys","queryKeysFactory","useAdminShippingProfiles","options","client","useMedusa","data","rest","useQuery","useAdminShippingProfile","id","useMutation","useQueryClient","useAdminCreateShippingProfile","options","client","useMedusa","queryClient","useQueryClient","useMutation","payload","buildOptions","adminShippingProfileKeys","useAdminUpdateShippingProfile","id","useAdminDeleteShippingProfile","useQuery","ADMIN_STORE_QUERY_KEY","adminStoreKeys","queryKeysFactory","useAdminStorePaymentProviders","options","client","useMedusa","data","rest","useQuery","useAdminStoreTaxProviders","useAdminStore","useMutation","useQueryClient","useAdminUpdateStore","options","client","useMedusa","queryClient","useQueryClient","useMutation","payload","buildOptions","adminStoreKeys","useAdminAddStoreCurrency","currency_code","useAdminDeleteStoreCurrency","useQuery","ADMIN_SWAPS_QUERY_KEY","adminSwapKeys","queryKeysFactory","useAdminSwaps","query","options","client","useMedusa","data","rest","useQuery","useAdminSwap","id","useMutation","useQueryClient","useAdminCreateSwap","orderId","options","client","useMedusa","queryClient","useQueryClient","useMutation","payload","buildOptions","adminOrderKeys","adminSwapKeys","useAdminCancelSwap","swapId","useAdminFulfillSwap","swap_id","adminVariantKeys","adminProductKeys","useAdminCreateSwapShipment","useAdminProcessSwapPayment","useAdminCancelSwapFulfillment","fulfillment_id","useQuery","ADMIN_TAX_RATES_QUERY_KEY","adminTaxRateKeys","queryKeysFactory","useAdminTaxRates","query","options","client","useMedusa","data","rest","useQuery","useAdminTaxRate","id","useMutation","useQueryClient","useAdminCreateTaxRate","options","client","useMedusa","queryClient","useQueryClient","useMutation","payload","buildOptions","adminTaxRateKeys","useAdminUpdateTaxRate","id","useAdminDeleteTaxRate","useAdminCreateProductTaxRates","useAdminDeleteProductTaxRates","useAdminCreateProductTypeTaxRates","useAdminDeleteProductTypeTaxRates","useAdminCreateShippingTaxRates","useAdminDeleteShippingTaxRates","useMutation","useQueryClient","useAdminUploadFile","options","client","useMedusa","queryClient","useQueryClient","useMutation","payload","buildOptions","useAdminUploadProtectedFile","useAdminCreatePresignedDownloadUrl","useAdminDeleteFile","useQuery","ADMIN_USERS_QUERY_KEY","adminUserKeys","queryKeysFactory","useAdminUsers","query","options","client","useMedusa","data","rest","useQuery","useAdminUser","id","useMutation","useQueryClient","useAdminCreateUser","options","client","useMedusa","queryClient","useQueryClient","useMutation","payload","buildOptions","adminUserKeys","useAdminUpdateUser","id","useAdminDeleteUser","useAdminResetPassword","useAdminSendResetPasswordToken"]}