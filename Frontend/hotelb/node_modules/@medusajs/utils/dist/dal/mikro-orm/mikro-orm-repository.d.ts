import { Context, DAL, FilterQuery as InternalFilterQuery, RepositoryTransformOptions } from "@medusajs/types";
import { EntitySchema } from "@mikro-orm/core";
import { EntityClass } from "@mikro-orm/core/typings";
export declare class MikroOrmBase<T = any> {
    readonly manager_: any;
    protected constructor({ manager }: {
        manager: any;
    });
    getFreshManager<TManager = unknown>(): TManager;
    getActiveManager<TManager = unknown>({ transactionManager, manager }?: Context): TManager;
    transaction<TManager = unknown>(task: (transactionManager: TManager) => Promise<any>, options?: {
        isolationLevel?: string;
        enableNestedTransactions?: boolean;
        transaction?: TManager;
    }): Promise<any>;
    serialize<TOutput extends object | object[]>(data: any, options?: any): Promise<TOutput>;
}
/**
 * Privileged extends of the abstract classes unless most of the methods can't be implemented
 * in your repository. This base repository is also used to provide a base repository
 * injection if needed to be able to use the common methods without being related to an entity.
 * In this case, none of the method will be implemented except the manager and transaction
 * related ones.
 */
export declare class MikroOrmBaseRepository<T extends object = object> extends MikroOrmBase<T> {
    constructor(...args: any[]);
    create(data: unknown[], context?: Context): Promise<T[]>;
    update(data: unknown[], context?: Context): Promise<T[]>;
    delete(ids: string[] | object[], context?: Context): Promise<void>;
    find(options?: DAL.FindOptions<T>, context?: Context): Promise<T[]>;
    findAndCount(options?: DAL.FindOptions<T>, context?: Context): Promise<[T[], number]>;
    upsert(data: unknown[], context?: Context): Promise<T[]>;
    softDelete(idsOrFilter: string[] | InternalFilterQuery, { transactionManager: manager }?: Context): Promise<[T[], Record<string, unknown[]>]>;
    restore(idsOrFilter: string[] | InternalFilterQuery, { transactionManager: manager }?: Context): Promise<[T[], Record<string, unknown[]>]>;
    applyFreeTextSearchFilters<T>(findOptions: DAL.FindOptions<T & {
        q?: string;
    }>, retrieveConstraintsToApply: (q: string) => any[]): void;
}
export declare class MikroOrmBaseTreeRepository<T extends object = object> extends MikroOrmBase<T> {
    constructor();
    find(options?: DAL.FindOptions, transformOptions?: RepositoryTransformOptions, context?: Context): Promise<T[]>;
    findAndCount(options?: DAL.FindOptions, transformOptions?: RepositoryTransformOptions, context?: Context): Promise<[T[], number]>;
    create(data: unknown, context?: Context): Promise<T>;
    delete(id: string, context?: Context): Promise<void>;
}
type DtoBasedMutationMethods = "create" | "update";
export declare function mikroOrmBaseRepositoryFactory<T extends object = object, TDTOs extends {
    [K in DtoBasedMutationMethods]?: any;
} = {
    [K in DtoBasedMutationMethods]?: any;
}>(entity: EntityClass<T> | EntitySchema<T>): {
    new (...args: any[]): {
        create(data: TDTOs["create"][], context?: Context): Promise<T[]>;
        update(data: TDTOs["update"][], context?: Context): Promise<T[]>;
        delete(primaryKeyValues: string[] | object[], context?: Context): Promise<void>;
        find(options?: DAL.FindOptions<T>, context?: Context): Promise<T[]>;
        findAndCount(findOptions?: DAL.FindOptions<T>, context?: Context): Promise<[T[], number]>;
        upsert(data: (TDTOs["create"] | TDTOs["update"])[], context?: Context): Promise<T[]>;
        softDelete(idsOrFilter: string[] | {
            [x: string]: any;
        }, { transactionManager: manager }?: Context): Promise<[T[], Record<string, unknown[]>]>;
        restore(idsOrFilter: string[] | {
            [x: string]: any;
        }, { transactionManager: manager }?: Context): Promise<[T[], Record<string, unknown[]>]>;
        applyFreeTextSearchFilters<T>(findOptions: DAL.FindOptions<T & {
            q?: string | undefined;
        }>, retrieveConstraintsToApply: (q: string) => any[]): void;
        readonly manager_: any;
        getFreshManager<TManager = unknown>(): TManager;
        getActiveManager<TManager_1 = unknown>({ transactionManager, manager }?: Context): TManager_1;
        transaction<TManager_2 = unknown>(task: (transactionManager: TManager_2) => Promise<any>, options?: {
            isolationLevel?: string | undefined;
            enableNestedTransactions?: boolean | undefined;
            transaction?: TManager_2 | undefined;
        }): Promise<any>;
        serialize<TOutput extends object | object[]>(data: any, options?: any): Promise<TOutput>;
    };
    buildUniqueCompositeKeyValue(keys: string[], data: object): string;
    retrievePrimaryKeys(entity: EntityClass<T> | EntitySchema<T>): (keyof T & string)[];
};
export {};
